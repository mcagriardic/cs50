 1/1: $ pip install camelot-py
 1/2: pip install camelot-py
 1/3: import pip
 1/4: pip.main(['install', 'camelot'])
 1/5:
import pip
import main from pip
 1/6: pip.main(['install', 'camelot'])
 1/7:
import pip
from main import pip
 1/8:
import pip
from pip import main
 1/9: import camelot
 2/1: import camelot
 2/2: !{sys.executable} -m pip install camelot
 2/3: ! -m pip install camelot
 2/4: ! py -m pip install camelot
 2/5: import camelot
 2/6: $ python -m pip install camelot
 2/7: ! python -m pip install camelot
 2/8:
import pip
pip.main(['install', 'camelot'])
 2/9: !conda install --yes --prefix camelot
2/10: import pandas
2/11: import camelot
2/12:
import pandas as pd
import camelot
2/13: tables = camelot.read_pdf('"C:\Users\Cagri\Desktop\721182.pdf"')
2/14: tables = camelot.read_pdf("C:\Users\Cagri\Desktop\721182.pdf")
2/15: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
2/16: $ pip install camelot-py
2/17: ! pip install camelot-py
2/18:
import pandas as pd
import camelot
2/19: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
2/20:
import pandas as pd
import camelot
2/21: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
 3/1:
import pandas as pd
import camelot
2/22: ! pip install .io -py
2/23: ! pip install .io-py
2/24:
! pip uninstall camelot
! pip uninstall camelot-py
! pip install camelot-py[cv]
 4/1: ! pip uninstall camelot
 5/1: ! pip install camelot-py[cv]
 5/2:
import pandas as pd
import camelot
 5/3: !pip uninstall camelot
 6/1: ! pip install camelot-py[cv]
 6/2:
import pandas as pd
import camelot
 6/3: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
 6/4:
import pandas as pd
import camelot
 6/5: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
 7/1: import PyPDF2
 7/2:
PDFfilename = "C:\Users\Cagri\Desktop\721182.pdf"

pfr = PyPDF2.PdfFileReader(open(PDFfilename, "rb")) #PdfFileReader object
 7/3:
PDFfilename = r"C:\Users\Cagri\Desktop\721182.pdf"

pfr = PyPDF2.PdfFileReader(open(PDFfilename, "rb")) #PdfFileReader object
 7/4:
pg1 = pfr.getPage(1)

writer = PyPDF2.PdfFileWriter() #create PdfFileWriter object
#add pages
writer.addPage(pg1)
 7/5:
NewPDFfilename = r"C:\Users\Cagri\Desktop\test.pdf" #filename of your PDF/directory where you want your new PDF to be
with open(NewPDFfilename, "wb") as outputStream: #create new PDF
writer.write(outputStream) #write pages to new PDF
 7/6:
NewPDFfilename = r"C:\Users\Cagri\Desktop\test.pdf" #filename of your PDF/directory where you want your new PDF to be
with open(NewPDFfilename, "wb") as outputStream: #create new PDF
    writer.write(outputStream) #write pages to new PDF
 8/1: !pip install tabula-py
 8/2: from tabula import read_pdf
 8/3: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
 8/4: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
 8/5: from tabula import read_pdf
 8/6: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
 8/7: java
 8/8: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
 8/9: !pip install tabula-py
8/10: from tabula import read_pdf
8/11: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
8/12: java -version
8/13: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
8/14: from tabula import read_pdf
8/15: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
8/16: java -version
 9/1: from tabula import read_pdf
 9/2: !pip install tabula-py
 9/3: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
 9/4: from tabula import read_pdf
 9/5: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
11/1: from tabula import read_pdf
11/2: df = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
11/3: df
11/4: df
11/5: df.head()
11/6: df
11/7: df = read_pdf(r"C:\Users\Cagri\Desktop\foo.pdf")
11/8: df
11/9: import camelot
11/10: df_1 = read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
11/11: df_1
11/12: type(df_1)
11/13: !python -m site
11/14: from tabula import read_pdf
11/15: df = read_pdf(r"C:\Users\Cagri\Desktop\foo.pdf")
11/16: df
11/17: import camelot
11/18: !pip install camelot-py
11/19: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\foo.pdf")
11/20: import camelot
12/1:
import pandas as pd
import camelot
12/2: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\foo.pdf")
11/21: ! gs -version
11/22: ! C:\> gswin64c.exe -version
11/23: ! apt install python3-tk ghostscript
11/24: ! pip install python3-tk ghostscript
12/3: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\foo.pdf")
12/4: tables
11/25:
import pandas as pd
import camelot
12/5:
tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\foo.pdf")
type(tables)
12/6: tables.export('foo.csv', f='csv', compress=True)
12/7:
tables.export('foo.csv', f='csv', compress=True)
tables[0]
12/8: tables[0].parsing_report
12/9: tables[0].df
12/10: df = tables[0].df
12/11:
import pandas as pd
import camelot
12/12: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
12/13: tables.export('foo.csv', f='csv', compress=True)
12/14: tables[0]
12/15: tables[0].parsing_report
12/16: df = tables[0].df
12/17: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\721182.pdf")
12/18: tables[0]
12/19: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\test.pdf")
12/20: tables[0]
12/21:
import pandas as pd
import camelot
12/22: df = tables[0].df
12/23: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\foo.pdf")
12/24: df = tables[0].df
13/1: import pandas as pd
13/2: df = pd.read_csv(r"C:\Users\Cagri\Desktop\test-excel.xls")
13/3: df = pd.read_csv(r"C:\Users\Cagri\Desktop\test-excel.xls", error_bad_lines=False)
13/4: df
13/5: df.to_csv(r"C:\Users\Cagri\Desktop\test_sonuc.csv)
13/6: df.to_csv(r"C:\Users\Cagri\Desktop\test_sonuc.csv")
13/7: df = pd.read_csv(r"C:\Users\Cagri\Desktop\test-excel.xls", sep='delimiter', header=None)
13/8: df.to_csv(r"C:\Users\Cagri\Desktop\test_sonuc.csv")
13/9: import pandas as pd
13/10: df = pd.read_csv(r"C:\Users\Cagri\Desktop\test-excel.xls", sep='delimiter', header=None)
13/11: df.to_csv(r"C:\Users\Cagri\Desktop\test_sonuc.csv")
13/12:
import zipfile
from lxml import etree
import pandas as pd

def read_docx(docx_file, **kwargs):
    """Read tables as DataFrames from a Word document
    """
    ns = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
    with zipfile.ZipFile(docx_file).open('word/document.xml') as f:
        root = etree.parse(f)
    for el in root.xpath('//w:tbl', namespaces=ns):
        el.tag = 'table'
    for el in root.xpath('//w:tr', namespaces=ns):
        el.tag = 'tr'
    for el in root.xpath('//w:tc', namespaces=ns):
        el.tag = 'td'
    return pd.read_html(etree.tostring(root), **kwargs)
13/13: read_docx(r"C:\Users\Cagri\Desktop\Bildirimler.doc")
13/14: import pandas as pd
13/15: df = pd.read_csv(r"C:\Users\Cagri\Desktop\test-excel.xls")
13/16:  df = pd.read_csv(r"C:\Users\Cagri\Desktop\test-excel.xls",header=None,error_bad_lines=False)
13/17: df
13/18: df.to_csv(r"C:\Users\Cagri\Desktop\test_sonuc.csv")
16/1:
import pandas as pd
import camelot
16/2: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\test.pdf")
16/3: df = tables[0].df
16/4:
import pandas as pd
import camelot

tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\foo.pdf")

tables.export('foo.csv', f='csv', compress=True)
tables[0]

tables[0].parsing_report

df = tables[0].df
16/5: df.to_csv(r"C:\Users\Cagri\Desktop\foo.csv")
16/6:
import pandas as pd
import camelot
16/7: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\test.pdf")
16/8: tables[0]
16/9: type(tables)
16/10: list(tables)
16/11: type(tables[0])
17/1: !pip install PeePDF-py
17/2: !pip install PeePDF
16/12: interpreter
16/13: 1  +9 2
16/14: 1+2
16/15: a = 2
16/16: a
18/1: import requests
18/2: import json
18/3: as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
18/4:
as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
as_dict['tableModel']
18/5:
as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
as_dict['tableModel']['partyModel ']
18/6:
as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
as_dict['tableModel']['partyModel']
18/7:
as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
partiler = {o['partyName']: o['voteCount'] for o in as_dict['tableModel']['partyModel'] if o['partyName'] in ('AK PARTİ', 'CHP')}
18/8: partiler
18/9:
as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
partiler = {o['partyName']: o['voteCount'] for o in as_dict['tableModel']['partyModel'] if o['partyName'] in ('AK PARTİ', 'CHP')}
partiler['AK PARTİ'] - partiler['CHP']
18/10:
as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
partiler = {o['partyName']: o['voteCount'] for o in as_dict['tableModel']['partyModel'] if o['partyName'] in ('AK PARTİ', 'CHP')}
partiler['AK PARTİ'] - partiler['CHP']
18/11:
as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
partiler = {o['partyName']: o['voteCount'] for o in as_dict['tableModel']['partyModel'] if o['partyName'] in ('AK PARTİ', 'CHP')}
partiler['AK PARTİ'] - partiler['CHP']
18/12:
as_dict = requests.get('http://www.hurriyet.com.tr/secim/31-mart-2019-yerel-secimleri/City/MayorshipMap?cityId=34').json()
partiler = {o['partyName']: o['voteCount'] for o in as_dict['tableModel']['partyModel'] if o['partyName'] in ('AK PARTİ', 'CHP')}
partiler['AK PARTİ'] - partiler['CHP']
19/1: from sklearn.datatasets import load_files
19/2: from scitkitlearn.datatasets import load_files
19/3: from scikitlearn.datatasets import load_files
19/4: from scikit-learn.datatasets import load_files
19/5: from scikit-learn.datatasets import load_files
19/6: from scikit-learn.datatasets import load_files
20/1: from scikit-learn.datatasets import load_files
21/1: from scikit-learn.datatasets import load_files
21/2: from scikit-learn.datatasets import load_files
21/3: !pip install scikit-learn
21/4: from scikitlearn.datatasets import load_files
21/5: from sklearn.datatasets import load_files
21/6: !pip install sklearn
21/7: from sklearn.datatasets import load_files
21/8: from sklearn.datatasets import load_files
21/9: from sklearn.datatasets import load_files
22/1: from sklearn.datatasets import load_files
22/2: from sklearn.datatasets import load_files
22/3: import sklearn
22/4: from sklearn import datasets
22/5: from sklearn.datasets import load_files
22/6: reviews_train = laod_files("data/aclImdb/train/")
22/7: reviews_train = load_files("data/aclImdb/train/")
22/8: reviews_train = load_files("data/actImdb/train/")
22/9: reviews_train = load_files("data/aclImdb/train/")
22/10: moviedir = r'D:\Lab\nltk_data\corpora\movie_reviews'
22/11: reviews_train = load_files(moviedir)
22/12: import pandas as pd
22/13:
df_master = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\imdb_master.csv",
                        encoding='latin-1', index_col = 0)
22/14:
##################### Seperating the data in to train and test set #############################
imdb_train = df_master[["review", "label"]][df_master.type.isin(['train'])].reset_index(drop=True)
imdb_test = df_master[["review", "label"]][df_master.type.isin(['test'])].reset_index(drop=True)
22/15: imdb_train[:5]
22/16: imdb_train[0]
22/17: imdb_train[1,0]
22/18: imdb_train[:5
22/19: imdb_train[:5]
22/20: imdb_train[1,]
22/21: imdb_train[1,:5]
22/22: imdb_train[0,:5]
22/23: imdb_train.iloc[0,:5]
22/24: imdb_test = [doc.replace(b"<br />", b" ") for doc in text_test]
22/25: imdb_test = [doc.replace(b"<br />", b" ") for doc in imdb_test]
22/26: imdb_train['review'] = rem_sw(imdb_train['review'])
22/27: import pandas as pd
22/28:
import pandas as pd
from sklearn.datasets import load_files
22/29: reviews_test = load_files("data/aclImdb/test/")
22/30: reviews_test = load_files("data/aclImdb/test/")
22/31: reviews_test = load_files("data/aclImdb/test/")
22/32: reviews_test = load_files("C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
22/33: reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
22/34: text_test = [doc.replace(b"<br />", b" ") for doc in text_test]
22/35: text_test, y_test = reviews_test.data, reviews_test.target
22/36: text_test = [doc.replace(b"<br />", b" ") for doc in text_test]
22/37:
text_test = [doc.replace(b"<br />", b" ") for doc in text_test]
text_test
22/38: print("text_train[1]:\n{}".format(text_train[1]))
22/39: reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
23/1:
import pandas as pd
from sklearn.datasets import load_files
23/2:
reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
23/3:
text_test, y_test = reviews_test.data, reviews_test.target
text_train, y_train = reviews_train.data, reviews_train.target
23/4: print("text_train[1]:\n{}".format(text_train[1]))
23/5:
text_train = [doc.replace(b"<br />", b" ") for doc in text_train]
text_test = [doc.replace(b"<br />", b" ") for doc in text_test]
24/1: print(np.bincount(y_train))
24/2:
import pandas as pd
from sklearn.datasets import load_files
24/3:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files
24/4:
reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
24/5:
reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
24/6:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files
24/7:
reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
25/1:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files
25/2: reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
25/3: reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
25/4:
text_test, y_test = reviews_test.data, reviews_test.target
text_train, y_train = reviews_train.data, reviews_train.target
25/5: print("text_train[1]:\n{}".format(text_train[1]))
25/6:
text_train = [doc.replace(b"<br />", b" ") for doc in text_train]
text_test = [doc.replace(b"<br />", b" ") for doc in text_test]
25/7: print(np.bincount(y_train))
25/8: y_train
25/9: df_test = pd.DataFrame(y_train)
25/10:
df_test = pd.DataFrame(y_train)
df_test
25/11: print(np.bincount(y_test))
25/12:
df_test = pd.DataFrame(y_train)
df_test.describe
25/13:
df_test = pd.DataFrame(y_train)
df_test.describe()
25/14:
df_test = pd.DataFrame(y_train)
df_test.histogram()
25/15:
df_test = pd.DataFrame(y_train)
df_test.hist()
25/16:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files
25/17: reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
25/18:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files

import matplotlib.pyplot as plt
25/19:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files

import matplotlib.pyplot as plt
%matplotlib inline
25/20: print(np.bincount(y_train))
25/21: print(np.bincount(y_test))
25/22:
df_test = pd.DataFrame(y_train)
df_test.hist()
25/23: print(np.bincount(x_train))
25/24: print(np.bincount(text_train))
25/25:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files

import matplotlib.pyplot as plt
%matplotlib inline
25/26: reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
25/27: reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
25/28:
text_test, y_test = reviews_test.data, reviews_test.target
text_train, y_train = reviews_train.data, reviews_train.target
25/29: print("text_train[1]:\n{}".format(text_train[1]))
25/30:
text_train = [doc.replace(b"<br />", b" ") for doc in text_train]
text_test = [doc.replace(b"<br />", b" ") for doc in text_test]
25/31: print(np.bincount(text_train))
25/32: print(type(text_train))
25/33: print(list(text_train))
25/34: list(text_train)
25/35: len(list(text_train))
25/36:
df_test = pd.DataFrame(y_train)
df_test.groupby()
25/37:
df_test = pd.DataFrame(y_train)
df_test.iloc[:,0]
25/38:
df_test = pd.DataFrame(y_train)
df_test.iloc[:,0].value_counts()
25/39: print("text_train[1]:\n{}".format(text_train[1]))
25/40:
bards_words = ["The fool doth this he is wise," ,
               "but the wise man knows himself to be a fool"]
25/41: from sklearn.feature_extraction.text import CountVectorizer
25/42:
vect = CountVectorizer()
vect.fit(bards_words)
25/43: bards_words
25/44:
vect = CountVectorizer()
vect.fit(bards_words)
25/45: print("Vocabulary size: {}".format(len(vect.vocabulary_)))
25/46: vect.vocabulary_
25/47: print("Vocabulary content:\n {}".format(vect.vocabulary_))
25/48:
bag_of_words = vect.transform(bards_words)
print("bag_of_words: {}".format(repr(bag_of_words)))
25/49: bag_of_words
25/50: bag_of_words.toarray()
25/51: vect.fit(text_train)
25/52: X_train = vect.transform(text_train)
25/53: print("X_train:\n{}".format(repr(X_train)))
25/54:
feature_names = vect.get_feature_names()
print("Number of features: {}".format(len(feature_names)))
25/55: print("First 20 features:\n{}".format(feature_names[:20]))
25/56: print("Features 20010 to 20030:\n{}".format(feature_names[20010:20030]))
25/57: print("Every 2000th feature:\n{}".format(feature_names[::2000]))
25/58: text_train
25/59: type(text_train)
25/60: df_test = pd.DataFrame(text_train)
25/61:
df_test = pd.DataFrame(text_train)
df_test.head()
25/62:
df_test = pd.DataFrame(text_train)
mask = df_test.iloc[:,1].str.contains(r'EQUITY', na=True)
25/63: df_test.iloc[:,0]
25/64:
df_test = pd.DataFrame(text_train)
mask = df_test.iloc[:,0].str.contains(r'EQUITY', na=True)
25/65: mask
25/66:
df_test = pd.DataFrame(text_train)
mask = df_test.iloc[:,0].str.contains(r'007', na=True)
25/67: mask
25/68: mask.count(False)
25/69: mask.value_counts()
25/70:
df_test = pd.DataFrame(text_train)
mask = df_test.iloc[:,0].str.contains('007', na=True)
25/71: mask.value_counts()
25/72: df_test.iloc[:,0]
25/73:
from sklearn.model_selection import cross_val_score
from sklearn.linear_model import LogisticRegression
25/74: scores = cross_val_score(LogisticRegression(), X_train, y_train, cv=5)
27/1:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files

import matplotlib.pyplot as plt
%matplotlib inline
27/2: reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
27/3: reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
27/4:
text_test, y_test = reviews_test.data, reviews_test.target
text_train, y_train = reviews_train.data, reviews_train.target
27/5: print("text_train[1]:\n{}".format(text_train[1]))
27/6:
text_train = [doc.replace(b"<br />", b" ") for doc in text_train]
text_test = [doc.replace(b"<br />", b" ") for doc in text_test]
27/7: print(np.bincount(y_train))
27/8: print(np.bincount(y_test))
27/9:
df_test = pd.DataFrame(y_train)
df_test.iloc[:,0].value_counts()
27/10: print("text_train[1]:\n{}".format(text_train[1]))
27/11:
bards_words = ["The fool doth think he is wise," ,
               "but the wise man knows himself to be a fool"]
27/12: from sklearn.feature_extraction.text import CountVectorizer
27/13:
vect = CountVectorizer()
vect.fit(bards_words)
27/14: print("Vocabulary size: {}".format(len(vect.vocabulary_)))
27/15: print("Vocabulary content:\n {}".format(vect.vocabulary_))
27/16:
bag_of_words = vect.transform(bards_words)
print("bag_of_words: {}".format(repr(bag_of_words)))
27/17: bag_of_words.toarray()
27/18: vect.fit(text_train)
27/19: X_train = vect.transform(text_train)
27/20: print("X_train:\n{}".format(repr(X_train)))
27/21:
feature_names = vect.get_feature_names()
print("Number of features: {}".format(len(feature_names)))
27/22: print("First 20 features:\n{}".format(feature_names[:20]))
27/23: print("Features 20010 to 20030:\n{}".format(feature_names[20010:20030]))
27/24: print("Every 2000th feature:\n{}".format(feature_names[::2000]))
27/25:
from sklearn.model_selection import cross_val_score
from sklearn.linear_model import LogisticRegression
27/26: model = (LogisticRegression(X_train,y_train)
27/27: model = LogisticRegression().fit(X_train,y_train)
27/28: print("Mean cross-validation accuracy: {:.2f}".format(model))
27/29: print("Mean cross-validation accuracy: {:.2f}".format(model.score(X_train,y_train)))
27/30: print("Mean accuracy: {:.2f}".format(model.score(X_train,y_train)))
27/31:
vect = CountVectorizer(min_df=5).fit(text_train)
X_train = vect.transform(text_train)
27/32: print(y_train.value_counts())
27/33: print(y_train.bin_count())
27/34: print(y_train.bincount())
27/35: print(np.bincount(y_train))
29/1:
import pandas as pd
import numpy as np
from sklearn.datasets import load_files

import matplotlib.pyplot as plt
%matplotlib inline
29/2: reviews_test = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\test")
29/3: reviews_train = load_files(r"C:\Users\Cagri\Anaconda3\pkgs\scikit-learn-0.20.1-py37h343c172_0\Lib\site-packages\sklearn\datasets\data\aclImdb\train")
29/4:
text_test, y_test = reviews_test.data, reviews_test.target
text_train, y_train = reviews_train.data, reviews_train.target
29/5: print("text_train[1]:\n{}".format(text_train[1]))
29/6:
text_train = [doc.replace(b"<br />", b" ") for doc in text_train]
text_test = [doc.replace(b"<br />", b" ") for doc in text_test]
29/7: print(np.bincount(y_train))
29/8: print(np.bincount(y_test))
29/9:
df_test = pd.DataFrame(y_train)
df_test.iloc[:,0].value_counts()
29/10: print("text_train[1]:\n{}".format(text_train[1]))
29/11:
bards_words = ["The fool doth think he is wise," ,
               "but the wise man knows himself to be a fool"]
29/12: from sklearn.feature_extraction.text import CountVectorizer
29/13:
vect = CountVectorizer()
vect.fit(bards_words)
29/14: print("Vocabulary size: {}".format(len(vect.vocabulary_)))
29/15: print("Vocabulary content:\n {}".format(vect.vocabulary_))
29/16:
bag_of_words = vect.transform(bards_words)
print("bag_of_words: {}".format(repr(bag_of_words)))
29/17: bag_of_words.toarray()
29/18: vect.fit(text_train)
29/19: X_train = vect.transform(text_train)
29/20: print("X_train:\n{}".format(repr(X_train)))
29/21:
feature_names = vect.get_feature_names()
print("Number of features: {}".format(len(feature_names)))
29/22: print("First 20 features:\n{}".format(feature_names[:20]))
29/23: print("Features 20010 to 20030:\n{}".format(feature_names[20010:20030]))
29/24: print("Every 2000th feature:\n{}".format(feature_names[::2000]))
29/25:
from sklearn.model_selection import cross_val_score
from sklearn.linear_model import LogisticRegression
29/26: print(np.bincount(y_train))
29/27: model = LogisticRegression().fit(X_train,y_train)
29/28: print("Mean accuracy: {:.2f}".format(model.score(X_train,y_train)))
29/29:
vect = CountVectorizer(min_df=5).fit(text_train)
X_train = vect.transform(text_train)
29/30: print("X_train with min_df: {}".format(repr(X_train)))
29/31: print("Number of features: {}".format(len(feature_names)))
29/32: from sklearn.feature_extraction.text import TfidfVectorizer
29/33: param_grid = {'logisticregression__C': [0.001, 0.01, 0.1, 1, 10]}
29/34:
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.pipeline import make_pipeline
29/35: pipe = make_pipeline(TfidfVectorizer(min_df=5, norm=None),LogisticRegression())
29/36: param_grid = {'logisticregression__C': [0.001, 0.01, 0.1, 1, 10]}
29/37: grid = GridSearchCV(pipe, param_grid, cv=5)
29/38: grid.fit(text_train, y_train)
29/39:
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.pipeline import make_pipeline
from sklearn.model_selection import GridSearchCV
29/40: pipe = make_pipeline(TfidfVectorizer(min_df=5, norm=None),LogisticRegression())
29/41: param_grid = {'logisticregression__C': [0.001, 0.01, 0.1, 1, 10]}
29/42: grid = GridSearchCV(pipe, param_grid, cv=5)
29/43: grid.fit(text_train, y_train)
29/44: param_grid = {'logisticregression__C': [1, 10]}
29/45: grid = GridSearchCV(pipe, param_grid, cv=5)
29/46: grid.fit(text_train, y_train)
30/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
30/2: from grader import Grader
30/3: grader = Grader()
30/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
30/5:
from ast import literal_eval
import pandas as pd
import numpy as np
30/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
30/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
30/8: train.head()
30/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
30/10: X_train
30/11: X_train.shape[:,:]
30/12: X_train.shape[]
30/13: X_train.shape[:]
30/14:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))

def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = # lowercase text
    text = # replace REPLACE_BY_SPACE_RE symbols by space in text
    text = # delete symbols which are in BAD_SYMBOLS_RE from text
    text = # delete stopwords from text
    return text
30/15: REPLACE_BY_SPACE_RE
30/16:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
30/17: import re
30/18:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
30/19: REPLACE_BY_SPACE_RE
30/20:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = # lowercase text
    text = # replace REPLACE_BY_SPACE_RE symbols by space in text
    text = # delete symbols which are in BAD_SYMBOLS_RE from text
    text = # delete stopwords from text
    return text
30/21: STOPWORDS
30/22: X_train.shape[:]
30/23: etc = "Any text CAN be this way"
30/24: etc = "Any text CAN be this way"
30/25: etc.lower()
30/26: etc.replace(" ", REPLACE_BY_SPACE_RE)
30/27: etc.replace(" ", _)
30/28: etc.replace(" ", "_")
30/29: REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
30/30:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
REPLACE_BY_SPACE_RE
30/31:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
type(REPLACE_BY_SPACE_RE)
30/32: result = re.match(REPLACE_BY_SPACE_RE, " ")
30/33:
result = re.match(REPLACE_BY_SPACE_RE, " ")
v
30/34:
result = re.match(REPLACE_BY_SPACE_RE, " ")
result
30/35:
result = re.match(REPLACE_BY_SPACE_RE, " ")
etc.result
30/36:
result = re.match(REPLACE_BY_SPACE_RE, " ")
etc.result()
30/37:
result = re.match(REPLACE_BY_SPACE_RE, " ")
type(result)
30/38: x = re.search(REPLACE_BY_SPACE_RE, etc)
30/39:
x = re.search(REPLACE_BY_SPACE_RE, etc)
x
30/40:
x = re.search(REPLACE_BY_SPACE_RE, etc)
type(x)
30/41:
txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)
30/42:
txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)
x
30/43:
str = "The rain in Spain"
x = re.findall("ai", str)
print(x)
30/44:
for i in text:
    if REPLACE_BY_SPACE_RE in i:
        i = " ""
30/45:
for i in text:
    if REPLACE_BY_SPACE_RE in i:
        i = " "
30/46:
for i in etc:
    if REPLACE_BY_SPACE_RE in i:
        i = " "
30/47:
str = "The rain in Spain"
x = re.search("ai", str)
print(x) #this will print an object
30/48:
str = "The rain in Spain"
x = re.search(r"\bS\w+", str)
print(x.span())
30/49:
str_1 = "The rain in Spain"
x = re.search(r"\bS\w+", str_1)
print(x.span())
30/50:
x = re.search(REPLACE_BY_SPACE_RE, etc)
print(x.span())
30/51:
while REPLACE_BY_SPACE_RE.search(text):
    print
30/52:
while REPLACE_BY_SPACE_RE.search(etc):
    print
30/53:
while REPLACE_BY_SPACE_RE.search(etc):
    print(etc)
30/54:
while REPLACE_BY_SPACE_RE.search(etc):
    print(REPLACE_BY_SPACE_RE)
30/55:
while REPLACE_BY_SPACE_RE.search(etc):
    print("s")
30/56:
import re

phone_check = re.compile(r"[^0-9s-()]")

phone = raw_input ("Please, enter your phone: ")

while phone_check.search(phone):
    print "Please enter your phone correctly!"
    phone = raw_input ("Please, enter your phone: ")
30/57:
import re

phone_check = re.compile(r"[^0-9s-()]")

phone = raw_input ("Please, enter your phone: ")

while phone_check.search(phone):
    print ()"Please enter your phone correctly!")
    phone = raw_input ("Please, enter your phone: ")
30/58:
import re

phone_check = re.compile(r"[^0-9s-()]")

phone = raw_input ("Please, enter your phone: ")

while phone_check.search(phone):
    print ("Please enter your phone correctly!")
    phone = raw_input ("Please, enter your phone: ")
30/59: re.search(REPLACE_BY_SPACE_RE, etc)
30/60: print(re.search(REPLACE_BY_SPACE_RE, etc))
30/61: re.search(REPLACE_BY_SPACE_RE, X_train)
30/62: X_train[0]
30/63: re.search(REPLACE_BY_SPACE_RE, X_train[0])
30/64: print(re.search(REPLACE_BY_SPACE_RE, X_train[0]))
30/65: print(re.search(REPLACE_BY_SPACE_RE, iX_train[i] for i in range(X_train.shape[:])))
30/66: print(re.search(REPLACE_BY_SPACE_RE, X_train[i] for i in range(X_train.shape[:])))
30/67: print(re.search(REPLACE_BY_SPACE_RE, (X_train[i] for i in range(X_train.shape[:]))))
30/68: X_train.shape[:]
30/69: X_train.shape[0]
30/70: print(re.search(REPLACE_BY_SPACE_RE, (X_train[i] for i in range(X_train.shape[0]))))
30/71: print(re.search(REPLACE_BY_SPACE_RE, (X_train[i] for i in range(1))))
30/72:
for i in range(X_train.shape[0]):


print(re.search(REPLACE_BY_SPACE_RE,
30/73:
for i in range(X_train.shape[0]):
    print(i)
30/74:
for i in range(2):
    print(i)
30/75:
for i in range(X_train.shape[0]):
    print(re.search(REPLACE_BY_SPACE_RE,X_train[i]))
32/1:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = [word for word in tokenized_words if word not in stop_words]
    return text
32/2: etc = "Any te\[\]xt CAN b`e this to the way"
32/3: text_prepare(etc)
32/4:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
32/5: from grader import Grader
32/6: grader = Grader()
32/7:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
32/8:
from ast import literal_eval
import pandas as pd
import numpy as np
32/9:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
32/10:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
32/11: train.head()
32/12:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
32/13: X_train.shape[:]
32/14: X_train[0]
32/15: import re
32/16:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
32/17:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = [word for word in tokenized_words if word not in stop_words]
    return text
32/18: etc = "Any te\[\]xt CAN b`e this to the way"
32/19: text_prepare(etc)
32/20:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = [word for word in text if word not in STOPWORDS]
    return text
32/21: etc = "Any te\[\]xt CAN b`e this to the way"
32/22: text_prepare(etc)
32/23: etc = "A[ny te\xt CAN b`e this t]o the way"
32/24: etc = r"A[ny te\xt CAN b`e this t]o the way"
32/25: text_prepare(etc)
32/26:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    #text = [word for word in text if word not in STOPWORDS]
    #return text
    
    text = text.split();
    return ' '.join([i for i in text if i not in STOPWORDS])
32/27: etc = r"A[ny te\xt CAN b`e this t]o the way"
32/28: text_prepare(etc)
32/29:
etc = r"A[ny te\xt CAN b`e this t]o the way"
etc.split()
32/30:
new_l = [i for i in etc_l if i not in STOPWORDS]
new_l
32/31:
etc = r"A[ny te\xt CAN b`e this t]o the way"
etc_l = etc.split()
32/32:
new_l = [i for i in etc_l if i not in STOPWORDS]
new_l
32/33: " ".join(new_l)
32/34:
etc = text.lower()
etc
32/35:
etc = etc.lower()
etc
32/36:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
32/37:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
32/38:
etc = etc.split();
etc
32/39:
etc = [i for i in etc if i not in STOPWORDS]
etc
32/40: etc = ' '.join([i for i in text if i not in STOPWORDS])etc
32/41: etc = ()' '.join([i for i in text if i not in STOPWORDS])etc)
32/42: etc = (' '.join([i for i in text if i not in STOPWORDS])etc)
32/43: etc = (' '.join([i for i in text if i not in STOPWORDS]))
32/44:
etc = (' '.join([i for i in etc if i not in STOPWORDS]))
etc
32/45: print(t in STOPWORDS)
32/46: print("t" in STOPWORDS)
32/47:
etc = etc.lower()
etc
32/48:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
32/49:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
32/50: etc = r"A[ny te\xt CAN b`e this t]o the way"
32/51:
etc = etc.lower()
etc
32/52:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
32/53:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
32/54:
etc = etc.split();
etc
32/55:
etc = [word for word in etc if word not in STOPWORDS]
etc
32/56:
etc = " ".join(i for i in etc)
etc
32/57: etc = r"A[ny te\xt CAN b`e this t]o the way"
32/58:
etc = etc.lower()
etc
32/59:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
32/60:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
32/61:
etc = etc.split();
etc
32/62:
etc = [word for word in etc if word not in STOPWORDS]
etc
32/63:
etc = " ".join(i for i in etc)
etc
32/64: text_prepare(etc)
32/65:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
32/66: print(test_text_prepare())
32/67:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
32/68:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
32/69: X_train[:3]
32/70: X_train
33/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
33/2: from grader import Grader
33/3: grader = Grader()
33/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
33/5:
from ast import literal_eval
import pandas as pd
import numpy as np
33/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
33/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
33/8: train.head()
33/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
33/10: X_train.shape[:]
33/11: X_train[0]
33/12: import re
33/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
33/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
33/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
33/16:
etc = etc.lower()
etc
33/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
33/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
33/19:
etc = etc.split();
etc
33/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
33/21:
etc = " ".join(i for i in etc)
etc
33/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
33/23: print(test_text_prepare())
33/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
33/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
33/26: X_train[:3]
33/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

######################################
######### YOUR CODE HERE #############
######################################
33/28:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
33/29:
DICT_SIZE = 5000
WORDS_TO_INDEX = ####### YOUR CODE HERE #######
INDEX_TO_WORDS = ####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    result_vector = np.zeros(dict_size)
    ######################################
    ######### YOUR CODE HERE #############
    ######################################
    return result_vector
33/30:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
33/31: etc = r"A[ny te\xt CAN b`e this t]o the way"
33/32:
etc = etc.lower()
etc
33/33:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
33/34:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
33/35:
etc = etc.split();
etc
33/36:
etc = [word for word in etc if word not in STOPWORDS]
etc
33/37:
etc = " ".join(i for i in etc)
etc
33/38:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
33/39: print(test_text_prepare())
33/40:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
33/41:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
33/42: X_train[:3]
33/43:
examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]

text_prepare(examples)
33/44:
examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]

text_prepare(i for i in examples)
33/45:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
33/46: etc = r"A[ny te\xt CAN b`e this t]o the way"
33/47:
etc = etc.lower()
etc
33/48:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
33/49:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
33/50:
etc = etc.split();
etc
33/51:
etc = [word for word in etc if word not in STOPWORDS]
etc
33/52:
etc = " ".join(i for i in etc)
etc
33/53:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
33/54: print(test_text_prepare())
33/55:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
33/56:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
33/57: X_train[:3]
33/58: etc = r"A[ny te\xt CAN b`e this t]o the way"
33/59: text_prepare(etc)
33/60:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
33/61: print(test_text_prepare())
33/62:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
33/63:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
33/64: X_train[:3]
33/65: data/text_prepare_tests.tsv[0]
33/66: X_train
33/67:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
33/68: X_train
33/69:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
33/70:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
33/71: from grader import Grader
33/72: grader = Grader()
33/73:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
33/74:
from ast import literal_eval
import pandas as pd
import numpy as np
33/75:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
33/76:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
33/77: train.head()
33/78:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
33/79: X_train.shape[:]
33/80: X_train[0]
33/81: import re
33/82:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
33/83:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
33/84: etc = r"A[ny te\xt CAN b`e this t]o the way"
33/85:
etc = etc.lower()
etc
33/86:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
33/87:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
33/88:
etc = etc.split();
etc
33/89:
etc = [word for word in etc if word not in STOPWORDS]
etc
33/90:
etc = " ".join(i for i in etc)
etc
33/91: text_prepare(etc)
33/92:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
33/93: from grader import Grader
33/94: grader = Grader()
33/95:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
33/96:
from ast import literal_eval
import pandas as pd
import numpy as np
33/97:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
33/98:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
33/99: train.head()
33/100:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
33/101: X_train.shape[:]
33/102: X_train[0]
33/103: import re
33/104:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
33/105:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
33/106: etc = r"A[ny te\xt CAN b`e this t]o the way"
33/107:
etc = etc.lower()
etc
33/108:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
33/109:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
33/110:
etc = etc.split();
etc
33/111:
etc = [word for word in etc if word not in STOPWORDS]
etc
33/112:
etc = " ".join(i for i in etc)
etc
33/113: text_prepare(etc)
33/114:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
33/115: print(test_text_prepare())
33/116:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
33/117:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
33/118: X_train
33/119: X_train[:3]
33/120:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    print(i)
33/121:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    for j in i:
        print(j)
33/122:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
33/123: from grader import Grader
33/124: grader = Grader()
33/125:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
33/126:
from ast import literal_eval
import pandas as pd
import numpy as np
33/127:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
33/128:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
33/129: train.head()
33/130:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
33/131: X_train.shape[:]
33/132: X_train[0]
33/133: import re
33/134:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
33/135:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
33/136: etc = r"A[ny te\xt CAN b`e this t]o the way"
33/137:
etc = etc.lower()
etc
33/138:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
33/139:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
33/140:
etc = etc.split();
etc
33/141:
etc = [word for word in etc if word not in STOPWORDS]
etc
33/142:
etc = " ".join(i for i in etc)
etc
33/143:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
33/144: print(test_text_prepare())
33/145:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
33/146:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
33/147: X_train[:3]
33/148:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    print(i)
33/149:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    for j in i:
        print(j)
35/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
35/2: from grader import Grader
35/3: grader = Grader()
35/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
35/5:
from ast import literal_eval
import pandas as pd
import numpy as np
35/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
35/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
35/8: train.head()
35/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
35/10: X_train.shape[:]
35/11: X_train[0]
35/12: import re
35/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
35/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
35/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
35/16:
etc = etc.lower()
etc
35/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
35/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
35/19:
etc = etc.split();
etc
35/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
35/21:
etc = " ".join(i for i in etc)
etc
35/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
35/23: print(test_text_prepare())
35/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
35/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
35/26: X_train[:3]
35/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    print(i)
35/28:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
35/29:
DICT_SIZE = 5000
WORDS_TO_INDEX = ####### YOUR CODE HERE #######
INDEX_TO_WORDS = ####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    result_vector = np.zeros(dict_size)
    ######################################
    ######### YOUR CODE HERE #############
    ######################################
    return result_vector
35/30:
test = ["draw stacked dotplot r"]
test.strip()
35/31:
test = ["draw stacked dotplot r"]
test.strip( )
35/32:
test = "draw stacked dotplot r"
test.strip(0)
35/33:
test = "draw stacked dotplot r"
test.strip()
35/34:
test = "draw stacked dotplot r"
test.strip(" ")
35/35:
test = "draw stacked dotplot r"
test.split(" ")
35/36:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    j = i.split(" ")
    for k in j:
        print(k)
35/37:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    j = i.split(" ")
    for k in j:
        words_counts[k] += 1
35/38:
for text in X_train:
    for word in text.split():
        words_counts[word] += 1
35/39:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    j = i.split(" ")
    for k in j:
        print(k)
35/40:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    j = i.split(" ")
    for k in j:
        print(k)
        
k
35/41:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    j = i.split(" ")
    for k in j:
        #print(k)
        
j
35/42:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    j = i.split(" ")
    for k in j:
        print(k)
35/43:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

for i in X_train:
    j = i.split(" ")
35/44: j
35/45:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}

j = []

for i in X_train:
    j.append(i.split(" "))
35/46: j
35/47:
for k in j:
    print(k)
35/48:
test_list = []

for k in j:
    for l in k:
        test_list.append(l)
        
test_list
35/49:
from collections import Counter

Counterz(test_list)
35/50:
from collections import Counter

Counter(test_list)
35/51:
from collections import Counter

words_counts = Counter(test_list)
35/52:
from collections import Counter

words_counts = Counter(test_list)
words_counts
35/53:
from collections import Counter

words_counts = Counter(test_list)
type(words_counts)
35/54:
from collections import Counter

words_counts = Counter(test_list)
words_counts
35/55:
from collections import Counter

words_counts = Counter(test_list)
words_counts["draw"]
35/56:
from collections import Counter

words_counts = Counter(test_list)
words_counts
35/57:
j = []

for i in X_train:
    j.append(i.split(" "))

test_list = []

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
36/1: X_train[:5]
37/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
37/2: from grader import Grader
37/3: grader = Grader()
37/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
37/5:
from ast import literal_eval
import pandas as pd
import numpy as np
37/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
37/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
37/8: train.head()
37/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
37/10: X_train.shape[:]
37/11: X_train[0]
37/12: import re
37/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
37/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
37/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
37/16:
etc = etc.lower()
etc
37/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
37/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
37/19:
etc = etc.split();
etc
37/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
37/21:
etc = " ".join(i for i in etc)
etc
37/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
37/23: print(test_text_prepare())
37/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
37/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
37/26: X_train[:5]
37/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
37/28:
j = []
test_list = []
  b
for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
37/29:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
37/30:
from collections import Counter

words_counts = Counter(test_list)
words_counts
37/31:
test = "draw stacked dotplot r"
test.split(" ")
37/32:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
37/33:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
37/34: from grader import Grader
37/35: grader = Grader()
37/36:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
37/37:
from ast import literal_eval
import pandas as pd
import numpy as np
37/38:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
37/39:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
37/40: train.head()
37/41:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
37/42: X_train.shape[:]
37/43: X_train[0]
37/44: X_train[:5]
37/45: X.train[0].split(r"\t")
37/46: X_train[0].split(r"\t")
37/47: X_train[0]
37/48:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
37/49: from grader import Grader
37/50: grader = Grader()
37/51:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
37/52:
from ast import literal_eval
import pandas as pd
import numpy as np
37/53:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
37/54:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
37/55: train.head()
37/56:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
37/57: X_train.shape[:]
37/58: X_train[0]
37/59: import re
37/60:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
37/61:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
37/62: etc = r"A[ny te\xt CAN b`e this t]o the way"
37/63:
etc = etc.lower()
etc
37/64:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
37/65:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
37/66:
etc = etc.split();
etc
37/67:
etc = [word for word in etc if word not in STOPWORDS]
etc
37/68:
etc = " ".join(i for i in etc)
etc
37/69:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
37/70: print(test_text_prepare())
37/71:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
37/72:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
37/73: X_train[:5]
37/74:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
37/75:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
37/76:
from collections import Counter

words_counts = Counter(test_list)
words_counts
37/77:
test = "draw stacked dotplot r"
test.split(" ")
37/78: train
37/79: train[tags]
37/80: train["tags"]
37/81: re.findall(r"\[(.+)\]",train["tags"])
37/82:
for index, row in train["tags"].iterrows():
    print(row)
    #re.findall(r"\[(.+)\]",row)
37/83:
for i in traing["tags"]:
    print(i)
    #re.findall(r"\[(.+)\]",row)
37/84:
for i in train["tags"]:
    print(i)
    #re.findall(r"\[(.+)\]",row)
37/85:
for i in train["tags"]:
    #print(i)
    tags_list = re.findall(r"\[(.+)\]",row)
37/86:
for i in train["tags"]:
    #print(i)
    tags_list = re.findall(r"\[(.+)\]",i)
37/87:
for i in train["tags"]:
    print(i)
    #tags_list = re.findall(r"\[(.+)\]",i)
37/88:
for i in train["tags"]:
    print(i)
    type(i)
    #tags_list = re.findall(r"\[(.+)\]",i)
37/89:
for i in train["tags"]:
    print(i)
    print(type(i))
    #tags_list = re.findall(r"\[(.+)\]",i)
37/90:
for i in train["tags"]:
    print(i)
    tags_list = re.findall(r"\[(.+)\]",i)
37/91:
for i in train["tags"]:
    print(i)
    tags_list = re.findall(r"\[(.+)\]",i, str(location))
37/92:
for i in train["tags"]:
    print(i)
    tags_list = re.findall(r"\[(.+)\]",i, str(i))
37/93:
for i in train["tags"]:
    print(i)
37/94:
for i in train["tags"]:
    for j in i:
        print(j)
37/95:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)
37/96:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

frequency_counter
37/97:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts
37/98:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts[:5]
37/99:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts
37/100:
test = "draw stacked dotplot r"
test.split(" ")
37/101:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
37/102:
import operator

sorted_x = sorted(tags_counts.items(), key=operator.itemgetter(1))
37/103:
import operator

sorted_x = sorted(tags_counts.items(), key=operator.itemgetter(1))
sorted_x
37/104:
import operator

sorted_x = sorted(tags_counts.items(), key=operator.itemgetter(0))
sorted_x
37/105:
import operator

sorted_x = sorted(tags_counts.items(), key=operator.itemgetter(1))
sorted_x
37/106:
import operator

sorted_x = sorted(tags_counts.items(), key=operator.itemgetter(1))
sorted_dict = OrderedDict(sorted_x)
sorted_dict
37/107:
import operator
import collections


sorted_x = sorted(tags_counts.items(), key=operator.itemgetter(1))
sorted_dict = OrderedDict(sorted_x)
sorted_dict
37/108:
import operator

sorted_x = sorted(tags_counts.items(), key=operator.itemgetter(1))
sorted_x
37/109: tags_counts.items()
37/110: most_common_tags
37/111: most_common_words
37/112:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
37/113:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
37/114:
allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
37/115:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
37/116:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
    
for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = numpy.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
37/117:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
37/118:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
37/119:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
    
for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = numpy.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
37/120: generate_bow(allsentences)
37/121:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
    
    for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = numpy.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
37/122: generate_bow(allsentences)
37/123:
import numpy as np

allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
37/124:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
37/125:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
37/126:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
    
    for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = numpy.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
37/127: generate_bow(allsentences)
37/128:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
    
    for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = np.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
37/129: generate_bow(allsentences)
37/130:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
    
    for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = np.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
37/131: generate_bow(allsentences)
37/132:
for sentence in allsentences:
    wordzzz=word_extraction(sentece)
    
wordzzz
37/133:
for sentence in allsentences:
    wordzzz=word_extraction(sentence)
    
wordzzz
37/134: tokenize(allsentences)
37/135:
for sentence in allsentences:
    print(sentence)
    #wordzzz=word_extraction(sentence)
    
#wordzzz
37/136:
for sentence in allsentences:
    print(sentence)
    wordzzz=word_extraction(sentence)
    
wordzzz
37/137:
from sklearn.feature_extraction.text import CountVectorizer
corpus = [
    'This is the first document.',
     'This document is the second document.',
    'And this is the third one.',
     'Is this the first document?',
]
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(corpus)
print(vectorizer.get_feature_names())

print(X.toarray())
37/138:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
37/139: tokenize(allsentences)
37/140:
vocab = tokenize(allsentences)
print("Word List for Document \n{0} \n".format(vocab));
37/141:

for sentence in allsentences:
    words = word_extraction(sentence)
    bag_vector = np.zeros(len(vocab))
    for w in words:
        for i,word in enumerate(vocab):
            if word == w: 
                bag_vector[i] += 1
                    
    print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
37/142:
import numpy as np

allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
37/143:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
37/144:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
37/145: tokenize(allsentences)
37/146: import pixiedust
37/147:
# Install a pip package in the current Jupyter kernel
import sys
!{sys.executable} -m pip install pixiedust
37/148: import pixiedust
39/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
39/2: from grader import Grader
39/3: grader = Grader()
39/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
39/5:
from ast import literal_eval
import pandas as pd
import numpy as np
39/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
39/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
39/8: train.head()
39/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
39/10: X_train.shape[:]
39/11: X_train[0]
39/12: import re
39/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
39/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
39/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
39/16:
etc = etc.lower()
etc
39/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
39/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
39/19:
etc = etc.split();
etc
39/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
39/21:
etc = " ".join(i for i in etc)
etc
39/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
39/23: print(test_text_prepare())
39/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
39/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
39/26: X_train[:5]
39/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
39/28:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
39/29:
from collections import Counter

words_counts = Counter(test_list)
words_counts
39/30:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts
39/31:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
39/32:
# Install a pip package in the current Jupyter kernel
import sys
!{sys.executable} -m pip install pixiedust
39/33: import pixiedust
39/34:
import numpy as np

allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
39/35:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
39/36:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
39/37:
vocab = tokenize(allsentences)
print("Word List for Document \n{0} \n".format(vocab));
39/38:
for sentence in allsentences:
    words = word_extraction(sentence)
    bag_vector = np.zeros(len(vocab))
    for w in words:
        for i,word in enumerate(vocab):
            if word == w: 
                bag_vector[i] += 1
                    
    print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
39/39: generate_bow(allsentences,vocab)
39/40:
%%pixie_debugger

for sentence in allsentences:
    words = word_extraction(sentence)
    bag_vector = np.zeros(len(vocab))
    for w in words:
        for i,word in enumerate(vocab):
            if word == w: 
                bag_vector[i] += 1
                    
    print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
41/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
41/2: from grader import Grader
41/3: grader = Grader()
41/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
41/5:
from ast import literal_eval
import pandas as pd
import numpy as np
41/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
41/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
41/8: train.head()
41/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
41/10: X_train.shape[:]
41/11: X_train[0]
41/12: import re
41/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
41/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
41/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
41/16:
etc = etc.lower()
etc
41/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
41/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
41/19:
etc = etc.split();
etc
41/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
41/21:
etc = " ".join(i for i in etc)
etc
41/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
41/23: print(test_text_prepare())
41/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
41/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
41/26: X_train[:5]
41/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
41/28:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
41/29:
from collections import Counter

words_counts = Counter(test_list)
words_counts
41/30:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts
41/31:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
41/32:
# Install a pip package in the current Jupyter kernel
#import sys
#!{sys.executable} -m pip install pixiedust
41/33: import pixiedust
41/34:
import numpy as np

allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
41/35:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
41/36: word_extraction(all_sentences)
41/37: word_extraction(allsentences)
41/38:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
41/39:
vocab = tokenize(allsentences)
print("Word List for Document \n{0} \n".format(vocab));
41/40:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
41/41: len(vocan)
41/42: len(vocab)
41/43:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n" + words)
    return words
41/44:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
41/45:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n" words)
    return words
41/46:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n %".format(words)
    return words
41/47:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n %".format(words))
    return words
41/48:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
41/49:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n {}".format(words))
    return words
41/50:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
41/51:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n{}".format(words))
    return words
41/52:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
41/53:
from sklearn.feature_extraction.text import CountVectorizer
corpus = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(corpus)
print(vectorizer.get_feature_names())

print(X.toarray())
43/1:
from tika import parser

raw = parser.from_file("C:\Users\Cagri\Desktop\PDF Extraction Test\721182.pdf")
print(raw['content'])
43/2:
from tika import parser

raw = parser.from_file(r"C:\Users\Cagri\Desktop\PDF Extraction Test\721182.pdf")
print(raw['content'])
43/3:
import sys
!{sys.executable} -m pip install pixiedust
43/4:
import sys
!{sys.executable} -m pip install tika
43/5:
from tika import parser

raw = parser.from_file(r"C:\Users\Cagri\Desktop\PDF Extraction Test\721182.pdf")
print(raw['content'])
43/6:
from tika import parser

raw = parser.from_file(r"C:\Users\Cagri\Desktop\PDF Extraction Test\721182_en.pdf")
print(raw['content'])
43/7: raw
43/8: raw.split(\n)
43/9: raw.split("\t")
43/10: raw
43/11: raw["content"]
43/12: raw["content"].split("\n")
43/13: raw["content"].split("\t")
43/14: raw["content"].split("\n")
44/1:
import sys
!{sys.executable} -m pip install tika
44/2:
from tika import parser

raw = parser.from_file(r"C:\Users\Cagri\Desktop\PDF Extraction Test\721182_en.pdf")
print(raw['content'])
44/3: raw["content"].split("\n")
44/4: re.search(r"Maturity Date (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
44/5: import re
44/6: re.search(r"Maturity Date (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
44/7:
re.search(r"Maturity Date (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
re.group(1)
44/8:
match_1 =re.search(r"Maturity Date (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group()
44/9:
match_1 =re.search(r"Maturity Date (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/10:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
print(match_1.group(1))
print(match_1.group(0))
44/11:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
print(match_1.group(0))
print(match_1.group(1))
44/12:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
print(match_1.group(1)
44/13:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
print(match_1.group(1))
44/14:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(0)
44/15:
match_1 =re.search(r"Maturity Date (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(0)
44/16:
match_1 =re.search(r"Maturity Date (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/17: match_1.group(0)
44/18:
match_1 =re.search(r"(Maturity Date )(\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/19:
match_1 =re.search(r"(Maturity Date )(\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/20: match_1.group(0)
44/21: match_1.group(2)
44/22:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/23: match_1.group(2)
44/24:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1,2)
44/25:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/26:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1,2)
44/27: df = pd.DataFrame(match_1.group(1,2))
44/28:
import re
import pandas as pd
44/29: df = pd.DataFrame(match_1.group(1,2))
44/30: df = pd.DataFrame(match_1.group(1))
44/31:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/32:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
a = match_1.group(1)
44/33: df = pd.DataFrame(a)
44/34: pd.DataFrame(a)
44/35:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/36:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
type(match_1.group(1))
44/37:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
match_1.group(1)
44/38:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
a = match_1.group(1)
a
44/39:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
a = match_1.group(1)
type(a)
44/40:
match_1 =re.search(r"(Maturity Date) (\d{1,2}\.\d{1,2}\.\d{4})",raw["content"])
a = match_1.group(1)
a
44/41:
b = match_1.group(2)
b
44/42: data = [[a,b]]
44/43: df = pd.DataFrame(data, columns = ['Input', 'Output'])
44/44:
df = pd.DataFrame(data, columns = ['Input', 'Output'])
df
44/45: df.to_csv(r"C:\Users\Cagri\Desktop\PDF Extraction Test\test.csv")
45/1:
from tika import parser

raw = parser.from_file(r"C:\Users\Cagri\Desktop\Turkish Term Sheets\759355_Type_2_Normal.pdf")
45/2: runfile('C:/Users/Cagri/.spyder-py3/temp.py', wdir='C:/Users/Cagri/.spyder-py3')
45/3: runfile('C:/Users/Cagri/.spyder-py3/temp.py', wdir='C:/Users/Cagri/.spyder-py3')
45/4: df
45/5:
print("\n" + data)

df = pd.DataFrame(data)
print(df)
45/6: print("\n"data)
45/7: runfile('C:/Users/Cagri/.spyder-py3/temp.py', wdir='C:/Users/Cagri/.spyder-py3')
45/8: import glob
45/9:
for filepath in glob.iglob('C:\Users\Cagri\Desktop\Turkish Term Sheets'):
    print(filepath)
45/10:
for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets'):
    print(filepath)
45/11:
for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    print(filepath)
45/12:
for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)
45/13:
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)
45/14:
for i in range(len(filenames)):
    print(i)
45/15:
def information_retrieval(filepath):
    
    raw = parser.from_file(filepath)
    
    pdf_extracted = list(raw['content'].split("\n"))
    
    pdf_extracted_cleaned = []
    
    for i in pdf_extracted:
      if i != "" and i !=" " and i != "  " and i != "-":
        pdf_extracted_cleaned.append(i)
    
    BBID_Dict = {
        "AKBANK T.A.Ş." : 159576,
        "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
        "Bereket Varlık Kiralama A.Ş." : 28561089,
        "Yapı ve Kredi Bankası A.Ş." : 154568,
        "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
        "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
        "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
        "QNB FİNANSBANK A.Ş." : 159626,
        "YAPI VE KREDİ BANKASI A.Ş." : 154568,
        "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
        "T. Garanti Bankası A.Ş." : 126333,
        "Halk Varlık Kiralama A.Ş." : 59635062,
        "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
        "KT Kira Sertifikaları Varlık" : 38453748,
        "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
        "ZORLU FAKTORİNG A.Ş." : 35057529,
        "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
        "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
        "İŞ FAKTORİNG A.Ş." :  8604399,
        "ŞEKER FAKTORİNG A.Ş." : 8794207,
        "Şeker Faktoring A.Ş." : 8794207,
        "TÜRKİYE İŞ BANKASI A.Ş." : 159718
    }
    
    #for i in pdf_extracted_cleaned:
    #  print(i)
    
    maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
    ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
    coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
    currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
    type_m = re.search(r"(Type) (M.+)", raw["content"])
    interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
    title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])
    
    currency_m_l = None
    title_company_m_l = None
    
    currency_m_l = [i for i in currency_m.groups() if i is not None]
    if title_company_m != None:
      title_company_m_l = [i for i in title_company_m.groups() if i is not None]
    
    
    company_name_warning = "---- Check the company name ----"
    
    def safe_execute():
      
      try:
        return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
      except:
        return company_name_warning
    
    safe_execute()
    
    data = [["Issuer" if title_company_m == None else title_company_m_l[0],
             pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
             ["BBID" , safe_execute()],
             [maturity_m.group(1), maturity_m.group(2)],
             [ISIN_m.group(1), ISIN_m.group(2)],
             [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
             coupon_number_m.group(2) if coupon_number_m != None else "N/A"],
             [currency_m_l[0], currency_m_l[1]],
             ["Type", pdf_extracted_cleaned[2]],
             [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
             interest_rate_type_m.group(2) if interest_rate_type_m != None else "N/A"]]
    
    
    list_of_datasets = []         
    
    df = pd.DataFrame(data)
    
    list_of_datasets.append[df]
    
    return list_of_datasets
45/16:
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)
    information_retrieval(filepath)
45/17:
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)
45/18: information_retrieval(filenames[0])
45/19:
def information_retrieval(filepath):
    
    raw = parser.from_file(filepath)
    
    pdf_extracted = list(raw['content'].split("\n"))
    
    pdf_extracted_cleaned = []
    
    for i in pdf_extracted:
      if i != "" and i !=" " and i != "  " and i != "-":
        pdf_extracted_cleaned.append(i)
    
    BBID_Dict = {
        "AKBANK T.A.Ş." : 159576,
        "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
        "Bereket Varlık Kiralama A.Ş." : 28561089,
        "Yapı ve Kredi Bankası A.Ş." : 154568,
        "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
        "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
        "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
        "QNB FİNANSBANK A.Ş." : 159626,
        "YAPI VE KREDİ BANKASI A.Ş." : 154568,
        "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
        "T. Garanti Bankası A.Ş." : 126333,
        "Halk Varlık Kiralama A.Ş." : 59635062,
        "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
        "KT Kira Sertifikaları Varlık" : 38453748,
        "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
        "ZORLU FAKTORİNG A.Ş." : 35057529,
        "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
        "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
        "İŞ FAKTORİNG A.Ş." :  8604399,
        "ŞEKER FAKTORİNG A.Ş." : 8794207,
        "Şeker Faktoring A.Ş." : 8794207,
        "TÜRKİYE İŞ BANKASI A.Ş." : 159718
    }
    
    #for i in pdf_extracted_cleaned:
    #  print(i)
    
    maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
    ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
    coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
    currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
    type_m = re.search(r"(Type) (M.+)", raw["content"])
    interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
    title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])
    
    currency_m_l = None
    title_company_m_l = None
    
    currency_m_l = [i for i in currency_m.groups() if i is not None]
    if title_company_m != None:
      title_company_m_l = [i for i in title_company_m.groups() if i is not None]
    
    
    company_name_warning = "---- Check the company name ----"
    
    def safe_execute():
      
      try:
        return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
      except:
        return company_name_warning
    
    safe_execute()
    
    data = [["Issuer" if title_company_m == None else title_company_m_l[0],
             pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
             ["BBID" , safe_execute()],
             [maturity_m.group(1), maturity_m.group(2)],
             [ISIN_m.group(1), ISIN_m.group(2)],
             [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
             coupon_number_m.group(2) if coupon_number_m != None else "N/A"],
             [currency_m_l[0], currency_m_l[1]],
             ["Type", pdf_extracted_cleaned[2]],
             [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
             interest_rate_type_m.group(2) if interest_rate_type_m != None else "N/A"]]
    
    
    df = pd.DataFrame(data)
    
    return df
45/20: information_retrieval(filenames[0])
45/21: information_retrieval(filenames[1])
45/22:
raw = parser.from_file(filepath[0])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
type_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def safe_execute():
  
  try:
    return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
  except:
    return company_name_warning


safe_execute()

data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         [ISIN_m.group(1), ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "N/A"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type", pdf_extracted_cleaned[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "N/A"]]


df = pd.DataFrame(data)
46/1:
from tika import parser
import re
import pandas as pd
import glob
46/2:
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)
46/3: raw = parser.from_file(filepath[0])
47/1:
from tika import parser
import re
import pandas as pd
import glob


#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)


#------------------------------------------------------------------------------

raw = parser.from_file(filenames[0])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
type_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def safe_execute():
  
  try:
    return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
  except:
    return company_name_warning


safe_execute()

data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         [ISIN_m.group(1), ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "N/A"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type", pdf_extracted_cleaned[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "N/A"]]


df = pd.DataFrame(data)
48/1:
from tika import parser
import re
import pandas as pd
import glob


#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)
48/2:
raw = parser.from_file(filenames[0])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
type_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def safe_execute():
  
  try:
    return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
  except:
    return company_name_warning


safe_execute()

data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         [ISIN_m.group(1), ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "N/A"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type", pdf_extracted_cleaned[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "N/A"]]


df = pd.DataFrame(data)
48/3:
raw = parser.from_file(filenames[4])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
type_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def safe_execute():
  
  try:
    return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
  except:
    return company_name_warning


safe_execute()

data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         [ISIN_m.group(1), ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "N/A"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type", pdf_extracted_cleaned[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "N/A"]]


df = pd.DataFrame(data)
49/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
49/2: from grader import Grader
49/3: grader = Grader()
49/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
49/5:
from ast import literal_eval
import pandas as pd
import numpy as np
49/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
49/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
49/8: train.head()
49/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
49/10: X_train.shape[:]
49/11: X_train[0]
49/12: import re
49/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
49/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
49/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
49/16:
etc = etc.lower()
etc
49/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
49/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
49/19:
etc = etc.split();
etc
49/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
49/21:
etc = " ".join(i for i in etc)
etc
49/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
49/23: print(test_text_prepare())
49/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
49/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
49/26: X_train[:5]
49/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
49/28:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
49/29:
from collections import Counter

words_counts = Counter(test_list)
words_counts
49/30:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts
49/31:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
49/32:
# Install a pip package in the current Jupyter kernel
#import sys
#!{sys.executable} -m pip install pixiedust
49/33: import pixiedust
49/34:
import numpy as np

allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
49/35:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
49/36:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n{}".format(words))
    return words
49/37:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
49/38:
def word_extraction(sentence):
    ignore = ['a', "the", "is"] #Get rid of the stopwords (you can directly use [i for i in text if i not in STOPWORDS])
    words = re.sub("[^\w]", " ",  sentence).split() #replace anything that is not an alphanumeric character with whitespace
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
49/39:
def word_extraction(sentence):
    ignore = ['a', "the", "is"] #Get rid of the stopwords (you can directly use [i for i in text if i not in STOPWORDS])
    words = re.sub("[^\w]", " ",  sentence).split() #replace anything that is not an alphanumeric character with whitespace
    #in 
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
49/40:
def word_extraction(sentence):
    ignore = ['a', "the", "is"] #Get rid of the stopwords (you can directly use [i for i in text if i not in STOPWORDS])
    words = re.sub("[^\w]", " ",  sentence).split() #replace anything that is not an alphanumeric anything apart froma-zA-Z0-9_ character with whitespace
    #in "sentence"
    cleaned_text = [w.lower() for w in words if w not in ignore] #Make all letters 
    return cleaned_text
49/41:
%%pixie_debugger

for sentence in allsentences:
    words = word_extraction(sentence)
    bag_vector = np.zeros(len(vocab))
    for w in words:
        for i,word in enumerate(vocab):
            if word == w: 
                bag_vector[i] += 1
                    
    print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
50/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
50/2: from grader import Grader
50/3: grader = Grader()
50/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
50/5:
from ast import literal_eval
import pandas as pd
import numpy as np
50/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
50/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
50/8: train.head()
50/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
50/10: X_train.shape[:]
50/11: X_train[0]
50/12: import re
50/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
50/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
50/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
50/16:
etc = etc.lower()
etc
50/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
50/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
50/19:
etc = etc.split();
etc
50/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
50/21:
etc = " ".join(i for i in etc)
etc
50/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
50/23: print(test_text_prepare())
50/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
50/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
50/26: X_train[:5]
50/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
50/28:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
50/29:
from collections import Counter

words_counts = Counter(test_list)
words_counts
50/30:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts
50/31:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
50/32:
# Install a pip package in the current Jupyter kernel
#import sys
#!{sys.executable} -m pip install pixiedust
50/33: import pixiedust
50/34:
import numpy as np

allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
50/35:
def word_extraction(sentence):
    ignore = ['a', "the", "is"] #Get rid of the stopwords (you can directly use [i for i in text if i not in STOPWORDS])
    words = re.sub("[^\w]", " ",  sentence).split() #replace anything that is not an alphanumeric (alphanumeric charac:
    #a-zA-Z0-9_) character with whitespace in "sentence"
    cleaned_text = [w.lower() for w in words if w not in ignore] #Everything lowercase
    return cleaned_text
50/36:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n{}".format(words))
    return words
50/37:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
50/38:
%%pixie_debugger

for sentence in allsentences:
    words = word_extraction(sentence)
    bag_vector = np.zeros(len(vocab))
    for w in words:
        for i,word in enumerate(vocab):
            if word == w: 
                bag_vector[i] += 1
                    
    print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
51/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
51/2: from grader import Grader
51/3: grader = Grader()
51/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
51/5:
from ast import literal_eval
import pandas as pd
import numpy as np
51/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
51/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
51/8: train.head()
51/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
51/10: X_train.shape[:]
51/11: X_train[0]
51/12: import re
51/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
51/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
51/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
51/16:
etc = etc.lower()
etc
51/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
51/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
51/19:
etc = etc.split();
etc
51/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
51/21:
etc = " ".join(i for i in etc)
etc
51/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
51/23: print(test_text_prepare())
51/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
51/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
51/26: X_train[:5]
51/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
51/28:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
51/29:
from collections import Counter

words_counts = Counter(test_list)
words_counts
51/30:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts
51/31:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
51/32:
# Install a pip package in the current Jupyter kernel
#import sys
#!{sys.executable} -m pip install pixiedust
51/33: import pixiedust
51/34:
import numpy as np

allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
51/35:
def word_extraction(sentence):
    ignore = ['a', "the", "is"] #Get rid of the stopwords (you can directly use [i for i in text if i not in STOPWORDS])
    words = re.sub("[^\w]", " ",  sentence).split() #replace anything that is not an alphanumeric (alphanumeric charac:
    #a-zA-Z0-9_) character with whitespace in "sentence"
    cleaned_text = [w.lower() for w in words if w not in ignore] #Everything lowercase
    return cleaned_text
51/36:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        print(w)
        words.extend(w)
        
    words = sorted(list(set(words)))
    print("\n{}".format(words))
    return words
51/37:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
51/38:
%%pixie_debugger

for sentence in allsentences:
    words = word_extraction(sentence)
    bag_vector = np.zeros(len(vocab))
    for w in words:
        for i,word in enumerate(vocab):
            if word == w: 
                bag_vector[i] += 1
                    
    print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
51/39:
from sklearn.feature_extraction.text import CountVectorizer
corpus = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(corpus)
print(vectorizer.get_feature_names())

print(X.toarray())
51/40: X.train[:5]
51/41:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
tags_counts[:5]
51/42:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
51/43: X_train
51/44:
for i in X_train:
    print(i.split())
51/45:
sentences = []

for i in X_train:
    sentences.append(i.split())
51/46:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences
51/47:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences[:5]
51/48: train
51/49: words_counts
51/50: most_common_tags
51/51: first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
51/52:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
51/53:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word.values
51/54:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word.values()
51/55:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
len(first_5000_word)
51/56:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
51/57:
for i in sentences:
    print(i)
51/58:
for i in sentences:
    for j in i
51/59:
for i in sentences:
    for j in i:
        print(j)
51/60:
for i in sentences:
    for j,k in enumerate(i):
        print(j,k)
51/61:
for i in sentences:
    for j,k in enumerate(i):
        print(j,k)
51/62: result_vector = np.zeros(5000)
51/63:
result_vector = np.zeros(5000)
result_vector
51/64:
for i in sentences:
    for j in enumerate(i):
        for k, w in enumerate(first_5000_word):
            if w == j:
                result_vector[k] =+1
51/65:
for i in sentences:
    for j in i:
        for k, w in enumerate(first_5000_word):
            if w == j:
                result_vector[k] =+1
51/66:
for sentence in sentences:
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w == word:
                result_vector[i] =+1
51/67:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
51/68:
vocab = tokenize(allsentences)
print("\nWord List for Document \n{0} \n".format(vocab));
51/69:
#%%pixie_debugger

for sentence in allsentences:
    words = word_extraction(sentence)
    bag_vector = np.zeros(len(vocab))
    for w in words:
        for i,word in enumerate(vocab):
            if word == w: 
                bag_vector[i] += 1
                    
    print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
51/70:
#%%pixie_debugger

for sentence in allsentences:
    words = word_extraction(sentence)
    bag_vector = np.zeros(len(vocab))
    for w in words:
        for i,word in enumerate(vocab):
            if word == w: 
                bag_vector[i] += 1
                    
    print("{0}\n{1}\n".format(sentence,np.array(bag_vector)))
51/71:
from sklearn.feature_extraction.text import CountVectorizer
corpus = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
vectorizer = CountVectorizer()
X = vectorizer.fit_transform(corpus)
print(vectorizer.get_feature_names())

print(X.toarray())
51/72: X_train
51/73:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences[:5]
51/74:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
51/75:
result_vector = np.zeros(5000)
result_vector
51/76:
for sentence in sentences:
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w == word:
                result_vector[i] =+1
51/77:
%%pixie_debugger

for sentence in sentences:
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w == word:
                result_vector[i] =+1
52/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
52/2: from grader import Grader
52/3: grader = Grader()
52/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
52/5:
from ast import literal_eval
import pandas as pd
import numpy as np
52/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
52/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
52/8: train.head()
52/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
52/10: X_train.shape[:]
52/11: X_train[0]
52/12: import re
52/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
52/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
52/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
52/16:
etc = etc.lower()
etc
52/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
52/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
52/19:
etc = etc.split();
etc
52/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
52/21:
etc = " ".join(i for i in etc)
etc
52/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
52/23: print(test_text_prepare())
52/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
52/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
52/26: X_train[:5]
52/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
52/28:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
52/29:
from collections import Counter

words_counts = Counter(test_list)
words_counts
52/30:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
52/31:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
52/32:
# Install a pip package in the current Jupyter kernel
#import sys
#!{sys.executable} -m pip install pixiedust
52/33: import pixiedust
52/34:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences[:5]
52/35:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
52/36: w.key()
52/37:
for w in first_5000_word:
    print(w.key())
52/38: first_5000_word
52/39:
for w in first_5000_word:
    print(w[0])
52/40:
%%pixie_debugger

for sentence in sentences:
    bag_vector = np.zeros(len(first_5000_word))
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w[0] == word:
                bag_vector[i] =+1
52/41:
%%pixie_debugger

for sentence in sentences:
    bag_vector = np.zeros(len(first_5000_word))
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w[0] == "using":
                bag_vector[i] =+1
52/42:
#%%pixie_debugger

for sentence in sentences:
    bag_vector = np.zeros(len(first_5000_word))
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w[0] == word:
                bag_vector[i] =+1
53/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
53/2: from grader import Grader
53/3: grader = Grader()
53/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
53/5:
from ast import literal_eval
import pandas as pd
import numpy as np
53/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
53/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
53/8: train.head()
53/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
53/10: X_train.shape[:]
53/11: X_train[0]
53/12: import re
53/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
53/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
53/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
53/16:
etc = etc.lower()
etc
53/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
53/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
53/19:
etc = etc.split();
etc
53/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
53/21:
etc = " ".join(i for i in etc)
etc
53/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
53/23: print(test_text_prepare())
53/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
53/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
53/26: X_train[:5]
53/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
53/28:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
53/29:
from collections import Counter

words_counts = Counter(test_list)
words_counts
53/30:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
53/31:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
53/32:
# Install a pip package in the current Jupyter kernel
#import sys
#!{sys.executable} -m pip install pixiedust
53/33: import pixiedust
53/34:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
53/35: ALL_WORDS
53/36: first_5000_word
53/37:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
53/38: first_5000_word
53/39: first_5000_word[-1]
53/40: X_train
53/41:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences[:5]
53/42:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
53/43:
#%%pixie_debugger

for sentence in sentences:
    bag_vector = np.zeros(len(first_5000_word))
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w[0] == word:
                bag_vector[i] =+1
53/44: bag_vector[0]
53/45: bag_vector
53/46: df = pd.DataFrame(bag_vector)
53/47:
df = pd.DataFrame(bag_vector)
df
53/48: [1,2,3].to_array()
53/49: a.to_array([1,2,3])
53/50: a = np.array([1,2,3])
53/51:
a = np.array([1,2,3])
b = np.array([2,8,9])
53/52:
a = np.array([1,2,3])
b = np.array([2,8,9])
a = np.append(a)
53/53:
a = np.array([1,2,3])
b = np.array([2,8,9])
a = np.append(b)
53/54: a = np.append(b)
53/55:
DICT_SIZE = 5000
WORDS_TO_INDEX = ####### YOUR CODE HERE #######
INDEX_TO_WORDS = ####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    result_vector = np.zeros(dict_size)
    ######################################
    ######### YOUR CODE HERE #############
    ######################################
    return result_vector
53/56: c = np.append(a,b)
53/57:
c = np.append(a,b)
c
53/58:
c = np.vstack( [ a , b )
c
53/59:
c = np.vstack( [ a , b ])
c
53/60:
df = pd.DataFrame(bag_vector)
df[:5]
53/61:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
53/62:
def count_vectorizer(text, words_counts, first_how_many_words):
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    for sentence in sentences:
    bag_vector = np.zeros(len(first_x_word))
    for word in sentence:
        for i,w in enumerate(first_x_word):
            if w[0] == word:
                bag_vector[i] =+1
                
    return bag_vector
53/63:
def count_vectorizer(text, words_counts, first_how_many_words):
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    for sentence in sentences:
        bag_vector = np.zeros(len(first_x_word))
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] =+1
                
    return bag_vector
53/64:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(count_vectorizer(X_train, words_counts, 5000))])
53/65: from scipy import sparse as sp_sparse
53/66:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(count_vectorizer(X_train, words_counts, 5000))])
53/67:
df = pd.DataFrame(bag_vector)
df[]
53/68: X_train_mybag
53/69:
numpy.savetxt(r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\foo.csv",
              X_train_mybag,
              delimiter=",")
53/70:
np.savetxt(r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\foo.csv",
              X_train_mybag,
              delimiter=",")
53/71: X_train_mybag[0]
53/72: print('X_train shape ', X_train_mybag.shape)
53/73:
def count_vectorizer(text, words_counts, first_how_many_words):
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    bag_vector = np.zeros(len(first_x_word))
    for sentence in sentences:
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] =+1
                
    return bag_vector
53/74: from scipy import sparse as sp_sparse
53/75:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(count_vectorizer(X_train, words_counts, 5000))])
53/76: print('X_train shape ', X_train_mybag.shape)
53/77:
def test_my_bag_of_words():
    words_to_index = {'hi': 0, 'you': 1, 'me': 2, 'are': 3}
    examples = ['hi how are you']
    answers = [[1, 1, 0, 1]]
    for ex, ans in zip(examples, answers):
        if (my_bag_of_words(ex, words_to_index, 4) != ans).any():
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
53/78: test_my_bag_of_words
53/79:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
53/80:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
53/81:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = numpy.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
53/82:
allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
53/83:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
53/84:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
53/85:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = numpy.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
53/86:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = np.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
53/87: import pixiedust
53/88:
allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
53/89:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
53/90:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
53/91:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = np.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
53/92:
allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
53/93:
def word_extraction(sentence):
    ignore = ['a', "the", "is"]
    words = re.sub("[^\w]", " ",  sentence).split()
    cleaned_text = [w.lower() for w in words if w not in ignore]
    return cleaned_text
53/94:
def tokenize(sentences):
    words = []
    for sentence in sentences:
        w = word_extraction(sentence)
        words.extend(w)
        
    words = sorted(list(set(words)))
    return words
53/95:
def generate_bow(allsentences):    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = np.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
53/96: tokenize(allsentences)
53/97:
def generate_bow(allsentences):
    
    vocab = tokenize(allsentences)
    print("Word List for Document \n{0} \n".format(vocab));
for sentence in allsentences:
        words = word_extraction(sentence)
        bag_vector = np.zeros(len(vocab))
        for w in words:
            for i,word in enumerate(vocab):
                if word == w: 
                    bag_vector[i] += 1
                    
        print("{0}\n{1}\n".format(sentence,numpy.array(bag_vector)))
53/98: generate_bow(allsentences)
53/99:
def my_bag_of_words(text, words_counts, first_how_many_words):
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    bag_vector = np.zeros(len(first_x_word))
    for sentence in sentences:
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
53/100: from scipy import sparse as sp_sparse
53/101:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(X_train, words_counts, 5000))])
53/102:
def my_bag_of_words(text, words_counts, first_how_many_words):
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    
    for sentence in sentences:
        bag_vector = np.zeros(len(first_x_word))
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
53/103: from scipy import sparse as sp_sparse
53/104:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(X_train, words_counts, 5000))])
53/105:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(X_train, words_counts, 5000))])
53/106: print('X_train shape ', X_train_mybag.shape)
53/107:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
53/108: most_common_words
53/109: WORDS_TO_INDEX
53/110: INDEX_TO_WORDS
53/111: ALL_WORDS
53/112:
def my_bag_of_words(text, words_counts, first_how_many_words):
    
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
        
    bag_vector = np.zeros(len(first_x_word))    
    for sentence in text.split():
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
53/113: from scipy import sparse as sp_sparse
53/114:
def my_bag_of_words(text, words_counts, first_how_many_words):
    
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
        
    bag_vector = np.zeros(len(first_x_word))    
    for sentence in text.split():
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
53/115: from scipy import sparse as sp_sparse
53/116:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(text, words_counts, 5000)) for text in X_train])
53/117: print('X_train shape ', X_train_mybag.shape)
53/118:
def my_bag_of_words_wrong(text, words_counts, first_how_many_words):
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    for sentence in sentences:
        bag_vector = np.zeros(len(first_x_word))
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
53/119:
def my_bag_of_words_wrong(text, words_counts, first_how_many_words):
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    for sentence in sentences:
        bag_vector = np.zeros(len(first_x_word))
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
53/120:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words_wrong(text, words_counts, 5000))])
53/121:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words_wrong(X_train, words_counts, 5000))])
53/122: print('X_train shape ', X_train_mybag.shape)
53/123: ---
53/124:
def my_bag_of_words(text, words_counts, first_how_many_words):
    
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
        
    bag_vector = np.zeros(len(first_x_word))    
    for sentence in text.split():
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
53/125:
allsentences = ["Joe waited for the train train", "The train was late", "Mary and Samantha took the bus",
"I looked for Mary and Samantha at the bus station",
"Mary and Samantha arrived at the bus station early but waited until noon for the bus"]
53/126:
def words_counts_func(text):
    
    j = []
    test_list = []

    for i in X_train:
        j.append(i.split(" "))

    for k in j:
        for l in k:
            test_list.append(l)
        

    from collections import Counter

    words_counts = Counter(test_list)
    return words_counts
53/127:
def tag_counts_func(text):
    
    frequency_counter = []

    for i in train["tags"]:
        for j in i:
            frequency_counter.append(j)

    tags_counts = Counter(frequency_counter)#
    return tags_counts
53/128:
words_counts_func(X_train)
tag_counts_func(train["tags"])
53/129: words_counts_func(X_train)
53/130: tag_counts_func(train["tags"])[:5]
53/131: tag_counts_func(train["tags"])[1]
53/132: tag_counts_func(train["tags"])[0]
53/133: tag_counts_func(train["tags"])[11]
53/134: tag_counts_func(train["tags"])
53/135:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
53/136: ---
53/137: tags_counts = tag_counts_func(train["tags"])
53/138: words_counts = words_counts_func(X_train)
53/139:
def tag_counts_func(text):
    
    frequency_counter = []

    for i in text:
        for j in i:
            frequency_counter.append(j)

    tags_counts = Counter(frequency_counter)
    return tags_counts
53/140: train["tags"][:5]
53/141:
frequency_counter = []

for i in train["tags"]:
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
53/142:
frequency_counter = []

for i in train["tags"]:
    print(i)
    for j in i:
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
53/143:
frequency_counter = []

for i in train["tags"]:
    print(i)
    for j in i:
        print(j)
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
53/144:
<div class="alert alert-block alert-success">
<b>ATTENTION:</b> ---- TEST END ---- TEST END ---- TEST END ---- TEST END ----
</div>
53/145:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
53/146:
def words_counts_func(text):
    
    j = []
    test_list = []

    for i in text:
        j.append(i.split(" "))

    for k in j:
        for l in k:
            test_list.append(l)
        

    from collections import Counter

    words_counts = Counter(test_list)
    return words_counts
53/147:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
53/148:
def tag_counts_func(text):
    
    frequency_counter = []

    for i in text:
        for j in i:
            frequency_counter.append(j)

    tags_counts = Counter(frequency_counter)
    return tags_counts
53/149: train["tags"][:5]
53/150:
frequency_counter = []

for i in train["tags"]:
    print(i) # reveals tags for a single question
    for j in i:
        print(j) # As there are more than one tag for a question, this loop gets the tags from questions that have multiple tags
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
53/151: tags_counts = tag_counts_func(train["tags"])
53/152: words_counts = words_counts_func(X_train)
53/153:
def my_bag_of_words_wrong(text, words_counts, first_how_many_words):
    
    """
    Overrides the bag_vector everytime before returning it.
    This is why this function only returns X_train shape  (1, 5000)
    """
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    for sentence in sentences:
        bag_vector = np.zeros(len(first_x_word))
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
53/154:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences[:5]
53/155:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences[:5]
53/156:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
53/157:
#%%pixie_debugger

for sentence in sentences:
    bag_vector = np.zeros(len(first_5000_word))
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w[0] == word:
                bag_vector[i] =+1
                
    vstack = np.vstack(bag_vector)
53/158:
#%%pixie_debugger

for sentence in sentences:
    bag_vector = np.zeros(len(first_5000_word))
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w[0] == word:
                bag_vector[i] =+1
54/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
54/2: from grader import Grader
54/3: grader = Grader()
54/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
54/5:
from ast import literal_eval
import pandas as pd
import numpy as np
54/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
54/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
54/8: train.head()
54/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
54/10: X_train.shape[:]
54/11: X_train[0]
54/12: import re
54/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
54/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
54/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
54/16:
etc = etc.lower()
etc
54/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
54/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
54/19:
etc = etc.split();
etc
54/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
54/21:
etc = " ".join(i for i in etc)
etc
54/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
54/23: print(test_text_prepare())
54/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
54/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
54/26: X_train[:5]
54/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
54/28:
def words_counts_func(text):
    
    j = []
    test_list = []

    for i in text:
        j.append(i.split(" "))

    for k in j:
        for l in k:
            test_list.append(l)
        

    from collections import Counter

    words_counts = Counter(test_list)
    return words_counts
54/29:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
54/30:
def tag_counts_func(text):
    
    frequency_counter = []

    for i in text:
        for j in i:
            frequency_counter.append(j)

    tags_counts = Counter(frequency_counter)
    return tags_counts
54/31: train["tags"][:5]
54/32:
frequency_counter = []

for i in train["tags"]:
    print(i) # reveals tags for a single question
    for j in i:
        print(j) # As there are more than one tag for a question, this loop gets the tags from questions that have multiple tags
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
54/33: tags_counts = tag_counts_func(train["tags"])
54/34:
from collections import Counter

tags_counts = tag_counts_func(train["tags"])
54/35: words_counts = words_counts_func(X_train)
54/36:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
54/37:
# Install a pip package in the current Jupyter kernel
#import sys
#!{sys.executable} -m pip install pixiedust
54/38: import pixiedust
54/39:
def my_bag_of_words_wrong(text, words_counts, first_how_many_words):
    
    """
    Overrides the bag_vector everytime before returning it. -- because bag_vector =np.zeros(len(first_x_word))
    is inside the for loop. This is why this function only returns X_train shape  (1, 5000)
    
    To overcome this problem we fed the sentences directly to function rather than splitting the
    sentences inside the function. The function is excuted for every function and a unique sparse vector is created
    for every sentence. By repating the function by using SK learn's sparse functionality, we managed to vertical stack
    all sparse vector
    
    """
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    for sentence in sentences:
        bag_vector = np.zeros(len(first_x_word))
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
54/40:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences[:5]
54/41:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
54/42:
#%%pixie_debugger

for sentence in sentences:
    bag_vector = np.zeros(len(first_5000_word))
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w[0] == word:
                bag_vector[i] =+1
54/43:
def my_bag_of_words_wrong(text, words_counts, first_how_many_words):
    
    """
    Overrides the bag_vector everytime before returning it. -- because bag_vector =np.zeros(len(first_x_word))
    is inside the for loop. This is why this function only returns X_train shape  (1, 5000)
    
    To overcome this problem we fed the sentences directly to function rather than splitting the
    sentences inside the function. The function is excuted for every function and a unique sparse vector is created
    for every sentence. By repating the function by using SK learn's sparse functionality, we managed to vertical stack
    all sparse vector
    
    """
    
    sentences = []
    for i in text:
        sentences.append(i.split())
        
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
    
    for sentence in sentences:
        bag_vector = np.zeros(len(first_x_word))
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
54/44:
X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words_wrong(X_train, words_counts, 5000))])
54/45:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words_wrong(X_train, words_counts, 5000))])
54/46: print('X_train shape ', X_train_mybag.shape)
54/47:
sentences = []

for i in X_train:
    sentences.append(i.split())

sentences[:5]
54/48:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
54/49:
#%%pixie_debugger

for sentence in sentences:
    bag_vector = np.zeros(len(first_5000_word))
    for word in sentence:
        for i,w in enumerate(first_5000_word):
            if w[0] == word:
                bag_vector[i] =+1
54/50:
df = pd.DataFrame(bag_vector)
df
54/51:
def my_bag_of_words(text, words_counts, first_how_many_words):
    
    first_x_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:first_how_many_words]
        
    bag_vector = np.zeros(len(first_x_word))    
    for sentence in text.split():
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
54/52:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(text, words_counts, 5000)) for text in X_train])
54/53:
def my_bag_of_words(text, words_to_index, dict_size):
    
    first_x_word = sorted(words_to_index.items(), key=lambda x: x[1], reverse=True)[:dict_size]
        
    bag_vector = np.zeros(len(first_x_word))    
    for sentence in text.split():
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
54/54:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(text, words_counts, 5000)) for text in X_train])
X_test_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(text, words_counts, 5000)) for text in X_test])
X_val_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(text, words_counts, 5000)) for text in X_val])
55/1:
from tika import parser
import re
import pandas as pd
import glob


#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)


#------------------------------------------------------------------------------
55/2:
raw = parser.from_file(filenames[4])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718
}
55/3:
BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "QNB Finansbank A.Ş." : 159625,
    "QNB Finans Faktoring A.Ş." : 33546435,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
    "Zorlu Faktoring A.Ş." : 35057529,
    "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
    "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
    "Türk Ekonomi Bankası" : 217880,
    "TÜRKİYE HALK BANKASI A.Ş." : 216692,
    "Garanti Finansal Kiralama A.Ş." : 8750960,
    "T.C. ZİRAAT BANKASI A.Ş." : 183939,
    "T.C. Ziraat Bankası A.Ş." : 183939,
    "Yapı Kredi Faktoring A.Ş." : 12392512,
    "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
    "Türkiye Vakıflar Bankası T.A.O." : 805670,
    "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
    "Eko Faktoring A.Ş." : 31741179,
    "İş Yatırım Menkul Değerler A.Ş." : 8604427,
    "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
    "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
    "GARANTİ FAKTORİNG A.Ş." : 159580
}
55/4:
maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
type_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]
55/5:
company_name_warning = "---- Check the company name ----"

def safe_execute():
  
  try:
    return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
  except:
    return company_name_warning


safe_execute()
55/6:
data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         ["ISIN" if ISIN_m == None else ISIN_m.group(1),
          "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "-------"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type" if type_m == None else type_m[1],
          pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]
55/7: df = pd.DataFrame(data)
55/8:
def extract_information(filenames):
    
    from tika import parser
    import re
    import pandas as pd
    
    raw = parser.from_file(filenames[4])
    
    pdf_extracted = list(raw['content'].split("\n"))
    
    pdf_extracted_cleaned = []
    
    for i in pdf_extracted:
      if i != "" and i !=" " and i != "  " and i != "-":
        pdf_extracted_cleaned.append(i)
    
    BBID_Dict = {
        "AKBANK T.A.Ş." : 159576,
        "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
        "Bereket Varlık Kiralama A.Ş." : 28561089,
        "Yapı ve Kredi Bankası A.Ş." : 154568,
        "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
        "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
        "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
        "QNB FİNANSBANK A.Ş." : 159626,
        "YAPI VE KREDİ BANKASI A.Ş." : 154568,
        "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
        "T. Garanti Bankası A.Ş." : 126333,
        "Halk Varlık Kiralama A.Ş." : 59635062,
        "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
        "KT Kira Sertifikaları Varlık" : 38453748,
        "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
        "ZORLU FAKTORİNG A.Ş." : 35057529,
        "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
        "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
        "QNB Finansbank A.Ş." : 159625,
        "QNB Finans Faktoring A.Ş." : 33546435,
        "İŞ FAKTORİNG A.Ş." :  8604399,
        "ŞEKER FAKTORİNG A.Ş." : 8794207,
        "Şeker Faktoring A.Ş." : 8794207,
        "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
        "Zorlu Faktoring A.Ş." : 35057529,
        "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
        "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
        "Türk Ekonomi Bankası" : 217880,
        "TÜRKİYE HALK BANKASI A.Ş." : 216692,
        "Garanti Finansal Kiralama A.Ş." : 8750960,
        "T.C. ZİRAAT BANKASI A.Ş." : 183939,
        "T.C. Ziraat Bankası A.Ş." : 183939,
        "Yapı Kredi Faktoring A.Ş." : 12392512,
        "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
        "Türkiye Vakıflar Bankası T.A.O." : 805670,
        "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
        "Eko Faktoring A.Ş." : 31741179,
        "İş Yatırım Menkul Değerler A.Ş." : 8604427,
        "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
        "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
        "GARANTİ FAKTORİNG A.Ş." : 159580
    }
    
    #for i in pdf_extracted_cleaned:
    #  print(i)
    
    maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
    ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
    coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
    currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
    type_m = re.search(r"(Type) (M.+)", raw["content"])
    interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
    title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])
    
    currency_m_l = None
    title_company_m_l = None
    
    currency_m_l = [i for i in currency_m.groups() if i is not None]
    if title_company_m != None:
      title_company_m_l = [i for i in title_company_m.groups() if i is not None]
    
    
    company_name_warning = "---- Check the company name ----"
    
    def safe_execute():
      
      try:
        return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
      except:
        return company_name_warning
    
    safe_execute()
    
    data = [["Issuer" if title_company_m == None else title_company_m_l[0],
             pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
             ["BBID" , safe_execute()],
             [maturity_m.group(1), maturity_m.group(2)],
             ["ISIN" if ISIN_m == None else ISIN_m.group(1),
              "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
             [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
             coupon_number_m.group(2) if coupon_number_m != None else "-------"],
             [currency_m_l[0], currency_m_l[1]],
             ["Type" if type_m == None else type_m[1],
              pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
             [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
             interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]
    
    df = pd.DataFrame(data)
    return df
56/1:
import glob


#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)


#------------------------------------------------------------------------------

def extract_information(filenames):
    
    from tika import parser
    import re
    import pandas as pd
    
    raw = parser.from_file(filenames[4])
    
    pdf_extracted = list(raw['content'].split("\n"))
    
    pdf_extracted_cleaned = []
    
    for i in pdf_extracted:
      if i != "" and i !=" " and i != "  " and i != "-":
        pdf_extracted_cleaned.append(i)
    
    BBID_Dict = {
        "AKBANK T.A.Ş." : 159576,
        "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
        "Bereket Varlık Kiralama A.Ş." : 28561089,
        "Yapı ve Kredi Bankası A.Ş." : 154568,
        "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
        "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
        "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
        "QNB FİNANSBANK A.Ş." : 159626,
        "YAPI VE KREDİ BANKASI A.Ş." : 154568,
        "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
        "T. Garanti Bankası A.Ş." : 126333,
        "Halk Varlık Kiralama A.Ş." : 59635062,
        "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
        "KT Kira Sertifikaları Varlık" : 38453748,
        "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
        "ZORLU FAKTORİNG A.Ş." : 35057529,
        "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
        "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
        "QNB Finansbank A.Ş." : 159625,
        "QNB Finans Faktoring A.Ş." : 33546435,
        "İŞ FAKTORİNG A.Ş." :  8604399,
        "ŞEKER FAKTORİNG A.Ş." : 8794207,
        "Şeker Faktoring A.Ş." : 8794207,
        "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
        "Zorlu Faktoring A.Ş." : 35057529,
        "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
        "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
        "Türk Ekonomi Bankası" : 217880,
        "TÜRKİYE HALK BANKASI A.Ş." : 216692,
        "Garanti Finansal Kiralama A.Ş." : 8750960,
        "T.C. ZİRAAT BANKASI A.Ş." : 183939,
        "T.C. Ziraat Bankası A.Ş." : 183939,
        "Yapı Kredi Faktoring A.Ş." : 12392512,
        "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
        "Türkiye Vakıflar Bankası T.A.O." : 805670,
        "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
        "Eko Faktoring A.Ş." : 31741179,
        "İş Yatırım Menkul Değerler A.Ş." : 8604427,
        "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
        "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
        "GARANTİ FAKTORİNG A.Ş." : 159580
    }
    
    #for i in pdf_extracted_cleaned:
    #  print(i)
    
    maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
    ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
    coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
    currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
    type_m = re.search(r"(Type) (M.+)", raw["content"])
    interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
    title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])
    
    currency_m_l = None
    title_company_m_l = None
    
    currency_m_l = [i for i in currency_m.groups() if i is not None]
    if title_company_m != None:
      title_company_m_l = [i for i in title_company_m.groups() if i is not None]
    
    
    company_name_warning = "---- Check the company name ----"
    
    def safe_execute():
      
      try:
        return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
      except:
        return company_name_warning
    
    safe_execute()
    
    data = [["Issuer" if title_company_m == None else title_company_m_l[0],
             pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
             ["BBID" , safe_execute()],
             [maturity_m.group(1), maturity_m.group(2)],
             ["ISIN" if ISIN_m == None else ISIN_m.group(1),
              "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
             [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
             coupon_number_m.group(2) if coupon_number_m != None else "-------"],
             [currency_m_l[0], currency_m_l[1]],
             ["Type" if type_m == None else type_m[1],
              pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
             [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
             interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]
    
    df = pd.DataFrame(data)
    return df
56/2:
for i in filenames:
    print(i)
56/3:
results = []

for i in filenames:
    results.append(extract_information(i))
56/4:
results = []

for i in filenames:
    print(i)
57/1:
import glob


#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)


#------------------------------------------------------------------------------

def extract_information(filenames):
    
    from tika import parser
    import re
    import pandas as pd
    
    raw = parser.from_file(filenames)
    
    pdf_extracted = list(raw['content'].split("\n"))
    
    pdf_extracted_cleaned = []
    
    for i in pdf_extracted:
      if i != "" and i !=" " and i != "  " and i != "-":
        pdf_extracted_cleaned.append(i)
    
    BBID_Dict = {
        "AKBANK T.A.Ş." : 159576,
        "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
        "Bereket Varlık Kiralama A.Ş." : 28561089,
        "Yapı ve Kredi Bankası A.Ş." : 154568,
        "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
        "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
        "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
        "QNB FİNANSBANK A.Ş." : 159626,
        "YAPI VE KREDİ BANKASI A.Ş." : 154568,
        "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
        "T. Garanti Bankası A.Ş." : 126333,
        "Halk Varlık Kiralama A.Ş." : 59635062,
        "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
        "KT Kira Sertifikaları Varlık" : 38453748,
        "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
        "ZORLU FAKTORİNG A.Ş." : 35057529,
        "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
        "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
        "QNB Finansbank A.Ş." : 159625,
        "QNB Finans Faktoring A.Ş." : 33546435,
        "İŞ FAKTORİNG A.Ş." :  8604399,
        "ŞEKER FAKTORİNG A.Ş." : 8794207,
        "Şeker Faktoring A.Ş." : 8794207,
        "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
        "Zorlu Faktoring A.Ş." : 35057529,
        "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
        "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
        "Türk Ekonomi Bankası" : 217880,
        "TÜRKİYE HALK BANKASI A.Ş." : 216692,
        "Garanti Finansal Kiralama A.Ş." : 8750960,
        "T.C. ZİRAAT BANKASI A.Ş." : 183939,
        "T.C. Ziraat Bankası A.Ş." : 183939,
        "Yapı Kredi Faktoring A.Ş." : 12392512,
        "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
        "Türkiye Vakıflar Bankası T.A.O." : 805670,
        "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
        "Eko Faktoring A.Ş." : 31741179,
        "İş Yatırım Menkul Değerler A.Ş." : 8604427,
        "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
        "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
        "GARANTİ FAKTORİNG A.Ş." : 159580
    }
    
    #for i in pdf_extracted_cleaned:
    #  print(i)
    
    maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
    ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
    coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
    currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
    type_m = re.search(r"(Type) (M.+)", raw["content"])
    interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
    title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])
    
    currency_m_l = None
    title_company_m_l = None
    
    currency_m_l = [i for i in currency_m.groups() if i is not None]
    if title_company_m != None:
      title_company_m_l = [i for i in title_company_m.groups() if i is not None]
    
    
    company_name_warning = "---- Check the company name ----"
    
    def safe_execute():
      
      try:
        return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
      except:
        return company_name_warning
    
    safe_execute()
    
    data = [["Issuer" if title_company_m == None else title_company_m_l[0],
             pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
             ["BBID" , safe_execute()],
             [maturity_m.group(1), maturity_m.group(2)],
             ["ISIN" if ISIN_m == None else ISIN_m.group(1),
              "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
             [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
             coupon_number_m.group(2) if coupon_number_m != None else "-------"],
             [currency_m_l[0], currency_m_l[1]],
             ["Type" if type_m == None else type_m[1],
              pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
             [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
             interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]
    
    #df = pd.DataFrame(data)
    #return df
    
    return data
57/2:
results = []

for i in filenames:
    #print(i)
    results.append(extract_information(i))
57/3:
def extract_information(filenames):
    
    from tika import parser
    import re
    import pandas as pd
    
    raw = parser.from_file(filenames)
    
    pdf_extracted = list(raw['content'].split("\n"))
    
    pdf_extracted_cleaned = []
    
    for i in pdf_extracted:
      if i != "" and i !=" " and i != "  " and i != "-":
        pdf_extracted_cleaned.append(i)
    
    BBID_Dict = {
        "AKBANK T.A.Ş." : 159576,
        "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
        "Bereket Varlık Kiralama A.Ş." : 28561089,
        "BEREKET VARLIK KİRALAMA A.Ş." : 28561089,
        "Yapı ve Kredi Bankası A.Ş." : 154568,
        "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
        "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
        "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
        "QNB FİNANSBANK A.Ş." : 159626,
        "YAPI VE KREDİ BANKASI A.Ş." : 154568,
        "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
        "T. Garanti Bankası A.Ş." : 126333,
        "Halk Varlık Kiralama A.Ş." : 59635062,
        "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
        "KT Kira Sertifikaları Varlık" : 38453748,
        "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
        "ZORLU FAKTORİNG A.Ş." : 35057529,
        "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
        "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
        "QNB Finansbank A.Ş." : 159625,
        "QNB Finans Faktoring A.Ş." : 33546435,
        "İŞ FAKTORİNG A.Ş." :  8604399,
        "ŞEKER FAKTORİNG A.Ş." : 8794207,
        "Şeker Faktoring A.Ş." : 8794207,
        "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
        "Zorlu Faktoring A.Ş." : 35057529,
        "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
        "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
        "Türk Ekonomi Bankası" : 217880,
        "TÜRKİYE HALK BANKASI A.Ş." : 216692,
        "Garanti Finansal Kiralama A.Ş." : 8750960,
        "T.C. ZİRAAT BANKASI A.Ş." : 183939,
        "T.C. Ziraat Bankası A.Ş." : 183939,
        "Yapı Kredi Faktoring A.Ş." : 12392512,
        "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
        "Türkiye Vakıflar Bankası T.A.O." : 805670,
        "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
        "Eko Faktoring A.Ş." : 31741179,
        "İş Yatırım Menkul Değerler A.Ş." : 8604427,
        "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
        "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
        "GARANTİ FAKTORİNG A.Ş." : 159580
    }
    
    #for i in pdf_extracted_cleaned:
    #  print(i)
    
    maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
    ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
    coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
    currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
    type_m = re.search(r"(Type) (M.+)", raw["content"])
    interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
    title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])
    
    currency_m_l = None
    title_company_m_l = None
    
    currency_m_l = [i for i in currency_m.groups() if i is not None]
    if title_company_m != None:
      title_company_m_l = [i for i in title_company_m.groups() if i is not None]
    
    
    company_name_warning = "---- Check the company name ----"
    
    def safe_execute():
      
      try:
        return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
      except:
        return company_name_warning
    
    safe_execute()
    
    data = [["Issuer" if title_company_m == None else title_company_m_l[0],
             pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
             ["BBID" , safe_execute()],
             [maturity_m.group(1), maturity_m.group(2)],
             ["ISIN" if ISIN_m == None else ISIN_m.group(1),
              "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
             [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
             coupon_number_m.group(2) if coupon_number_m != None else "-------"],
             [currency_m_l[0], currency_m_l[1]],
             ["Type" if type_m == None else type_m[1],
              pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
             [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
             interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]
    
    #df = pd.DataFrame(data)
    #return df
    
    return data


#==============================================================================

results = []

for i in filenames:
    #print(i)
    results.append(extract_information(i))
57/4:
import xlwt 

workbook = xlwt.Workbook()  

sheet = workbook.add_sheet("Sheet Name") 

# Specifying column 
sheet.write(0, 0, '=BDP("TR0GRAN01202" & " Corp", "TICKER")') 
workbook.save("sample.xls")
57/5:
from xlwt import Workbook 

# Workbook is created 
wb = Workbook() 

# add_sheet is used to create sheet. 
sheet1 = wb.add_sheet('Sheet 1') 

sheet1.write(1, 0, '=BDP("TR0GRAN01202" & " Corp", "TICKER")')  
wb.save('xlwt example.xls')
57/6: from xlwt import Workbook
57/7: from xlwt import Workbook
57/8:
import xlwt 
from xlwt import Workbook 

# Workbook is created 
wb = Workbook() 

# add_sheet is used to create sheet. 
sheet1 = wb.add_sheet('Sheet 1') 

sheet1.write(1, 0, '=BDP("TR0GRAN01202" & " Corp", "TICKER")') 


wb.save('xlwt example.xls')
57/9: import xlwt
57/10:
import xlwt 
from xlwt import Workbook 

# Workbook is created 
wb = Workbook() 

# add_sheet is used to create sheet. 
sheet1 = wb.add_sheet('Sheet 1') 

sheet1.write(1, 0, '=BDP("TR0GRAN01202" & " Corp", "TICKER")') 


wb.save('xlwt example.xls'
57/11:
import xlwt 
from xlwt import Workbook 

# Workbook is created 
wb = Workbook() 

# add_sheet is used to create sheet. 
sheet1 = wb.add_sheet('Sheet 1') 

sheet1.write(1, 0, '=BDP("TR0GRAN01202" & " Corp", "TICKER")') 


wb.save('xlwt example.xls')
57/12:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
workbook = xlsxwriter.Workbook('hello.xlsx') 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write('A1', 'Hello..') 

# Finally, close the Excel file 
# via the close() method. 
workbook.close()
57/13:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
workbook = xlsxwriter.Workbook('hello.xlsx') 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write('A1', '=BDP("TR0GRAN01202" & " Corp", "TICKER")') 

# Finally, close the Excel file 
# via the close() method. 
workbook.close()
57/14:
import xlrd 

# Give the location of the file 
loc = ("C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx") 

# To open Workbook 
wb = xlrd.open_workbook(loc) 
sheet = wb.sheet_by_index(0) 

# For row 0 and column 0 
sheet.cell_value(0, 0)
57/15:
import xlrd 

# Give the location of the file 
loc = (r"C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx") 

# To open Workbook 
wb = xlrd.open_workbook(loc) 
sheet = wb.sheet_by_index(0) 

# For row 0 and column 0 
sheet.cell_value(0, 0)
54/55:
print('X_train shape ', X_train_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
54/56:
def test_my_bag_of_words():
    words_to_index = {'hi': 0, 'you': 1, 'me': 2, 'are': 3}
    examples = ['hi how are you']
    answers = [[1, 1, 0, 1]]
    for ex, ans in zip(examples, answers):
        if (my_bag_of_words(ex, words_to_index, 4) != ans).any():
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
54/57: print(test_my_bag_of_words())
54/58: test = "Jimmys old car has broken down"
54/59:
test = ["Jimmy old car has broken down",
       "However Jimmy is okay with it"]
54/60:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
54/61:
X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
57/16:
import pandas as pd
df = pd.read_xlsx(loc)
57/17:
import pandas as pd
df = pd.read_excel(loc)
57/18:
loc = (r"C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx") 


import pandas as pd
df = pd.read_excel(loc)
57/19:
loc = (r"C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx") 


import pandas as pd
df = pd.read_excel(loc)
54/62:
def test_my_bag_of_words():
    words_to_index = {'hi': 0, 'you': 1, 'me': 2, 'are': 3}
    examples = ['hi how are you']
    answers = [[1, 1, 0, 1]]
    for ex, ans in zip(examples, answers):
        if (my_bag_of_words(ex, words_to_index, 4) != ans).any():
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
54/63: print(test_my_bag_of_words())
54/64: most_common_words
54/65:
most_common_words
WORDS_TO_INDEX
54/66:
most_common_words
WORDS_TO_INDEX
INDEX_TO_WORDS
54/67:
most_common_words
WORDS_TO_INDEX
INDEX_TO_WORDS
ALL_WORDS
54/68:
most_common_words
WORDS_TO_INDEX
58/1: runfile('C:/Users/Cagri/.spyder-py3/temp.py', wdir='C:/Users/Cagri/.spyder-py3')
58/2:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
workbook = xlsxwriter.Workbook(r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx') 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write('A1', '=BDP("TR0GRAN01202" & " Corp", "TICKER")') 

# Finally, close the Excel file 
# via the close() method. 
workbook.close()
58/3:
import pandas as pd
df = pd.read_excel(loc)
58/4: import pandas as pd
58/5: df = pd.read_excel(r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx')
58/6:
import pandas as pd
df = pd.read_excel(r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx', sheet_name=None)
58/7:
import pandas as pd
df = pd.read_excel(r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx', sheetname=
58/8:
import pandas as pd
df = pd.read_excel(r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx', sheetname = None)
58/9:
import pandas as pd
from pandas import ExcelWriter
from pandas import ExcelFiled
58/10: path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
58/11:
import pandas as pd
df = pd.read_excel(path, index_col=0)  # doctest: +SKIP
58/12:
import pandas as pd
df = pd.read_excel(path, index_col=0)  # doctest: +SKIP
58/13:
import pandas as pd
df = pd.read_excel(path, index_col=0)  # doctest: +SKIP
58/14:
import pandas as pd
df = pd.read_excel(path, index_col=0)  # doctest: +SKIP
58/15:
import pandas as pd
df = pd.read_excel(path, index_col=0)  # doctest: +SKIP
58/16: import pandas as pd
58/17: pd.__version__
58/18:
import pandas as pd
df = pd.read_excel(path, index_col=0)  # doctest: +SKIP
58/19:
import csv

csvData = ['=BDP("TR0GRAN01202" & " Corp", "TICKER")']

with open('person.csv', 'w') as csvFile:
    writer = csv.writer(csvFile)
    writer.writerows(csvData)


csvFile.close()
58/20: import xlrd
58/21: import xlrd
59/1: import xlrd
60/1: xlrd.version
60/2: import xlrd
61/1: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
61/2: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
62/1: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
62/2: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
63/1: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
64/1:
import sys
!{sys.executable} -m pip install tika
64/2:
"""
Spyder Editor

This is a temporary script file.
"""


import glob


#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)

#------------------------------------------------------------------------------

def extract_information(filenames):
        
    from tika import parser
    import re
    import pandas as pd
        
    raw = parser.from_file(filenames)
    
    pdf_extracted = list(raw['content'].split("\n"))
    
    pdf_extracted_cleaned = []
    
    for i in pdf_extracted:
      if i != "" and i !=" " and i != "  " and i != "-":
        pdf_extracted_cleaned.append(i)
    
    BBID_Dict = {
        "AKBANK T.A.Ş." : 159576,
        "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
        "Bereket Varlık Kiralama A.Ş." : 28561089,
        "BEREKET VARLIK KİRALAMA A.Ş." : 28561089,
        "Yapı ve Kredi Bankası A.Ş." : 154568,
        "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
        "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
        "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
        "QNB FİNANSBANK A.Ş." : 159626,
        "YAPI VE KREDİ BANKASI A.Ş." : 154568,
        "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
        "T. Garanti Bankası A.Ş." : 126333,
        "Halk Varlık Kiralama A.Ş." : 59635062,
        "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
        "KT Kira Sertifikaları Varlık" : 38453748,
        "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
        "ZORLU FAKTORİNG A.Ş." : 35057529,
        "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
        "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
        "QNB Finansbank A.Ş." : 159625,
        "QNB Finans Faktoring A.Ş." : 33546435,
        "İŞ FAKTORİNG A.Ş." :  8604399,
        "ŞEKER FAKTORİNG A.Ş." : 8794207,
        "Şeker Faktoring A.Ş." : 8794207,
        "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
        "Zorlu Faktoring A.Ş." : 35057529,
        "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
        "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
        "Türk Ekonomi Bankası" : 217880,
        "TÜRKİYE HALK BANKASI A.Ş." : 216692,
        "Garanti Finansal Kiralama A.Ş." : 8750960,
        "T.C. ZİRAAT BANKASI A.Ş." : 183939,
        "T.C. Ziraat Bankası A.Ş." : 183939,
        "Yapı Kredi Faktoring A.Ş." : 12392512,
        "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
        "Türkiye Vakıflar Bankası T.A.O." : 805670,
        "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
        "Eko Faktoring A.Ş." : 31741179,
        "İş Yatırım Menkul Değerler A.Ş." : 8604427,
        "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
        "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
        "GARANTİ FAKTORİNG A.Ş." : 159580
    }
    
    #for i in pdf_extracted_cleaned:
    #  print(i)
      
    maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
    ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
    coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
    currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
    type_m = re.search(r"(Type) (M.+)", raw["content"])
    interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
    title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])
    
    currency_m_l = None
    title_company_m_l = None
    
    currency_m_l = [i for i in currency_m.groups() if i is not None]
    if title_company_m != None:
      title_company_m_l = [i for i in title_company_m.groups() if i is not None]
      
    
    company_name_warning = "---- Check the company name ----"
    
    def safe_execute():
      
      try:
        return BBID_Dict[pdf_extracted_cleaned[1]] if title_company_m == None else  BBID_Dict[title_company_m_l[1]]
      except:
        return company_name_warning
      
    safe_execute()
    
    data = [["Issuer" if title_company_m == None else title_company_m_l[0],
             pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
             ["BBID" , safe_execute()],
             [maturity_m.group(1), maturity_m.group(2)],
             ["ISIN" if ISIN_m == None else ISIN_m.group(1),
              "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
             [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
             coupon_number_m.group(2) if coupon_number_m != None else "-------"],
             [currency_m_l[0], currency_m_l[1]],
             ["Type" if type_m == None else type_m[1],
              pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
             [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
             interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]
    
    #df = pd.DataFrame(data)
    #return df
    
    return data

#==============================================================================
    
results = []

for i in filenames:
    #print(i)
    results.append(extract_information(i))


    
import xlsxwriter 
  
# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 
  
# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 
  
# Use the worksheet object to write 
# data via the write() method. 
worksheet.write('A1', '=BDP("TR0GRAN01202" & " Corp", "TICKER")') 
  
# Finally, close the Excel file 
# via the close() method. 
workbook.close()
64/3: import xlrd
65/1: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
65/2: import xlrd
65/3:
import xlrd
df = pd.read_excel(path
65/4:
import xlrd
df = pd.read_excel(path)
65/5:
import xlrd
import pandas as pd
df = pd.read_excel(path)
65/6:
import pandas as pd
df = pd.read_excel(path, index_col = 0)
65/7:
results = []

for i in filenames:
    #print(i)
    results.append(extract_information(i))




import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write('A1', '=BDP("TR0GRAN01202" & " Corp", "TICKER")') 

# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import pandas as pd
df = pd.read_excel(path, index_col = 0)
65/8: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
65/9: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
65/10:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write('A1', '=BDP("TRDBRKT81937" & " Corp", "TICKER")') 

# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import pandas as pd
df = pd.read_excel(path, index_col = 0)
65/11:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
65/12:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A2','=BDP("TRDBRKT81937" & " Corp", "TICKER")')

# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import pandas as pd
df = pd.read_excel(path, index_col = 0)
65/13:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A2','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
65/14:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A2','=BDP("TRDBRKT819375" & " Corp", "TICKER")')
65/15:
import openpyxl
wb = openpyxl.load_workbook('test.xlsx')
Sheet = wb.get_sheet_by_name('Sheet1')
65/16:
import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb.get_sheet_by_name('Sheet1')
65/17:
import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb['Sheet1']
65/18:
for cellObj in Sheet.columns[1]:
    print(cellObj.value)
65/19:
for cellObj in Sheet.columns[1]:
    print(cellObj.value())
65/20:
import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb['Sheet1']
65/21:
for cellObj in Sheet.columns[1]:
    print(cellObj.value())
65/22:
for cellObj in Sheet:
    print(cellObj.value())
65/23:
for cellObj in Sheet:
    print(cellObj)
65/24:
for cellObj in Sheet:
    print(cellObj.Sheet1.A1)
65/25:
for cellObj in Sheet:
    print(cellObj)
65/26:
for cellObj in Sheet:
    print(cellObj,values())
65/27:
for cellObj in Sheet:
    print(cellObj,value())
65/28:
for cellObj in Sheet:
    print(cellObj.value())
65/29:
import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb.active
65/30: ws["A1"]
65/31: Sheet["A1"]
65/32:
for row in Sheet.values:
   for value in row:
     print(value)
65/33:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
65/34: workbook.close()
65/35: workbook.close()
65/36:
import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb.active
Sheet["A1"]

for row in Sheet.values:
   for value in row:
     print(value)
65/37: Sheet.values
65/38: Sheet.values[0]
65/39: Sheet.values["A1"]
65/40:
for i in Sheet.values:
    print(i)
65/41:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
#worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()
65/42:
import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb.active
Sheet["A1"]

for row in Sheet.values:
   for value in row:
     print(value)
65/43:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
#worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A1','Sum(A1:A5)')
65/44: workbook.close()
65/45:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
65/46:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")',num_format, 4)
#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb.active
Sheet["A1"]

for row in Sheet.values:
   for value in row:
     print(value)
65/47:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")', 4)
#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb.active
Sheet["A1"]

for row in Sheet.values:
   for value in row:
     print(value)
65/48:
import openpyxl
wb = openpyxl.load_workbook(path)
Sheet = wb.active
print(Sheet["A1"].value)
65/49:
import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
65/50:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
65/51:
import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
65/52:
import xlrd

read_fullreport = xlrd.open_workbook(path)
read_fullreport_sheet = read_fullreport.sheet_by_index(0)
ipAddressofMC = read_fullreport_sheet.cell_value(0, 0)
65/53:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()
65/54:
import xlrd

read_fullreport = xlrd.open_workbook(path)
read_fullreport_sheet = read_fullreport.sheet_by_index(0)
ipAddressofMC = read_fullreport_sheet.cell_value(0, 0)
65/55:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
65/56:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A2','Sum(A3:A5)')

#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
65/57: print(Sheet["A2"].value)
65/58:
import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
65/59: print(Sheet["A2"].value)
65/60:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A2','Sum(A3:A5)')
worksheet.write('A3',2)
worksheet.write('A4',7)
worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/61:
import xlrd

read_fullreport = xlrd.open_workbook(path)
read_fullreport_sheet = read_fullreport.sheet_by_index(0)
ipAddressofMC = read_fullreport_sheet.cell_value(0, 0)
65/62:
import xlrd

read_fullreport = xlrd.open_workbook(path)
read_fullreport_sheet = read_fullreport.sheet_by_index(0)
ipAddressofMC = read_fullreport_sheet.cell_value(1, 0)
65/63:
import xlrd

read_fullreport = xlrd.open_workbook(path)
read_fullreport_sheet = read_fullreport.sheet_by_index(0)
ipAddressofMC = read_fullreport_sheet.cell_value(2, 0)
65/64:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A2','Sum(A3:A5)')
worksheet.write('A3',2)
worksheet.write('A4',7)
worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import openpyxl
wb = openpyxl.load_workbook(path, data_only = False)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/65:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A2','Sum(A3:A5)')
worksheet.write('A3',2)
worksheet.write('A4',7)
worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close() 

import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/66:
import psutil
import subprocess
doc = subprocess.Popen(["start", "/WAIT", path], shell=True)
65/67: doc.poll()
65/68:
psutil.Process(doc.pid).get_children()[0].kill()
doc.poll()
65/69:
import psutil
import subprocess
doc = subprocess.Popen(["start", "/WAIT", path], shell=True)
doc.poll()
psutil.Process(doc.pid).get_children()[0].kill()
doc.poll()
65/70:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A2','Sum(A3:A5)')
worksheet.write('A3',2)
worksheet.write('A4',7)
worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()

import psutil
import subprocess
doc = subprocess.Popen(["start", "/WAIT", path], shell=True)
doc.poll()
psutil.Process(doc.pid).get_children()[0].kill()
doc.poll() 

import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/71:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A2','Sum(A3:A5)')
worksheet.write('A3',2)
worksheet.write('A4',7)
worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()

import psutil
import subprocess
doc = subprocess.Popen(["start", "/WAIT", path], shell=True)
doc.poll()
#psutil.Process(doc.pid).get_children()[0].kill()
#doc.poll() 

import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/72:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
worksheet.write_formula('A2','Sum(A3:A5)')
worksheet.write('A3',2)
worksheet.write('A4',7)
worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()

import psutil
import subprocess
doc = subprocess.Popen(["start", "/WAIT", path], shell=True)
doc.poll()
#psutil.Process(doc.pid).get_children()[0].kill()
#doc.poll()
65/73:
import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/74:
import os
file = path
os.startfile(file)
65/75:
import os
file = path
os.startfile(file)

import psutil
import subprocess
doc = subprocess.Popen(["start", "/WAIT", path], shell=True)   #Stores the open file as doc
doc.poll()                                                           #Shows that the process still exists (will return 0 if the /WAIT argument is excluded from previous line)
psutil.Process(doc.pid).get_children()[0].kill()                     #Kills the process
doc.poll()                                                           #Shows that the process has been killed
65/76:
import os
file = path
fd = os.startfile(file)

os.close( fd )
65/77:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A2','Sum(A3:A5)')
#worksheet.write('A3',2)
#worksheet.write('A4',7)
#worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()
65/78:
import os
file = path
fd = os.startfile(file)
os.close( fd )
65/79: os.close( fd )
65/80: fo = open(path)
65/81:
fo = open(path)
fo.close()
65/82:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A2','Sum(A3:A5)')
#worksheet.write('A3',2)
#worksheet.write('A4',7)
#worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()
65/83:
import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/84:
fo = open(path)
fo.close()
65/85:
import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/86:
import os
file = path
fd = os.startfile(file)
os.kill
65/87:
import os
import time
file = path
fd = os.startfile(file)
time.sleep(5.5)
os.kill
65/88:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A2','Sum(A3:A5)')
#worksheet.write('A3',2)
#worksheet.write('A4',7)
#worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()

import os
import time
file = path
fd = os.startfile(file)
time.sleep(5.5)
os.kill
65/89:
import os
import time
import subprocess

#file = path
#fd = os.startfile(file)
#time.sleep(5.5)

proc = subprocess.Popen(path)
time.sleep(5)
proc.terminate()
proc.wait()
65/90:
import os
import time
import subprocess

#file = path
#fd = os.startfile(file)
#time.sleep(5.5)
65/91: proc = subprocess.Popen(path)
65/92:
import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", path], shell=True)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
65/93: psutil.Process(doc.pid).get_children()[0].kill()
65/94: psutil.Process(doc.pid).children()[0].kill()
65/95:
import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", path], shell=True)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
psutil.Process(doc.pid).children()[0].kill()
doc.poll()
65/96:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A2','Sum(A3:A5)')
#worksheet.write('A3',2)
#worksheet.write('A4',7)
#worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()

#import os
#import time
#import subprocess

#file = path
#fd = os.startfile(file)
#time.sleep(5.5)
65/97:
import psutil
import subprocess
65/98: doc = subprocess.Popen(["start", "/WAIT", path], shell=True)
65/99: doc.poll()                                                         #Shows that the process has been killed
65/100: psutil.Process(doc.pid).children()[0].kill()
65/101: doc.poll()
65/102:
import openpyxl
wb = openpyxl.load_workbook(path, data_only = True)
Sheet = wb.active
print(Sheet["A1"].value)
print(Sheet["A2"].value)
print(Sheet["A3"].value)
print(Sheet["A4"].value)
print(Sheet["A5"].value)
65/103:
import psutil
import subprocess

doc = subprocess.Popen(["start", 5, path], shell=True)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
psutil.Process(doc.pid).children()[0].kill()
doc.poll()
65/104: test_p = r"C:\Users\Cagri\Desktop\Turkish Term Sheets\759635_Type_2_Sukuk.pdf"
65/105:
import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", test_p], shell=True)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
psutil.Process(doc.pid).children()[0].kill()
doc.poll()
65/106: doc = subprocess.Popen(["start", "/WAIT", test_p], shell=True)   #Stores the open file as doc
65/107: doc.poll()                                                         #Shows that the process has been killed
65/108: psutil.Process(doc.pid).children()[0].kill()
65/109: doc.poll()
65/110:
import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", test_p], shell=False)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
psutil.Process(doc.pid).children()[0].kill()
doc.poll()
65/111:
test_p = r"C:\Users\Cagri\Desktop\Turkish Term Sheets\759635_Type_2_Sukuk.pdf"

import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", test_p], shell=False)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
psutil.Process(doc.pid).children()[0].kill()
doc.poll()
65/112:
test_p = r"C:\Users\Cagri\Desktop\Turkish Term Sheets\759635_Type_2_Sukuk.pdf"

import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", test_p], shell=True)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
psutil.Process(doc.pid).children()[0].kill()
doc.poll()
65/113:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A2','Sum(A3:A5)')
#worksheet.write('A3',2)
#worksheet.write('A4',7)
#worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()

#import os
#import time
#import subprocess

#file = path
#fd = os.startfile(file)
#time.sleep(5.5)

test_p = r"C:\Users\Cagri\Desktop\Turkish Term Sheets\759635_Type_2_Sukuk.pdf"

import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", test_p], shell=True)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
psutil.Process(doc.pid).children()[0].kill()
doc.poll()
65/114:
import xlsxwriter 

# Workbook() takes one, non-optional, argument  
# which is the filename that we want to create. 
path = r'C:\Users\Cagri\Desktop\Turkish Term Sheets\ISIN.xlsx'
workbook = xlsxwriter.Workbook(path) 

# The workbook object is then used to add new  
# worksheet via the add_worksheet() method. 
worksheet = workbook.add_worksheet() 

# Use the worksheet object to write 
# data via the write() method. 
worksheet.write_formula('A1','=BDP("TRDBRKT81937" & " Corp", "TICKER")')
#worksheet.write_formula('A2','Sum(A3:A5)')
#worksheet.write('A3',2)
#worksheet.write('A4',7)
#worksheet.write('A5',4)


#worksheet.write_formula('A1','Sum(A1:A5)')


# Finally, close the Excel file 
# via the close() method. 
workbook.close()

#import os
#import time
#import subprocess

#file = path
#fd = os.startfile(file)
#time.sleep(5.5)

import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", path], shell=True)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
psutil.Process(doc.pid).children()[0].kill()
doc.poll()
65/115:
import psutil
import subprocess

doc = subprocess.Popen(["start", "/WAIT", path], shell=True)   #Stores the open file as doc
doc.poll()                                                         #Shows that the process has been killed
try:
    psutil.Process(doc.pid).children()[0].kill()
except:
    print("it is already killed")

doc.poll()
65/116: doc = subprocess.Popen(["start", "/WAIT", path], shell=True)   #Stores the open file as doc
65/117: doc.poll()                                                         #Shows that the process has been killed
65/118:
try:
    psutil.Process(doc.pid).children()[0].kill()
except:
    print("it is already killed")
65/119:
import os
import time
import subprocess

file = path
fd = os.startfile(file)
65/120:
import psutil
import subprocess
65/121: doc = subprocess.Popen(["start", "/WAIT", path], shell=True)   #Stores the open file as doc
65/122: doc.poll()                                                         #Shows that the process has been killed
65/123:
doc.poll()                                                         #Shows that the process has been killed
try:
    psutil.Process(doc.pid).children()[0].kill()
except:
    print("it is already killed")
65/124: doc.poll()
66/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
66/2: from grader import Grader
66/3: grader = Grader()
66/4:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
66/5:
from ast import literal_eval
import pandas as pd
import numpy as np
66/6:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
66/7:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
66/8: train.head()
66/9:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
66/10: X_train.shape[:]
66/11: X_train[0]
66/12: import re
66/13:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
66/14:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
66/15: etc = r"A[ny te\xt CAN b`e this t]o the way"
66/16:
etc = etc.lower()
etc
66/17:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
66/18:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
66/19:
etc = etc.split();
etc
66/20:
etc = [word for word in etc if word not in STOPWORDS]
etc
66/21:
etc = " ".join(i for i in etc)
etc
66/22:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
66/23: print(test_text_prepare())
66/24:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
66/25:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
66/26: X_train[:5]
66/27:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
66/28:
def words_counts_func(text):
    
    j = []
    test_list = []

    for i in text:
        j.append(i.split(" "))

    for k in j:
        for l in k:
            test_list.append(l)
        

    from collections import Counter

    words_counts = Counter(test_list)
    return words_counts
66/29:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
66/30:
def tag_counts_func(text):
    
    frequency_counter = []

    for i in text:
        for j in i:
            frequency_counter.append(j)

    tags_counts = Counter(frequency_counter)
    return tags_counts
66/31: train["tags"][:5]
66/32:
frequency_counter = []

for i in train["tags"]:
    print(i) # reveals tags for a single question
    for j in i:
        print(j) # As there are more than one tag for a question, this loop gets the tags from questions that have multiple tags
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
66/33:
most_common_words
WORDS_TO_INDEX
66/34:
X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
66/35:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
66/36:
most_common_words
WORDS_TO_INDEX
66/37:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
66/38: from grader import Grader
66/39: grader = Grader()
66/40:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
66/41:
from ast import literal_eval
import pandas as pd
import numpy as np
66/42:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
66/43:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
66/44: train.head()
66/45:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
66/46: X_train.shape[:]
66/47: X_train[0]
66/48: import re
66/49:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
66/50:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
66/51: etc = r"A[ny te\xt CAN b`e this t]o the way"
66/52:
etc = etc.lower()
etc
66/53:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
66/54:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
66/55:
etc = etc.split();
etc
66/56:
etc = [word for word in etc if word not in STOPWORDS]
etc
66/57:
etc = " ".join(i for i in etc)
etc
66/58:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
66/59: print(test_text_prepare())
66/60:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
66/61:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
66/62: X_train[:5]
66/63:
# Dictionary of all tags from train corpus with their counts.
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
66/64:
def words_counts_func(text):
    
    j = []
    test_list = []

    for i in text:
        j.append(i.split(" "))

    for k in j:
        for l in k:
            test_list.append(l)
        

    from collections import Counter

    words_counts = Counter(test_list)
    return words_counts
66/65:
j = []
test_list = []

for i in X_train:
    j.append(i.split(" "))

for k in j:
    for l in k:
        test_list.append(l)
        
test_list[:5]
66/66:
def tag_counts_func(text):
    
    frequency_counter = []

    for i in text:
        for j in i:
            frequency_counter.append(j)

    tags_counts = Counter(frequency_counter)
    return tags_counts
66/67: train["tags"][:5]
66/68:
frequency_counter = []

for i in train["tags"]:
    print(i) # reveals tags for a single question
    for j in i:
        print(j) # As there are more than one tag for a question, this loop gets the tags from questions that have multiple tags
        frequency_counter.append(j)

tags_counts = Counter(frequency_counter)
66/69:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
66/70:
most_common_words
WORDS_TO_INDEX
66/71:
X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
66/72: most_common_words
66/73:
from collections import Counter

tags_counts = tag_counts_func(train["tags"])
66/74: words_counts = words_counts_func(X_train)
66/75:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
66/76: most_common_words
66/77:
X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
66/78:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
66/79:
def test_my_bag_of_words():
    words_to_index = {'hi': 0, 'you': 1, 'me': 2, 'are': 3}
    examples = ['hi how are you']
    answers = [[1, 1, 0, 1]]
    for ex, ans in zip(examples, answers):
        if (my_bag_of_words(ex, words_to_index, 4) != ans).any():
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
66/80: print(test_my_bag_of_words())
66/81: row = X_train_mybag[10].toarray()[0]
66/82:
row = X_train_mybag[10].toarray()[0]
row
66/83:
row = X_train_mybag[10].toarray()[0]
np.nonzero(row)
66/84:
row = X_train_mybag[10].toarray()[0]
np.nonzero(len(row))
66/85:
row = X_train_mybag[10].toarray()[0]
np.nonzero(row)
66/86:
row = X_train_mybag[10].toarray()[0]
np.count_nonzero(row)
66/87:
row = X_train_mybag[10].toarray()[0]
non_zero_elements_count = np.count_nonzero(row)

grader.submit_tag('BagOfWords', str(non_zero_elements_count))
66/88:
def my_bag_of_words(text, words_to_index, dict_size):
    
    first_x_word = sorted(words_to_index.items(), key=lambda x: x[1], reverse=True)[:dict_size]
        
    bag_vector = np.zeros(len(first_x_word))    
    for sentence in text.split():
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
66/89:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(text, words_counts, 5000)) for text in X_train])
X_test_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(text, words_counts, 5000)) for text in X_test])
X_val_mybag = sp_sparse.vstack(
    [sp_sparse.csr_matrix(my_bag_of_words(text, words_counts, 5000)) for text in X_val])
66/90:
def my_bag_of_words_wrong_2(text, words_to_index, dict_size):
    
    first_x_word = sorted(words_to_index.items(), key=lambda x: x[1], reverse=True)[:dict_size]
        
    bag_vector = np.zeros(len(first_x_word))    
    for sentence in text.split():
        for word in sentence:
            for i,w in enumerate(first_x_word):
                if w[0] == word:
                    bag_vector[i] += 1
                
    return bag_vector
66/91:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
66/92:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
66/93:
def test_my_bag_of_words():
    words_to_index = {'hi': 0, 'you': 1, 'me': 2, 'are': 3}
    examples = ['hi how are you']
    answers = [[1, 1, 0, 1]]
    for ex, ans in zip(examples, answers):
        if (my_bag_of_words(ex, words_to_index, 4) != ans).any():
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
66/94: print(test_my_bag_of_words())
66/95:
row = X_train_mybag[10].toarray()[0]
non_zero_elements_count = np.count_nonzero(row)

grader.submit_tag('BagOfWords', str(non_zero_elements_count))
66/96: from sklearn.feature_extraction.text import TfidfVectorizer
66/97:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer()
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train, min_df = 5, max_df = 90.0, ngram_range = (1,2))
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test, min_df = 5, max_df = 90.0, ngram_range = (1,2))
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val, min_df = 5, max_df = 90.0, ngram_range = (1,2))

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/98:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/99:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2))
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/100:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/101: tfidf_reversed_vocab
66/102: tfidf_reversed_vocab.value()
66/103: tfidf_reversed_vocab.values()
66/104: "c++" in tfidf_reversed_vocab.values()
66/105:
print("c++" in tfidf_reversed_vocab.values(),
     "c#" in tfidf_reversed_vocab.values())
66/106:
print("c++" in tfidf_reversed_vocab.values(),
     ""\n" "c#" in tfidf_reversed_vocab.values())
66/107:
print("c++" in tfidf_reversed_vocab.values(),
     "\n" "c#" in tfidf_reversed_vocab.values())
66/108:
print("c++" in tfidf_reversed_vocab.values(),
     \n "c#" in tfidf_reversed_vocab.values())
66/109:
print("c++" in tfidf_reversed_vocab.values(),
     \n, "c#" in tfidf_reversed_vocab.values())
66/110:
print("c++" in tfidf_reversed_vocab.values(),
     "\n", "c#" in tfidf_reversed_vocab.values())
66/111:
print("c++" in tfidf_reversed_vocab.values(),
     "\n","c#" in tfidf_reversed_vocab.values())
66/112: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/113: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/114: print(" " + "c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/115: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/116:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2), token_pattern = "\S+")
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/117:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/118: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/119: ######### YOUR CODE HERE #############
66/120: ######### YOUR CODE HERE #############
66/121:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2))
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/122:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2))
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/123:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2))
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/124:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2))
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/125:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/126: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/127:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2), token_patter = "\S+")
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/128:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/129:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2), token_pattern = "\S+")
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/130:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/131: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/132: print("c++" in tfidf_reversed_vocab.values(),"\n" "c#" in tfidf_reversed_vocab.values())
66/133: print("c++" in tfidf_reversed_vocab.values(),"\n" + "c#" in tfidf_reversed_vocab.values())
66/134: print("c++" in tfidf_reversed_vocab.values(),"\n""c#" in tfidf_reversed_vocab.values())
66/135: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/136: tags_counts
66/137: from sklearn.preprocessing import MultiLabelBinarizer
66/138:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/139:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/140:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression()).fit(X_train, y_train)
    return OVR
66/141:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/142:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
66/143:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/144: X_train_tfidf
66/145:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2), token_pattern = "\S+")
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/146:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/147: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/148: X_train_tfidf
66/149: from sklearn.preprocessing import MultiLabelBinarizer
66/150:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/151:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/152:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
66/153:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/154:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/155: classifier_mybag
66/156: classifier_mybag.predict(X_val_mybag)
66/157:
classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)
66/158:
classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)
y_val_predicted_scores_mybag
66/159: y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
66/160: tfidf_reversed_vocab
66/161: X_val_mybag
66/162: X_val_tfidf
66/163:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    tfidf_vectorizer = TfidfVectorizer(min_df=5, max_df=0.9, ngram_range=(1, 2),
                                       token_pattern='(\S+)')  
    X_train=tfidf_vectorizer.fit_transform(X_train)
    X_val=tfidf_vectorizer.transform(X_val)
    X_test=tfidf_vectorizer.transform(X_test)
                                       
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/164:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/165: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/166: tfidf_vocab['c++']
66/167: tfidf_reversed_vocab[1976]
66/168: classifier_tfidf
66/169: classifier_tfidf.predict(X_val_tfidf)
66/170:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/171:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2))
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/172:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/173: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/174:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2), token_pattern = "\S+")
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/175:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/176: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/177: from sklearn.preprocessing import MultiLabelBinarizer
66/178:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/179:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/180:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
66/181:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/182: classifier_tfidf
66/183:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/184: classifier_tfidf.predict(X_val_tfidf)
66/185: X_val_tfidf
66/186:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 90.0, ngram_range = (1,2), token_pattern = "\S+")
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/187:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/188: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/189: from sklearn.preprocessing import MultiLabelBinarizer
66/190:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/191:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/192: y_train
66/193:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/194:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
66/195:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/196:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/197:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2))
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/198:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/199: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/200:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2), token_pattern = "\S+")
    X_train_tfidf = tfidf_vectorizer.fit_transform(X_train)
    X_test_tfidf = tfidf_vectorizer.fit_transform(X_test)
    X_val_tfidf = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/201:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/202: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/203: from sklearn.preprocessing import MultiLabelBinarizer
66/204:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/205:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/206:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
66/207:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/208:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/209:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2),
                                       token_pattern = "(\S+)")
    X_train = tfidf_vectorizer.fit_transform(X_train)
    X_test = tfidf_vectorizer.fit_transform(X_test)
    X_val = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/210:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2),
                                       token_pattern = "(\S+)")
    X_train = tfidf_vectorizer.fit_transform(X_train)
    X_test = tfidf_vectorizer.fit_transform(X_test)
    X_val = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/211:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/212: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/213: X_train_tfidf
66/214: from sklearn.preprocessing import MultiLabelBinarizer
66/215:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/216:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/217:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
66/218:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/219:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/220:
y_val_pred_inversed = mlb.inverse_transform(y_val_predicted_labels_tfidf)
y_val_inversed = mlb.inverse_transform(y_val)
for i in range(3):
    print('Title:\t{}\nTrue labels:\t{}\nPredicted labels:\t{}\n\n'.format(
        X_val[i],
        ','.join(y_val_inversed[i]),
        ','.join(y_val_pred_inversed[i])
    ))
66/221: y_val_predicted_labels_tfidf
66/222: mlb.inverse_transform(y_val_predicted_labels_tfidf)
66/223:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2))
    X_train = tfidf_vectorizer.fit_transform(X_train)
    X_test = tfidf_vectorizer.fit_transform(X_test)
    X_val = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/224:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/225: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/226:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2),
                                       token_pattern = "(\S+)")
    X_train = tfidf_vectorizer.fit_transform(X_train)
    X_test = tfidf_vectorizer.fit_transform(X_test)
    X_val = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/227:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/228: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/229: from sklearn.preprocessing import MultiLabelBinarizer
66/230:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/231:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/232:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/233:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
66/234:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/235:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/236:
y_val_pred_inversed = mlb.inverse_transform(y_val_predicted_labels_tfidf)
y_val_inversed = mlb.inverse_transform(y_val)
for i in range(3):
    print('Title:\t{}\nTrue labels:\t{}\nPredicted labels:\t{}\n\n'.format(
        X_val[i],
        ','.join(y_val_inversed[i]),
        ','.join(y_val_pred_inversed[i])
    ))
66/237: y_val_predicted_labels_mybag
66/238: np.count_nonzero(y_val_predicted_labels_mybag[0])
66/239: np.count_nonzero(y_val_predicted_labels_mybag[2])
66/240: np.count_nonzero(y_val_predicted_labels_mybag[500])
66/241: from sklearn.feature_extraction.text import TfidfVectorizer
66/242:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2))
    X_train = tfidf_vectorizer.fit_transform(X_train)
    X_test = tfidf_vectorizer.fit_transform(X_test)
    X_val = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/243:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/244: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/245:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    tfidf_vectorizer = TfidfVectorizer(min_df=5, max_df=0.9, ngram_range=(1, 2),
                                       token_pattern='(\S+)')  
    X_train=tfidf_vectorizer.fit_transform(X_train)
    X_val=tfidf_vectorizer.transform(X_val)
    X_test=tfidf_vectorizer.transform(X_test)
                                       
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/246:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/247: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/248: X_train_tfidf
66/249: np.count_nonzero(X_train_tfidf)
66/250: np.count_nonzero(X_train_tfidf[0])
66/251: from sklearn.preprocessing import MultiLabelBinarizer
66/252:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/253: np.count_nonzero(y_train[0])
66/254: np.count_nonzero(y_train[1~])
66/255: np.count_nonzero(y_train[1])
66/256: np.count_nonzero(y_train[2])
66/257: tags_counts
66/258: mlb
66/259: mlb.shape[:]
66/260: mlb.shape[]
66/261: mlb.shape()
66/262: mlb
66/263: type(mlb)
66/264:
for i in mlb:
    print(i)
66/265: mlb
66/266:
from collections import defaultdict
# Dictionary of all tags from train corpus with their counts.
tags_counts =  defaultdict(int)
# Dictionary of all words from train corpus with their counts.
words_counts =  defaultdict(int)
66/267:
for text in X_train:
    for word in text.split():
        words_counts[word] += 1


for tags in y_train:
    for tag in tags:
        tags_counts[tag] += 1
66/268:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
66/269: tags_counts
66/270:
from collections import Counter

tags_counts = tag_counts_func(train["tags"])
66/271: words_counts = words_counts_func(X_train)
66/272:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
66/273:
from collections import defaultdict
# Dictionary of all tags from train corpus with their counts.
tags_counts =  defaultdict(int)
# Dictionary of all words from train corpus with their counts.
words_counts =  defaultdict(int)
66/274: words_counts
66/275:

for text in X_train:
    for word in text.split():
        words_counts[word] += 1


for tags in y_train:
    for tag in tags:
        tags_counts[tag] += 1
66/276: tags_counts
66/277: words_counts
66/278: y_train
66/279:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
66/280: from grader import Grader
66/281: grader = Grader()
66/282:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
66/283:
from ast import literal_eval
import pandas as pd
import numpy as np
66/284:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
66/285:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
66/286: train.head()
66/287:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
66/288: X_train.shape[:]
66/289: X_train[0]
66/290: import re
66/291:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
66/292:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text
66/293: etc = r"A[ny te\xt CAN b`e this t]o the way"
66/294:
etc = etc.lower()
etc
66/295:
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc
66/296:
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc
66/297:
etc = etc.split();
etc
66/298:
etc = [word for word in etc if word not in STOPWORDS]
etc
66/299:
etc = " ".join(i for i in etc)
etc
66/300:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
66/301: print(test_text_prepare())
66/302:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
66/303:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
66/304: X_train[:5]
66/305:
from collections import defaultdict
# Dictionary of all tags from train corpus with their counts.
tags_counts =  defaultdict(int)
# Dictionary of all words from train corpus with their counts.
words_counts =  defaultdict(int)
66/306:
for text in X_train:
    for word in text.split():
        words_counts[word] += 1


for tags in y_train:
    for tag in tags:
        tags_counts[tag] += 1
66/307: words_counts
66/308: tags_counts
66/309:
most_common_tags = sorted(tags_counts.items(), key=lambda x: x[1], reverse=True)[:3]
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:3]

grader.submit_tag('WordsTagsCount', '%s\n%s' % (','.join(tag for tag, _ in most_common_tags), 
                                                ','.join(word for word, _ in most_common_words)))
66/310: tags_counts
66/311:
# Install a pip package in the current Jupyter kernel
#import sys
#!{sys.executable} -m pip install pixiedust
66/312: import pixiedust
66/313:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()

def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
66/314:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
66/315:
def test_my_bag_of_words():
    words_to_index = {'hi': 0, 'you': 1, 'me': 2, 'are': 3}
    examples = ['hi how are you']
    answers = [[1, 1, 0, 1]]
    for ex, ans in zip(examples, answers):
        if (my_bag_of_words(ex, words_to_index, 4) != ans).any():
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
66/316: print(test_my_bag_of_words())
66/317:
row = X_train_mybag[10].toarray()[0]
non_zero_elements_count = np.count_nonzero(row)

grader.submit_tag('BagOfWords', str(non_zero_elements_count))
66/318: from sklearn.feature_extraction.text import TfidfVectorizer
66/319:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2))
    X_train = tfidf_vectorizer.fit_transform(X_train)
    X_test = tfidf_vectorizer.fit_transform(X_test)
    X_val = tfidf_vectorizer.fit_transform(X_val)

    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/320:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/321: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/322:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    tfidf_vectorizer = TfidfVectorizer(min_df=5, max_df=0.9, ngram_range=(1, 2),
                                       token_pattern='(\S+)')  
    X_train=tfidf_vectorizer.fit_transform(X_train)
    X_val=tfidf_vectorizer.transform(X_val)
    X_test=tfidf_vectorizer.transform(X_test)
                                       
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
66/323:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
66/324: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
66/325: from sklearn.preprocessing import MultiLabelBinarizer
66/326:
mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
y_train = mlb.fit_transform(y_train)
y_val = mlb.fit_transform(y_val)
66/327: np.count_nonzero(y_train[2])
66/328: np.count_nonzero(y_train[2])
66/329: mlb
66/330:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier
66/331:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
66/332:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/333:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/334:
y_val_pred_inversed = mlb.inverse_transform(y_val_predicted_labels_tfidf)
y_val_inversed = mlb.inverse_transform(y_val)
for i in range(3):
    print('Title:\t{}\nTrue labels:\t{}\nPredicted labels:\t{}\n\n'.format(
        X_val[i],
        ','.join(y_val_inversed[i]),
        ','.join(y_val_pred_inversed[i])
    ))
66/335: mlb.inverse_transform(y_val_predicted_labels_tfidf)
66/336: mlb.inverse_transform(y_val_predicted_labels_tfidf)
66/337:
from sklearn.metrics import accuracy_score
from sklearn.metrics import f1_score
from sklearn.metrics import roc_auc_score 
from sklearn.metrics import average_precision_score
from sklearn.metrics import recall_score
66/338:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted)
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return accuracy, f1, roc, roc_precision
66/339:
print('Bag-of-words')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('Tfidf')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/340:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return accuracy, f1, roc, roc_precision
66/341:
print('Bag-of-words')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('Tfidf')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/342:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print(accuracy, f1, roc, roc_precision)
66/343:
print('Bag-of-words')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('Tfidf')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/344:
from metrics import roc_auc
%matplotlib inline
66/345:
n_classes = len(tags_counts)
roc_auc(y_val, y_val_predicted_scores_mybag, n_classes)
66/346:
n_classes = len(tags_counts)
roc_auc(y_val, y_val_predicted_scores_tfidf, n_classes)
66/347:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("accuracy: {}".format(accuracy),
                 "\nF1: {}".format(f1),
                 "\nAUC: {}".format(roc),
                 "\nAUC precision: {}".format(roc_precision))
66/348:
print('Bag-of-words')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('Tfidf')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/349:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("accuracy:\t {}".format(accuracy),
                 "\nF1:\t {}".format(f1),
                 "\nAUC:\t {}".format(roc),
                 "\nAUC precision:\t {}".format(roc_precision))
66/350:
print('Bag-of-words')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('Tfidf')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/351:
print('\nBag-of-words')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/352:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("accuracy:\t {}".format(round(accuracy,3),
                 "\nF1:\t {}".format(f1),
                 "\nAUC:\t {}".format(roc),
                 "\nAUC precision:\t {}".format(roc_precision))
66/353:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("accuracy:\t {}".format(round(accuracy,3)),
                 "\nF1:\t {}".format(f1),
                 "\nAUC:\t {}".format(roc),
                 "\nAUC precision:\t {}".format(roc_precision))
66/354:
print('\nBag-of-words')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/355:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("accuracy:\t {}".format(round(accuracy,3)),
                 "\nF1:\t {}".format(round(f1,3)),
                 "\nAUC:\t {}".format(round(roc,3)),
                 "\nAUC precision:\t {}".format(roc_precision))
66/356:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("accuracy:\t {}".format(round(accuracy,3)),
                 "\nF1:\t {}".format(round(f1,3)),
                 "\nAUC:\t {}".format(round(roc,3)),
                 "\nAUC precision:\t {}".format(round(roc_precision,3))
66/357:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("accuracy:\t {}".format(round(accuracy,3)),
                 "\nF1:\t {}".format(round(f1,3)),
                 "\nAUC:\t {}".format(round(roc,3)),
                 "\nAUC precision:\t {}".format(round(roc_precision,3)))
66/358:
print('\nBag-of-words')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/359:
print('Bag-of-words\n')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf\n')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/360:
def print_evaluation_scores(y_val, predicted):

    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("\taccuracy: {}".format(round(accuracy,3)),
                 "\n\tF1: {}".format(round(f1,3)),
                 "\n\tAUC: {}".format(round(roc,3)),
                 "\n\tAUC precision: {}".format(round(roc_precision,3)))
66/361:
print('Bag-of-words\n')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf\n')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/362:
from metrics import roc_auc
%matplotlib inline
66/363:
n_classes = len(tags_counts)n_classes
roc_auc(y_val, y_val_predicted_scores_mybag, )
66/364:
n_classes = len(tags_counts)
roc_auc(y_val, y_val_predicted_scores_tfidf, n_classes)
66/365:
n_classes = len(tags_counts)n_classes)
roc_auc(y_val, y_val_predicted_scores_mybag, )
66/366:
n_classes = len(tags_counts)n_classes,
roc_auc(y_val, y_val_predicted_scores_mybag, )
66/367:
n_classes = len(tags_counts)
roc_auc(y_val, y_val_predicted_scores_mybag, n_classes)
66/368:
n_classes = len(tags_counts)
roc_auc(y_val, y_val_predicted_scores_tfidf, n_classes)
66/369:
def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression(penalty = "l1"))
    OVR.fit(X_train, y_train)
    return OVR
66/370:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
66/371:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/372:
print('Bag-of-words\n')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf\n')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/373:
def train_classifier(X_train, y_train, penalty):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression(penalty =penalty))
    OVR.fit(X_train, y_train)
    return OVR
66/374:
classifier_mybag = train_classifier(X_train_mybag, y_train,"l2")
classifier_tfidf = train_classifier(X_train_tfidf, y_train, "l2")
66/375:
def train_classifier(X_train, y_train, penalty, solver = "newton-cg"):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression(penalty = penalty, solver = solver))
    OVR.fit(X_train, y_train)
    return OVR
66/376:
classifier_mybag = train_classifier(X_train_mybag, y_train,"l2")
classifier_tfidf = train_classifier(X_train_tfidf, y_train, "l2")
66/377:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/378:
print('Bag-of-words\n')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf\n')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/379:
classifier_mybag = train_classifier(X_train_mybag, y_train,"l1")
classifier_tfidf = train_classifier(X_train_tfidf, y_train,"l1")
66/380:
def train_classifier(X_train, y_train, penalty, solver = "newton-cg"):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression(penalty = penalty, solver = solver))
    OVR.fit(X_train, y_train)
    return OVR
66/381:
classifier_mybag = train_classifier(X_train_mybag, y_train,"l1")
classifier_tfidf = train_classifier(X_train_tfidf, y_train,"l1")
66/382:
def train_classifier(X_train, y_train, penalty):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression(penalty = penalty))
    OVR.fit(X_train, y_train)
    return OVR
66/383:
classifier_mybag = train_classifier(X_train_mybag, y_train,"l1")
classifier_tfidf = train_classifier(X_train_tfidf, y_train,"l1")
66/384:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
66/385:
print('Bag-of-words\n')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf\n')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
66/386:
test_predictions = classifier_mybag.predict(X_test_mybag)
test_pred_inversed = mlb.inverse_transform(test_predictions)

test_predictions_for_submission = '\n'.join('%i\t%s' % (i, ','.join(row)) for i, row in enumerate(test_pred_inversed))
grader.submit_tag('MultilabelClassification', test_predictions_for_submission)
66/387: X_test
66/388:
 Install a pip package in the current Jupyter kernel
import sys
!{sys.executable} -m pip install pixiedust
66/389:
 Install pip package in the current Jupyter kernel
import sys
!{sys.executable} -m pip install pixiedust
66/390:
# Install a pip package in the current Jupyter kernel
import sys
!{sys.executable} -m pip install pixiedust
67/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()

from grader import Grader
grader = Grader()


import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords

from ast import literal_eval
import pandas as pd
import numpy as np
67/2:
import sys
!{sys.executable} -m pip install pixiedust
67/3:
import sys
!{sys.executable} -m pip install grader
68/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()

from grader import Grader
grader = Grader()


import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords

from ast import literal_eval
import pandas as pd
import numpy as np
68/2:
import sys
!{sys.executable} -m pip install grader
68/3:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()

from grader import Grader
grader = Grader()
69/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()

#from grader import Grader
#grader = Grader()


import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords

from ast import literal_eval
import pandas as pd
import numpy as np
69/2:
def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data
69/3:
train = read_data('data/train.tsv')
validation = read_data('data/validation.tsv')
test = pd.read_csv('data/test.tsv', sep='\t')
69/4:
train = read_data('train.tsv')
validation = read_data('validation.tsv')
test = pd.read_csv('test.tsv', sep='\t')
69/5:
X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values
69/6:
X_train.shape[:]
X_train[0]
69/7: X_train.shape[:]
69/8: X_train[0]
69/9:
REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
69/10:
import re

REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
69/11: etc = r"A[ny te\xt CAN b`e this t]o the way"
69/12: etc = r"A[ny te\xt CAN b`e this t]o the way"
69/13: etc = etc.lower()
69/14: etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
69/15: etc = re.sub(BAD_SYMBOLS_RE,"",etc)
69/16: etc = etc.split();
69/17: etc = [word for word in etc if word not in STOPWORDS]
69/18: etc = etc.split();
69/19:
etc = r"A[ny te\xt CAN b`e this t]o the way"
etc = etc.lower()
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc = etc.split();
69/20: etc_d = [word for word in etc if word not in STOPWORDS]
69/21: etc = [word for word in etc if word not in STOPWORDS]
69/22: etc = " ".join(i for i in etc)
69/23:
def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
69/24:
prepared_questions = []
for line in open('text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)

text_prepare_results = '\n'.join(prepared_questions)
69/25:
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)

text_prepare_results = '\n'.join(prepared_questions)
69/26: prepared_questions = []
69/27:
for line in open('text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)

text_prepare_results = '\n'.join(prepared_questions)
69/28:
prepared_questions = []
for line in open('text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
69/29:
from grader import Grader
grader = Grader()
69/30:
import sys
!{sys.executable} -m pip install Grader
69/31:
import sys
!{sys.executable} -m pip install grader
69/32:
from grader import Grader
grader = Grader()
66/391:
prepared_questions = []
for line in open('data/text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
text_prepare_results = '\n'.join(prepared_questions)

grader.submit_tag('TextPrepare', text_prepare_results)
66/392: text_prepare_results
66/393: text_prepare_results.split(""\n")
66/394: text_prepare_results.split("\n")
70/1:
import sys
sys.path.append("..")
from common.download_utils import download_week1_resources

download_week1_resources()
70/2:
from grader import Grader
grader = Grader()
70/3:
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords

from ast import literal_eval
70/4:
import pandas as pd
import numpy as np

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data('train.tsv')
validation = read_data('validation.tsv')
test = pd.read_csv('test.tsv', sep='\t')


X_train, y_train = train['title'].values, train['tags'].values
X_val, y_val = validation['title'].values, validation['tags'].values
X_test = test['title'].values

X_train.shape[:]
X_train[0]


import re

REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
70/5: train = read_data('data\train.tsv')
70/6:
train = read_data('train.tsv')
validation = read_data('validation.tsv')
test = pd.read_csv('test.tsv', sep='\t')
70/7: path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\"
70/8: path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"
70/9: train = read_data(path + "train.tsv")
70/10:
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')
70/11: X_train, y_train = train['title'].values, train['tags'].values
70/12: X_val, y_val = validation['title'].values, validation['tags'].values
70/13: X_test = test['title'].values
70/14: X_train.shape[:]
70/15: X_train[0]
70/16:
import re

REPLACE_BY_SPACE_RE = re.compile('[/(){}\[\]\|@,;]')
BAD_SYMBOLS_RE = re.compile('[^0-9a-z #+_]')
STOPWORDS = set(stopwords.words('english'))
70/17:
def text_prepare(text):
    """
        text: a string
        
        return: modified initial string
    """
    text = text.lower()
    text = re.sub(REPLACE_BY_SPACE_RE," ",text)
    text = re.sub(BAD_SYMBOLS_RE,"",text)
    text = text.split()
    text = [word for word in text if word not in STOPWORDS]
    text = " ".join(i for i in text)
    return text


#================= Testing the text_prepare function ==========================

etc = r"A[ny te\xt CAN b`e this t]o the way"
etc = etc.lower()
etc = re.sub(REPLACE_BY_SPACE_RE," ",etc)
etc = re.sub(BAD_SYMBOLS_RE,"",etc)
etc = etc.split();
etc = [word for word in etc if word not in STOPWORDS]
etc = " ".join(i for i in etc)

#==============================================================================

def test_text_prepare():
    examples = ["SQL Server - any equivalent of Excel's CHOOSE function?",
                "How to free c++ memory vector<int> * arr?"]
    answers = ["sql server equivalent excels choose function", 
               "free c++ memory vectorint arr"]
    for ex, ans in zip(examples, answers):
        if text_prepare(ex) != ans:
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
70/18:
prepared_questions = []
for line in open('text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
70/19:
prepared_questions = []
for line in open(path + 'text_prepare_tests.tsv', encoding='utf-8'):
    line = text_prepare(line.strip())
    prepared_questions.append(line)
70/20: text_prepare_results = '\n'.join(prepared_questions)
70/21: grader.submit_tag('TextPrepare', text_prepare_results)
70/22:
from grader import Grader
grader = Grader()
70/23:
X_train = [text_prepare(x) for x in X_train]
X_val = [text_prepare(x) for x in X_val]
X_test = [text_prepare(x) for x in X_test]
70/24:
tags_counts = {}
# Dictionary of all words from train corpus with their counts.
words_counts = {}
70/25:
def words_counts_func(text):
    
    j = []
    test_list = []
    
    for i in text:
        j.append(i.split(" "))
    
    for k in j:
        for l in k:
            test_list.append(l)
    
    
    from collections import Counter
    
    words_counts = Counter(test_list)
    return words_counts


#******************************************************************************

def tag_counts_func(text):
    
    frequency_counter = []
    
    for i in text:
        for j in i:
            frequency_counter.append(j)
    
    tags_counts = Counter(frequency_counter)
    return tags_counts
70/26: from collections import Counter
70/27: tags_counts = tag_counts_func(train["tags"])
70/28: words_counts = words_counts_func(X_train)
70/29:
from collections import defaultdict
# Dictionary of all tags from train corpus with their counts.
tags_counts_a =  defaultdict(int)
# Dictionary of all words from train corpus with their counts.
words_counts_a =  defaultdict(int)

for text in X_train:
    for word in text.split():
        words_counts_a[word] += 1



for tags in y_train:
    for tag in tags:
        tags_counts_a[tag] += 1
70/30: most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
70/31: WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
70/32: DICT_SIZE = 5000
70/33: WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
70/34: WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
70/35: INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
70/36: ALL_WORDS = WORDS_TO_INDEX.keys()
70/37:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])} ####### YOUR CODE HERE #######
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}####### YOUR CODE HERE #######
ALL_WORDS = WORDS_TO_INDEX.keys()
70/38: most_common_words
70/39: WORDS_TO_INDEX
70/40: ALL_WORDS
70/41:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
first_5000_word
70/42:
for i,w in enumerate(first_5000_word):
    print(i,w)
70/43: ALL_WORDS
70/44:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
70/45:
def my_bag_of_words(text, words_to_index, dict_size):
    """
        text: a string
        dict_size: size of the dictionary
        
        return a vector which is a bag-of-words representation of 'text'
    """
    
    result_vector = np.zeros(dict_size)
    for word in text.split():
        if word in words_to_index:
            result_vector[words_to_index[word]] += 1
    
    return result_vector
70/46:
from scipy import sparse as sp_sparse

X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(text, WORDS_TO_INDEX, DICT_SIZE)) for text in X_test])
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
70/47: most_common_words[0]
70/48: most_common_words[0]:1
70/49: most_common_words[0]
70/50: a = most_common_words[0]:1
70/51: WORDS_TO_INDEX
70/52: INDEX_TO_WORDS
70/53:
print('X_train shape ', X_train_mybag.shape)
print('X_val shape ', X_val_mybag.shape)
print('X_test shape ', X_test_mybag.shape)
70/54:
def test_my_bag_of_words():
    words_to_index = {'hi': 0, 'you': 1, 'me': 2, 'are': 3}
    examples = ['hi how are you']
    answers = [[1, 1, 0, 1]]
    for ex, ans in zip(examples, answers):
        if (my_bag_of_words(ex, words_to_index, 4) != ans).any():
            return "Wrong answer for the case: '%s'" % ex
    return 'Basic tests are passed.'
70/55: print(test_my_bag_of_words())
70/56: WORDS_TO_INDEX
70/57: first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
66/395:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j)
66/396:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j.key())
66/397:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j.keys())
66/398:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0]])
66/399:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0])
66/400:
first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0])
    j[0]:i
66/401:
empty_dictionary = {}

first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0])
    j[0]:i
66/402:
empty_dictionary = {}

first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0])
    empty_dictionary[j[0]] = empty_dictionary[i]
66/403:
empty_dictionary = {}

first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0])
    #mpty_dictionary[j[0]] = empty_dictionary[i]
66/404:
empty_dictionary = {}

first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0])
    empty_dictionary[j[0]] = empty_dictionary[i]
66/405:
empty_dictionary = {}

first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0])
    empty_dictionary[j[0]] = i
66/406:
empty_dictionary = {}

first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    print(i,j[0])
    empty_dictionary[j[0]] = i
    
empty_dictionary
66/407:
empty_dictionary = {}

first_5000_word = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:5000]
for i,j in enumerate(first_5000_word):
    #print(i,j[0])
    empty_dictionary[j[0]] = i
    
empty_dictionary
70/58:
from sklearn.feature_extraction.text import TfidfVectorizer

def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    # Create TF-IDF vectorizer with a proper parameters choice
    # Fit the vectorizer on the train set
    # Transform the train, test, and val sets and return the result
    
    
    tfidf_vectorizer = TfidfVectorizer(min_df = 5, max_df = 0.9, ngram_range = (1,2))
    X_train = tfidf_vectorizer.fit_transform(X_train)
    X_test = tfidf_vectorizer.fit_transform(X_test)
    X_val = tfidf_vectorizer.fit_transform(X_val)
    
    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_
70/59:
X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}
70/60: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())a
70/61: print("c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
70/62: print("c++" in tfidf_reversed_vocab.values(),"\nc#" in tfidf_reversed_vocab.values())
70/63: print("c++" in tfidf_reversed_vocab.values(),"\\nc#" in tfidf_reversed_vocab.values())
70/64: print("c++" in tfidf_reversed_vocab.values(),"\n\nc#" in tfidf_reversed_vocab.values())
70/65: print("\nc++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
70/66: print("\n","c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
70/67:
def tfidf_features(X_train, X_val, X_test):
    """
        X_train, X_val, X_test — samples        
        return TF-IDF vectorized representation of each sample and vocabulary
    """
    tfidf_vectorizer = TfidfVectorizer(min_df=5, max_df=0.9, ngram_range=(1, 2),
                                       token_pattern='(\S+)')  
    X_train=tfidf_vectorizer.fit_transform(X_train)
    X_val=tfidf_vectorizer.transform(X_val)
    X_test=tfidf_vectorizer.transform(X_test)
    
    return X_train, X_val, X_test, tfidf_vectorizer.vocabulary_


X_train_tfidf, X_val_tfidf, X_test_tfidf, tfidf_vocab = tfidf_features(X_train, X_val, X_test)
tfidf_reversed_vocab = {i:word for word,i in tfidf_vocab.items()}

print("\n","c++" in tfidf_reversed_vocab.values(),"\n","c#" in tfidf_reversed_vocab.values())
70/68: from sklearn.preprocessing import MultiLabelBinarizer
70/69: mlb = MultiLabelBinarizer(classes=sorted(tags_counts.keys()))
70/70: mlb
70/71: y_train = mlb.fit_transform(y_train)
70/72: y_val = mlb.fit_transform(y_val)
70/73:
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LogisticRegression, RidgeClassifier

def train_classifier(X_train, y_train):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression())
    OVR.fit(X_train, y_train)
    return OVR
70/74:
classifier_mybag = train_classifier(X_train_mybag, y_train)
classifier_tfidf = train_classifier(X_train_tfidf, y_train)
70/75: from numbapro import vectorize
70/76:
y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)
70/77: y_val_pred_inversed = mlb.inverse_transform(y_val_predicted_labels_tfidf)
70/78: y_val_inversed = mlb.inverse_transform(y_val)
70/79:
for i in range(3):
    print('Title:\t{}\nTrue labels:\t{}\nPredicted labels:\t{}\n\n'.format(
        X_val[i],
        ','.join(y_val_inversed[i]),
        ','.join(y_val_pred_inversed[i])
    ))
70/80:
from sklearn.metrics import accuracy_score
from sklearn.metrics import f1_score
from sklearn.metrics import roc_auc_score 
from sklearn.metrics import average_precision_score
from sklearn.metrics import recall_score
70/81:
def print_evaluation_scores(y_val, predicted):
    
    accuracy = accuracy_score(y_val, predicted)
    f1 = f1_score(y_val, predicted, average='weighted')
    roc = roc_auc_score(y_val, predicted)
    roc_precision = average_precision_score(y_val, predicted)
    
    return print("\taccuracy: {}".format(round(accuracy,3)),
                 "\n\tF1: {}".format(round(f1,3)),
                 "\n\tAUC: {}".format(round(roc,3)),
                 "\n\tAUC precision: {}".format(round(roc_precision,3)))
70/82:
print('Bag-of-words\n')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf\n')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
70/83:
from metrics import roc_auc
%matplotlib inline
70/84:
import sys
!{sys.executable} -m pip install metrics
70/85:
from metrics import roc_auc
%matplotlib inline
70/86: from metrics import roc_auc
70/87:
def train_classifier(X_train, y_train, penalty):
    """
      X_train, y_train — training data
      
      return: trained classifier
    """
    
    # Create and fit LogisticRegression wraped into OneVsRestClassifier.
    
    OVR = OneVsRestClassifier(LogisticRegression(penalty = penalty))
    OVR.fit(X_train, y_train)
    return OVR


classifier_mybag = train_classifier(X_train_mybag, y_train,"l1")
classifier_tfidf = train_classifier(X_train_tfidf, y_train,"l1")

y_val_predicted_labels_mybag = classifier_mybag.predict(X_val_mybag)
y_val_predicted_scores_mybag = classifier_mybag.decision_function(X_val_mybag)

y_val_predicted_labels_tfidf = classifier_tfidf.predict(X_val_tfidf)
y_val_predicted_scores_tfidf = classifier_tfidf.decision_function(X_val_tfidf)

print('Bag-of-words\n')
print_evaluation_scores(y_val, y_val_predicted_labels_mybag)
print('\nTfidf\n')
print_evaluation_scores(y_val, y_val_predicted_labels_tfidf)
70/88:
test_predictions = classifier_mybag.predict(X_test_mybag)
test_pred_inversed = mlb.inverse_transform(test_predictions)

test_predictions_for_submission = '\n'.join('%i\t%s' % (i, ','.join(row)) for i, row in enumerate(test_pred_inversed))
70/89: INDEX_TO_WORDS
70/90: est.coef_.argsort().tolist()[0][:5]
70/91: est.coef_.argsort().tolist()[0][:5]
70/92: est = classifier.estimators_[tags_classes.index(tag)]
70/93: est = classifier.estimators_[tags_classes.index(tag)]
70/94:
est = classifier.estimators_[tags_classes.index(tag)]
est.coef_.argsort().tolist()[0][-5:]
70/95:
est = classifier_mybag.estimators_[tags_classes.index(tag)]
est.coef_.argsort().tolist()[0][-5:]
70/96:
est = classifier_mybag.estimators_["c".index(tag)]
est.coef_.argsort().tolist()[0][-5:]
70/97: print(OVR.coef_)
70/98: classifier_mybag.coef_
70/99: a = classifier_mybag.coef_
70/100: est = classifier_mybag.estimators_[mlb.classes.index("c")]
70/101: est
70/102: top_positive_words = [INDEX_TO_WORDS[index] for index in est.coef_.argsort().tolist()[0][-5:]]
70/103:
for index in est.coef_.argsort().tolist()[0][-5:]:
    print(index)
70/104: INDEX_TO_WORDS[3194]
70/105:
for index in est.coef_.argsort().tolist()[0][5:]:
    print(index)
70/106:
for index in est.coef_.argsort().tolist()[0][:5]:
    print(index)
70/107: INDEX_TO_WORDS[553]
71/1:
import nltk
nltk.download()
71/2: from nltk.book import *
71/3: from nltk.book import *
71/4: text1
71/5: text.concordance("monstrous")
71/6: text1.concordance("monstrous")
71/7: text2.concordance("affection")
71/8: text4.concordance("terror")
71/9: text4.dispersion_plot(["terror", "nation"])
71/10: sorted(set(text3))
71/11: sorted(set(text3))[:5]
71/12: sorted(set(text3))[:50]
72/1: import nltk
72/2: from nltk.book import *
72/3: sorted(set(text3))[:50]
72/4: sorted_first_50 = sorted(set(text3))[:50]
72/5:
from __future__ import division
len(text3) / len(set(text3))
72/6: text5.count()
72/7: text5.count("lol")/len(text5)
72/8: 100*text5.count("lol")/len(text5)
72/9: fdist1 = FreqDist(text1)
72/10: vocabulary1 = fdist1.keys()
72/11: vocabulary1[:50]
72/12: vocabulary1 = fdist1.keys()
72/13: vocabulary1[:50]
72/14: vocabulary1[:50]
72/15: fdist.keys()
72/16: fdist1.keys()
72/17: fdist1.keys()[:50]
72/18: fdist1.keys()
72/19: text4.collocations()
73/1:
import numpy as np
import pandas as pd
import re

path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"
73/2: test = pd.read_csv(path+"train.tsv")
73/3:
with open(path + "test.tsv") as tsvfile:
    print(tsvfile)
73/4: import csv
73/5:
with open(path + "test.tsv") as tsvfile:
    tsvreader = csv.reader(tsvfile)
73/6:
for i in tsvreader:
    print(i)
73/7: df = DataFrame.from_csv(path + "test.tsv")
73/8: from pandas import DataFrame
73/9: df = DataFrame.from_csv(path + "test.tsv")
73/10: df = DataFrame.from_csv(path + "test.tsv", sep = None)
73/11: df = DataFrame.from_csv(path + "test.tsv", sep = "\n")
73/12:
with open(path + "test.tsv") as tsvfile:
    lines = tsvfile.read().split('\n')
73/13: df = DataFrame.from_csv(path + "test.tsv", sep = "\t")
73/14:
def read_tsv(path):
    df = DataFrame.from_csv(path, sep = "\t")
    retun df
73/15:
def read_tsv(path):
    df = DataFrame.from_csv(path, sep = "\t")
    return df
73/16: X_test = read_tsv(path + "test.tsv")
73/17: X_train = read_tsv(path + "train.tsv")
73/18: X_val = read_tsv(path + "validation")
73/19: X_val = read_tsv(path + "validation.tsv")
73/20: Train = read_tsv(path + "train.tsv")
73/21: Train[0]
73/22: X_train = read_tsv(path + "train.tsv")
73/23:
test = read_tsv(path + "test.tsv")
train = read_tsv(path + "train.tsv")
X_val = read_tsv(path + "validation.tsv")
73/24: train.values
73/25: train.values()
73/26: from ast import literal_eval
73/27: train["tags"]
73/28: train.index
73/29: train.taghs
73/30: train.tags
73/31: train.tags.values
73/32: train.index.values
73/33: train["tag"].values
73/34: train.tag
73/35: train["tags"].values
73/36: X_train, y_train = train.index.values, train["tags"].values
73/37:
X_train, y_train = train.index.values, train["tags"].values
X_test, y_test = test.index.values, test["tags"].values
73/38: val = read_tsv(path + "validation.tsv")
73/39: X_val, y_val = va;.index.values, val["tags"].values
73/40: X_val, y_val = val.index.values, val["tags"].values
73/41: X_test = test.values
73/42: X_test = test.index.values
73/43: nltk.download('stopwords')
73/44: import nltk
73/45: nltk.download('stopwords')
73/46: stop_words = set(stopwords.words('english'))
73/47: from nltk.corpus import stopwords
73/48: stop_words = set(stopwords.words('english'))
73/49: stop_words
73/50: train.index()
73/51: train.index.values
73/52: train.index.values.lower()
73/53: train.index.lower()
73/54: train.index[0]
73/55: train.index
73/56: train.index[:]
73/57: train.index[:].lower()
73/58:
for x in X_train:
    print(x)
73/59: X_train[0]
73/60: X_train[0].lower()
73/61:
punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")
73/62:
def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = [sentence.split() for sentence in text if not sentence in stop_words]
    
    return text
73/63: a = text_prepare(X_train)
73/64:
def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = [words for words in text if not words in stop_words]
    
    return text
73/65: a = text_prepare(sentences for sentences in X_train)
73/66: a = text_prepare([sentences for sentences in X_train])
73/67: test_list = [sentences for sentences in X_train]
73/68: test_list
73/69: etc = "any/thing ca[n b.e writ+ten this way"
73/70: etc.lower()
73/71: etc = etc.lower()
73/72: etc= re.sub(punctuation_remove, " ", etc)
73/73: etc
73/74: etc = re.sub(bad_words, "", etc)
73/75: etc
73/76: etc = r"A[ny te\xt CAN b`e this t]o the way"
73/77: etc = text_prepare(etc)
73/78:
def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = [words for words in text if not words in stop_words]
    
    return text


etc = text_prepare(etc)
73/79:
def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = [words for words in text if not words in stop_words]
    
    return text
73/80:
etc = r"A[ny te\xt CAN b`e this t]o the way"
etc = text_prepare(etc)
73/81: etc = r"A[ny te\xt CAN b`e this t]o the way"
73/82:
def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = [words for words in text if not words in stop_words]
    
    return text
73/83: etc = text_prepare(etc)
73/84:
def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text
73/85: etc = r"A[ny te\xt CAN b`e this t]o the way"
73/86: etc = text_prepare(etc)
73/87: text_prepare(X_train)
73/88: text_prepare([sentencens for sentences in X_train])
73/89: text_prepare([sentences for sentences in X_train])
73/90: a = [sentences for sentences in X_train]
73/91: a = [elements for elements in sentences sentences for sentences in X_train]
73/92: a = [text_prepare(sentences) for sentences in X_train]
73/93:
X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
73/94:
for i in X_train:
    print(i)
73/95: sentences = iter(X_train)
73/96: sentences
73/97: words = list(iter(sentences))
73/98: words
73/99: words = list(iter(words))
75/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_tsv(path):
    df = DataFrame.from_csv(path, sep = "\t")
    return df


test = read_tsv(path + "test.tsv")
train = read_tsv(path + "train.tsv")
val = read_tsv(path + "validation.tsv")

X_test = test.index.values
X_train, y_train = train.index.values, train["tags"].values
X_val, y_val = val.index.values, val["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
75/2: words = list(iter(X_train))
75/3: setences = list(iter(X_train))
75/4: sentences = list(iter(X_train))
75/5: X_train_sentences = list(iter(X_train))
75/6:
word_count = []
for words in X_train_sentences:
    word_count.append(word)
75/7:
word_count = []
for words in X_train_sentences:
    word_count.append(words)
75/8:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)
75/9: words_counts_a =  defaultdict(int)
75/10: from collections import defaultdict
75/11: words_counts_a =  defaultdict(int)
75/12: from collections import Counter
75/13: Counter(word_count)
75/14: words_counts = Counter(word_count)
75/15:
i for in y_train:
    print(i)
75/16:
for i in y_train:
    print(i)
75/17:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)

tag_count = []
for tags_per_question in y_train:
    for all_tags in tags_per_question:
        tag_count.append(all_tags)


tag_counts = Counter(tag_count)
75/18:
tag_count = []
for tags in y_train:
        tag_count.append(all_tags)


tag_counts = Counter(tag_count)
75/19: tag_count = []
75/20: for tags in y_train:
75/21:
tag_count = []
for tags in y_train:
        tag_count.append(tags)
75/22: tag_counts = Counter(tag_count)
75/23:
tag_count = []
for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
75/24:
tag_count = []
for tags in y_train:
    for tag in tags:
        tag_count.append(tag)
75/25:
tag_count = []
for tags in y_train:
    tag_count.append(tags)
75/26:
for tags in y_train:
    for tag in tags:
        print(tag)
75/27:
tag_count = []
for tags in y_train:
    tag_count.append(tag)


tag_counts = Counter(tag_count)
75/28:
tag_count = []
for tags in y_train:
    tag_count.append(tags)


tag_counts = Counter(tag_count)
75/29: tag_count[1]
75/30:
for i in tag_count[1]:
    print(i)
75/31: train["tags"]
75/32:
for i in train["tags"]:
    print(i)
75/33:
for i in train["tags"]:
    for j in in:
        print(j)
75/34:
for i in train["tags"]:
    for j in i:
        print(j)
75/35: train["tags"] = train["tags"].apply(literal_eval)
75/36:
for i in train["tags"]:
    for j in i:
        print(j)
75/37:
tag_count = []
for tags in train["tags"].apply(literal_eval):
    for tag in tags:
        tag_count.append(tags)


tag_counts = Counter(tag_count)
75/38:
tag_count = []
for tags in train["tags"].apply(literal_eval):
    for tag in tags:
        tag_count.append(print(tags))


tag_counts = Counter(tag_count)
75/39:
tag_count = []
for tags in train["tags"].apply(literal_eval):
    for tag in tags:
        print(tag)
76/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_tsv(path):
    df = DataFrame.from_csv(path, sep = "\t")
    return df


test = read_tsv(path + "test.tsv")
train = read_tsv(path + "train.tsv")
val = read_tsv(path + "validation.tsv")

X_test = test.index.values
X_train, y_train = train.index.values, train["tags"].values
X_val, y_val = val.index.values, val["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
76/2:
tag_count = []
for tags in train["tags"].apply(literal_eval):
    for tag in tags:
        tag_count.append(tags)


tag_counts = Counter(tag_count)
76/3: train["tags"] = train["tags"].apply(literal_eval)
76/4:
for tags in train["tags"].apply(literal_eval):
    for tag in tags:
        print(tags)
76/5:
for tags in train["tags"]:
    for tag in tags:
        print(tags)
77/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test.index.values
X_train, y_train = train.index.values, train["tags"].values
X_val, y_val = val.index.values, val["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
78/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test.index.values
X_train, y_train = train.index.values, train["tags"].values
X_val, y_val = validation.index.values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
78/2:
def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text
79/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test.values
X_train, y_train = train.values, train["tags"].values
X_val, y_val = validation.values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
80/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test.values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].1values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
80/2:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test.values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].1values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
80/3:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test.values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
81/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
81/2:
tag_count = []

train["tags"] = train["tags"].apply(literal_eval)

for tags in train["tags"]:
    for tag in tags:
        tag_count.append(tags)
81/3:
for tags in y_train:
    for tag in tags:
        tag_count.append(tags)
81/4:
for tags in y_train:
    print(tags)
81/5:
for tags in y_train:
    for tag in tags:
        print(tag)
81/6:
tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
81/7: sorted(tag_counts)
81/8: sorted(tag_counts.values)
81/9: from collections import Counter, OrderedDict
81/10: tag_counts = OrderedDict(tag_counts.most_common())
81/11: tag_counts = sorted(tag_counts.items(), key=lambda i: i[1], reverse=True)
81/12:
tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
81/13: tag_counts = Counter(tag_count)
81/14: tag_count = []
81/15:
for tags in y_train:
    for tag in tags:
        tag_count.append(tag)
81/16: tag_counts = Counter(tag_count)
81/17: tag_counts = sorted(tag_counts.items(), key=lambda i: i[1], reverse=True)
81/18:
tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
81/19: most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
81/20: WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])}
81/21: DICT_SIZE = 5000
81/22: WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])}
81/23: WORDS_TO_INDEX
81/24: INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}
81/25: INDEX_TO_WORDS
81/26: ALL_WORDS
81/27: ALL_WORDS = WORDS_TO_INDEX.keys()
81/28: ALL_WORDS
81/29:
words_counts = Counter(word_count)
tag_counts = sorted(words_counts.items(), key=lambda i: i[1], reverse=True)
81/30:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = sorted(words_counts.items(), key=lambda i: i[1], reverse=True)


tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = sorted(tag_counts.items(), key=lambda i: i[1], reverse=True)
81/31:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = sorted(words_counts.items(), key=lambda i: i[1], reverse=True)


tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = sorted(tag_counts.items(), key=lambda i: i[1], reverse=True)
81/32: words_counts = Counter(word_count)
81/33: a = words_counts.most_common()
82/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

nltk.download('stopwords')
stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


X_train_sentences = list(iter(X_train))

word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = words_counts.most_common()


tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = tag_counts.most_common()
82/2: words_counts[0]
82/3: listed_dictionary_worsd = {}
82/4:
listed_dictionary_worsd = {}
for index, elements in enumerate(word_counts):
    listed_dictionary_worsd[elements[0]] = index
82/5:
listed_dictionary_worsd = {}
for index, elements in enumerate(words_counts):
    listed_dictionary_worsd[elements[0]] = index
83/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = words_counts.most_common()


tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = tag_counts.most_common()


listed_dictionary_words = {}
for index, elements in enumerate(words_counts):
    listed_dictionary_words[elements[0]] = index
83/2:
most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])}
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}
ALL_WORDS = WORDS_TO_INDEX.keys()
83/3: words_counts = Counter(word_count)
83/4: most_common_words = sorted(words_counts.items(), key=lambda x: x[1], reverse=True)[:6000]
83/5:
DICT_SIZE = 5000
WORDS_TO_INDEX = {p[0]:i for i,p in enumerate(most_common_words[:DICT_SIZE])}
INDEX_TO_WORDS = {WORDS_TO_INDEX[k]:k for k in WORDS_TO_INDEX}
ALL_WORDS = WORDS_TO_INDEX.keys()
83/6: ALL_WORDS
83/7: INDEX_TO_WORDS
83/8: index_to _words = inv_map = {v: k for k, v in listed_dictionary_words.items()}
83/9: index_to_words = inv_map = {v: k for k, v in listed_dictionary_words.items()}
84/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = words_counts.most_common()


tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = tag_counts.most_common()


listed_dictionary_words = {}
for index, elements in enumerate(words_counts):
    listed_dictionary_words[elements[0]] = index


index_to_words = {v: k for k, v in listed_dictionary_words.items()}
84/2:
listed_dictionary_words = {}
for index, elements in enumerate(words_counts[:5000]):
    listed_dictionary_words[elements[0]] = index


index_to_words = {v: k for k, v in listed_dictionary_words.items()}
84/3: X_test
84/4:
for words in X_test:
    print(words)
84/5:
for sentences in X_test:
    for words in sentences:
        print(words)
84/6:
for sentences in X_test:
    for words in sentences:
        if words in
84/7:
if words in listed_dictionary_words.keys():
    print(True)
84/8:
for sentences in X_test:
    for words in sentences:
        if words in listed_dictionary_words.keys():
            result_vector[listed_dictionary_words[words]]
84/9: listed_dictionary_words[words]
84/10:
for sentences in X_test:
    for words in sentences:
        if words in listed_dictionary_words.keys():
            result_vector[listed_dictionary_words[words]] =+1
84/11: len(listed_dictionary_words.keys())
84/12: result_vector = np.zeros(len(listed_dictionary_words.keys()))
84/13: result_vector
84/14:
def my_bag_of_words(sentences):
    
    result_vector = np.zeros(len(listed_dictionary_words.keys()))
    for words in sentences:
        if words in listed_dictionary_words.keys():
            result_vector[listed_dictionary_words[words]] =+1
    
    return result_vector
84/15:
def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(text)
84/16:
X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
85/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(text)
85/2:
X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
86/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(i for i in text)


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
86/2:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = words_counts.most_common()


tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = tag_counts.most_common()


listed_dictionary_words = {}
for index, elements in enumerate(words_counts[:5000]):
    listed_dictionary_words[elements[0]] = index


index_to_words = {v: k for k, v in listed_dictionary_words.items()}


def my_bag_of_words(sentences):
    
    result_vector = np.zeros(len(listed_dictionary_words.keys()))
    for words in sentences:
        if words in listed_dictionary_words.keys():
            result_vector[listed_dictionary_words[words]] =+1
    
    return result_vector
86/3: my_bag_of_words(X_train[0])
86/4: a = my_bag_of_words(X_train[0])
87/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(i for i in text)


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
88/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(i for i in text)


X_test_cleared = [text_prepare(sentences) for sentences in X_test]
X_train_cleared = [text_prepare(sentences) for sentences in X_train]
X_val_cleared = [text_prepare(sentences) for sentences in X_val]
88/2:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = words_counts.most_common()
88/3:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(i for i in text)


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
88/4:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = words_counts.most_common()
88/5:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
88/6:
tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = tag_counts.most_common()


listed_dictionary_words = {}
for index, elements in enumerate(words_counts[:5000]):
    listed_dictionary_words[elements[0]] = index


index_to_words = {v: k for k, v in listed_dictionary_words.items()}
88/7: listed_dictionary_words = {}
89/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict


path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return text


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
89/2:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
89/3: words_counts = words_counts.most_common()
89/4:
tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = tag_counts.most_common()
89/5:
listed_dictionary_words = {}
for index, elements in enumerate(words_counts[:5000]):
    listed_dictionary_words[elements[0]] = index
89/6: index_to_words = {v: k for k, v in listed_dictionary_words.items()}
89/7:
def my_bag_of_words(sentences):
    
    result_vector = np.zeros(len(listed_dictionary_words.keys()))
    for words in sentences:
        if words in listed_dictionary_words.keys():
            result_vector[listed_dictionary_words[words]] =+1
    
    return result_vector
89/8: my_bag_of_words(X_train[0])
89/9: a = my_bag_of_words(X_train[0])
89/10: my_bag_of_words(sentences) for sentences in X_train
89/11: [my_bag_of_words(sentences) for sentences in X_train]
89/12: import scipy.sparse as sps
89/13: X_train_mybag = sps.csr_matrix([my_bag_of_words(sentences) for sentences in X_train])
89/14: from scipy import sparse as sp_sparse
89/15: X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(sentences)) for sentences in X_train])
89/16: X_train_mybag
89/17: X_train_mybag.shape()
89/18: X_train_mybag.shape[]
89/19: X_train_mybag.shape[:]
89/20:
X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(sentences)) for sentences in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(sentences)) for sentences in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(sentences)) for sentences in X_test])
89/21: from sklearn.feature_extraction.text import TfidfVectorizer
89/22:
def tfidf_vectorizer(text):
    
    vectorizer = TfidfVectorizer(max_df = 0.9, min_df = 5)
    X = vectorizer.fit_transform(text)
    return X
89/23: X_train_joined = " ".join(i for i in X_train)
89/24: X_train[0]
89/25: X_train_joined = " ".join(i for j, i in enumerate(X_train[j]))
89/26:
for i in X_train:
    print(i
89/27:
for i in X_train:
    print(i)
90/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict
import scipy.sparse as sps
from scipy import sparse as sp_sparse
from sklearn.feature_extraction.text import TfidfVectorizer

path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(i for i in text)
90/2:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict
import scipy.sparse as sps
from scipy import sparse as sp_sparse
from sklearn.feature_extraction.text import TfidfVectorizer

path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(i for i in text)
90/3:
X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]
90/4:
word_count = []
for sentences in X_train:
    for words in sentences:
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = words_counts.most_common()


tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = tag_counts.most_common()
90/5:
for sentences in X_train:
    print(sentences)
90/6:
for sentences in X_train.split():
    print(sentences)
90/7:
for sentences in X_train:
    for words in sentences.split():
        print(words)
90/8:
word_count = []
for sentences in X_train:
    for words in sentences.split():
        word_count.append(words)
91/1:
import numpy as np
import pandas as pd
from pandas import DataFrame
import re
from ast import literal_eval
import nltk
from nltk.corpus import stopwords
from collections import Counter, OrderedDict
import scipy.sparse as sps
from scipy import sparse as sp_sparse
from sklearn.feature_extraction.text import TfidfVectorizer

path = r"C:\Users\Cagri\Google Drive\Self Study\Natural Language Processing - Andreas Muller\Coursera course\natural-language-processing-master\data\\"

def read_data(filename):
    data = pd.read_csv(filename, sep='\t')
    data['tags'] = data['tags'].apply(literal_eval)
    return data


train = read_data(path + "train.tsv")
validation = read_data(path + 'validation.tsv')
test = pd.read_csv(path + 'test.tsv', sep='\t')

X_test = test["title"].values
X_train, y_train = train["title"].values, train["tags"].values
X_val, y_val = validation["title"].values, validation["tags"].values

punctuation_remove = re.compile("[/(){}\[\]\|@,;]")
bad_words = re.compile("[^0-9a-z #+_]")

stop_words = set(stopwords.words('english'))

def text_prepare(text):
    
    text = text.lower()
    text = re.sub(punctuation_remove, " ", text)
    text = re.sub(bad_words, "", text)
    text = text.split()
    text = [words for words in text if not words in stop_words]
    
    return " ".join(i for i in text)


X_test = [text_prepare(sentences) for sentences in X_test]
X_train = [text_prepare(sentences) for sentences in X_train]
X_val = [text_prepare(sentences) for sentences in X_val]


word_count = []
for sentences in X_train:
    for words in sentences.split():
        word_count.append(words)


words_counts = Counter(word_count)
words_counts = words_counts.most_common()


tag_count = []

for tags in y_train:
    for tag in tags:
        tag_count.append(tag)


tag_counts = Counter(tag_count)
tag_counts = tag_counts.most_common()


listed_dictionary_words = {}
for index, elements in enumerate(words_counts[:5000]):
    listed_dictionary_words[elements[0]] = index


index_to_words = {v: k for k, v in listed_dictionary_words.items()}

def my_bag_of_words(sentences):
    
    result_vector = np.zeros(len(listed_dictionary_words.keys()))
    for words in sentences:
        if words in listed_dictionary_words.keys():
            result_vector[listed_dictionary_words[words]] =+1
    
    return result_vector


X_train_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(sentences)) for sentences in X_train])
X_val_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(sentences)) for sentences in X_val])
X_test_mybag = sp_sparse.vstack([sp_sparse.csr_matrix(my_bag_of_words(sentences)) for sentences in X_test])
91/2: tfidf_vectorizer(X_train)
91/3:
def tfidf_vectorizer(text):
    
    vectorizer = TfidfVectorizer(max_df = 0.9, min_df = 5)
    X = vectorizer.fit_transform(text)
    return X
91/4: tfidf_vectorizer(X_train)
91/5:
X_train_tfidf = tfidf_vectorizer(X_train)
X_test_tfidf = tfidf_vectorizer(X_test)
X_val_tfidf = tfidf_vectorizer(X_val)
91/6: X_train_tfidf
91/7: X_train_tfidf.vocabulary_
91/8:
X_train_tfidf, X_train_vocabulary = tfidf_vectorizer(X_train)
X_test_tfidf, X_test_vocabulary= tfidf_vectorizer(X_test)
X_val_tfidf, X_val_vocabulary= tfidf_vectorizer(X_val)
91/9:
X_train_tfidf = tfidf_vectorizer(X_train)
X_test_tfidf = tfidf_vectorizer(X_test)
X_val_tfidf = tfidf_vectorizer(X_val)
91/10: X_val_tfidf
91/11: X_val_tfidf.items()
91/12:
def tfidf_vectorizer(text):
    
    vectorizer = TfidfVectorizer(max_df = 0.9, min_df = 5)
    X = vectorizer.fit_transform(text)
    return X, vectorizer.vocabulary_
91/13: X_train_tfidf, a = tfidf_vectorizer(X_train)
91/14:
X_train_tfidf, X_train_vocabulary = tfidf_vectorizer(X_train)
X_test_tfidf, X_test_vocabulary = tfidf_vectorizer(X_test)
X_val_tfidf, X_val_vocabulary = tfidf_vectorizer(X_val)
91/15: tfidf_reversed_vocab_X_train = {i:word for word,i in X_train_vocabulary.items()}
91/16: print("c++" in X_train_vocabulary)
91/17:
def tfidf_vectorizer(text):
    
    vectorizer = TfidfVectorizer(max_df = 0.9, min_df = 5, token_pattern = "(\S+)")
    X = vectorizer.fit_transform(text)
    return X, vectorizer.vocabulary_


X_train_tfidf, X_train_vocabulary = tfidf_vectorizer(X_train)
X_test_tfidf, X_test_vocabulary = tfidf_vectorizer(X_test)
X_val_tfidf, X_val_vocabulary = tfidf_vectorizer(X_val)

print("c++" in X_train_vocabulary)
91/18:
def tfidf_vectorizer(text):
    """
    token_pattern = \S+ --> a regex that treats any one or more characters that don't contain whitespace characters as a single token.
    
    This enabled us to capture c++, c#
    """
    
    vectorizer = TfidfVectorizer(max_df = 0.9, min_df = 5, token_pattern = "(\S+)")
    X = vectorizer.fit_transform(text)
    return X, vectorizer.vocabulary_


X_train_tfidf, X_train_vocabulary = tfidf_vectorizer(X_train)
X_test_tfidf, X_test_vocabulary = tfidf_vectorizer(X_test)
X_val_tfidf, X_val_vocabulary = tfidf_vectorizer(X_val)

print("c++" in X_train_vocabulary)
91/19: from sklearn.preprocessing import MultiLabelBinarizer
91/20: mlb = MultiLabelBinarizer()
91/21: mlb.fit_transform(y_train)
91/22: y_train_mlb = mlb.fit_transform(y_train)
91/23: y_val_mlb = mlb.fit_transform(y_val)
91/24: mlb.fit_transform(y_train)
91/25: mlb.fit_transform(y_train)[0]
91/26: mlb.fit_transform(y_train)[1]
93/1: data = "GARANTİ FAKTORİNG A.Ş."
93/2: data.lower()
93/3: data.translate(str.maketrans('', '', string.punctuation))
93/4:
import string

data = "GARANTİ FAKTORİNG A.Ş."
93/5: s.translate(str.maketrans('', '', string.punctuation))
93/6: data.translate(str.maketrans('', '', string.punctuation))
93/7:
import string

data = "GARANTİ FAKTORİNG A.Ş."
data = data.lower()
data.translate(str.maketrans('', '', string.punctuation))
93/8: unaccented_string = unidecode.unidecode(data)
93/9: import unidecode
93/10:
import sys
!{sys.executable} -m pip install unidecode
93/11:
import string
import unidecode

data = "GARANTİ FAKTORİNG A.Ş."
data = data.lower()
data.translate(str.maketrans('', '', string.punctuation))

unaccented_string = unidecode.unidecode(data)
93/12:
import string
import unidecode
93/13: data = "GARANTİ FAKTORİNG A.Ş."
93/14: data = data.lower()
93/15: data = data.translate(str.maketrans('', '', string.punctuation))
93/16: unaccented_string = unidecode.unidecode(data)
93/17:
import glob
import string
import unidecode



#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)
93/18:
from tika import parser
import re
import pandas as pd

raw = parser.from_file(filenames[0])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "BEREKET VARLIK KİRALAMA A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "QNB Finansbank A.Ş." : 159625,
    "QNB Finans Faktoring A.Ş." : 33546435,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
    "Zorlu Faktoring A.Ş." : 35057529,
    "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
    "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
    "Türk Ekonomi Bankası" : 217880,
    "TÜRKİYE HALK BANKASI A.Ş." : 216692,
    "Garanti Finansal Kiralama A.Ş." : 8750960,
    "T.C. ZİRAAT BANKASI A.Ş." : 183939,
    "T.C. Ziraat Bankası A.Ş." : 183939,
    "Yapı Kredi Faktoring A.Ş." : 12392512,
    "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
    "Türkiye Vakıflar Bankası T.A.O." : 805670,
    "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
    "Eko Faktoring A.Ş." : 31741179,
    "İş Yatırım Menkul Değerler A.Ş." : 8604427,
    "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
    "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
    "GARANTİ FAKTORİNG A.Ş." : 159580
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
type_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def normalise_issuer(issuer_name):
    
    issuer_name = issuer_name.lower()
    issuer_name = issuer_name.translate(str.maketrans('', '', string.punctuation))
    issuer_name = unidecode.unidecode(issuer_name)
    return issuer_name


def safe_execute():
  
  try:
    return BBID_Dict[normalise_issuer(pdf_extracted_cleaned[1])] if title_company_m == None else  BBID_Dict[normalise_issuer(title_company_m_l[1])]
  except:
    return company_name_warning


safe_execute()


data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         ["ISIN" if ISIN_m == None else ISIN_m.group(1),
          "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "-------"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type" if type_m == None else type_m[1],
          pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]
93/19: df = pd.DataFrame(data)
93/20: normalise_issuer(pdf_extracted_cleaned[1])
93/21: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
93/22: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
93/23: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
93/24:
import glob

#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)


#------------------------------------------------------------------------------

from tika import parser
import re
import pandas as pd

raw = parser.from_file(filenames[0])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "BEREKET VARLIK KİRALAMA A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "QNB Finansbank A.Ş." : 159625,
    "QNB Finans Faktoring A.Ş." : 33546435,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
    "Zorlu Faktoring A.Ş." : 35057529,
    "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
    "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
    "Türk Ekonomi Bankası" : 217880,
    "TÜRKİYE HALK BANKASI A.Ş." : 216692,
    "Garanti Finansal Kiralama A.Ş." : 8750960,
    "T.C. ZİRAAT BANKASI A.Ş." : 183939,
    "T.C. Ziraat Bankası A.Ş." : 183939,
    "Yapı Kredi Faktoring A.Ş." : 12392512,
    "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
    "Türkiye Vakıflar Bankası T.A.O." : 805670,
    "tuprasturkiye petrol rafinerileri as" : "yarrak",
    "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
    "Eko Faktoring A.Ş." : 31741179,
    "İş Yatırım Menkul Değerler A.Ş." : 8604427,
    "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
    "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
    "GARANTİ FAKTORİNG A.Ş." : 159580
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
ty_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def normalise_issuer(issuer_name):
    
    import string
    import unidecode
    
    issuer_name = issuer_name.lower()
    issuer_name = issuer_name.translate(str.maketrans('', '', string.punctuation))
    issuer_name = unidecode.unidecode(issuer_name)
    return issuer_name


def safe_execute():
  
  try:
    return BBID_Dict[normalise_issuer(pdf_extracted_cleaned[1])] if title_company_m == None else  BBID_Dict[normalise_issuer(title_company_m_l[1])]
  except:
    return company_name_warning



data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         ["ISIN" if ISIN_m == None else ISIN_m.group(1),
          "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "-------"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type" if type_m == None else type_m[1],
          pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]

df = pd.DataFrame(data)
93/25: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
93/26:
import glob

#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)


#------------------------------------------------------------------------------

from tika import parser
import re
import pandas as pd

raw = parser.from_file(filenames[0])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "BEREKET VARLIK KİRALAMA A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "QNB Finansbank A.Ş." : 159625,
    "QNB Finans Faktoring A.Ş." : 33546435,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
    "Zorlu Faktoring A.Ş." : 35057529,
    "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
    "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
    "Türk Ekonomi Bankası" : 217880,
    "TÜRKİYE HALK BANKASI A.Ş." : 216692,
    "Garanti Finansal Kiralama A.Ş." : 8750960,
    "T.C. ZİRAAT BANKASI A.Ş." : 183939,
    "T.C. Ziraat Bankası A.Ş." : 183939,
    "Yapı Kredi Faktoring A.Ş." : 12392512,
    "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
    "Türkiye Vakıflar Bankası T.A.O." : 805670,
    "tuprasturkiye petrol rafinerileri as" : "---test---",
    "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
    "Eko Faktoring A.Ş." : 31741179,
    "İş Yatırım Menkul Değerler A.Ş." : 8604427,
    "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
    "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
    "GARANTİ FAKTORİNG A.Ş." : 159580
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
ty_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def normalise_issuer(issuer_name):
    
    import string
    import unidecode
    
    issuer_name = issuer_name.lower()
    issuer_name = issuer_name.translate(str.maketrans('', '', string.punctuation))
    issuer_name = unidecode.unidecode(issuer_name)
    return issuer_name


def safe_execute():
  
  try:
    return BBID_Dict[normalise_issuer(pdf_extracted_cleaned[1])] if title_company_m == None else  BBID_Dict[normalise_issuer(title_company_m_l[1])]
  except:
    return company_name_warning



data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         ["ISIN" if ISIN_m == None else ISIN_m.group(1),
          "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "-------"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type" if type_m == None else type_m[1],
          pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]

df = pd.DataFrame(data)
93/27: type_m
93/28:
    ng A.Ş." : 35057529,
    "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
    "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
    "Türk Ekonomi Bankası" : 217880,
    "TÜRKİYE HALK BANKASI A.Ş." : 216692,
    "Garanti Finansal Kiralama A.Ş." : 8750960,
    "T.C. ZİRAAT BANKASI A.Ş." : 183939,
    "T.C. Ziraat Bankası A.Ş." : 183939,
    "Yapı Kredi Faktoring A.Ş." : 12392512,
    "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
    "Türkiye Vakıflar Bankası T.A.O." : 805670,
    "tuprasturkiye petrol rafinerileri as" : "---test---",
    "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
    "Eko Faktoring A.Ş." : 31741179,
    "İş Yatırım Menkul Değerler A.Ş." : 8604427,
    "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
    "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
    "GARANTİ FAKTORİNG A.Ş." : 159580
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
type_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def normalise_issuer(issuer_name):
    
    import string
    import unidecode
    
    issuer_name = issuer_name.lower()
    issuer_name = issuer_name.translate(str.maketrans('', '', string.punctuation))
    issuer_name = unidecode.unidecode(issuer_name)
    return issuer_name


def safe_execute():
  
  try:
    return BBID_Dict[normalise_issuer(pdf_extracted_cleaned[1])] if title_company_m == None else  BBID_Dict[normalise_issuer(title_company_m_l[1])]
  except:
    return company_name_warning



data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         ["ISIN" if ISIN_m == None else ISIN_m.group(1),
          "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "-------"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type" if type_m == None else type_m[1],
          pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]

df = pd.DataFrame(data)
93/29:
import glob

#------------------------------------------------------------------------------
filenames = []

for filepath in glob.iglob(r'C:\Users\Cagri\Desktop\Turkish Term Sheets/*.pdf'):
    filenames.append(filepath)


#------------------------------------------------------------------------------

from tika import parser
import re
import pandas as pd

raw = parser.from_file(filenames[0])

pdf_extracted = list(raw['content'].split("\n"))

pdf_extracted_cleaned = []

for i in pdf_extracted:
  if i != "" and i !=" " and i != "  " and i != "-":
    pdf_extracted_cleaned.append(i)


BBID_Dict = {
    "AKBANK T.A.Ş." : 159576,
    "AK FİNANSAL KİRALAMA A.Ş." : 22393029,
    "Bereket Varlık Kiralama A.Ş." : 28561089,
    "BEREKET VARLIK KİRALAMA A.Ş." : 28561089,
    "Yapı ve Kredi Bankası A.Ş." : 154568,
    "Aktif Bank Sukuk Varlık Kiralama A.Ş." : 53792123,
    "TÜRKİYE VAKIFLAR BANKASI T.A.O." : 805670,
    "Ak Yatırım Menkul Değerler A.Ş." : 20021639,
    "QNB FİNANSBANK A.Ş." : 159626,
    "YAPI VE KREDİ BANKASI A.Ş." : 154568,
    "TÜRKİYE GARANTİ BANKASI A.Ş." : 126333,
    "T. Garanti Bankası A.Ş." : 126333,
    "Halk Varlık Kiralama A.Ş." : 59635062,
    "KT KİRA SERTİFİKALARI VARLIK KİRALAMA A.Ş.": 38453748,
    "KT Kira Sertifikaları Varlık" : 38453748,
    "ZİRAAT KATILIM VARLIK KİRALAMA A.Ş." : 49919802,
    "ZORLU FAKTORİNG A.Ş." : 35057529,
    "QNB FİNANS YATIRIM MENKUL DEĞERLER A.Ş." : 19671777,
    "QNB FİNANS FİNANSAL KİRALAMA A.Ş.": 159626,
    "QNB Finansbank A.Ş." : 159625,
    "QNB Finans Faktoring A.Ş." : 33546435,
    "İŞ FAKTORİNG A.Ş." :  8604399,
    "ŞEKER FAKTORİNG A.Ş." : 8794207,
    "Şeker Faktoring A.Ş." : 8794207,
    "TÜRKİYE İŞ BANKASI A.Ş." : 159718,
    "Zorlu Faktoring A.Ş." : 35057529,
    "QNB FİNANS FAKTORİNG A.Ş." : 33546435,
    "TÜRK EKONOMİ BANKASI A.Ş." : 217880,
    "Türk Ekonomi Bankası" : 217880,
    "TÜRKİYE HALK BANKASI A.Ş." : 216692,
    "Garanti Finansal Kiralama A.Ş." : 8750960,
    "T.C. ZİRAAT BANKASI A.Ş." : 183939,
    "T.C. Ziraat Bankası A.Ş." : 183939,
    "Yapı Kredi Faktoring A.Ş." : 12392512,
    "KOÇ FIAT KREDİ FİNANSMAN A.Ş." :  8783898,
    "Türkiye Vakıflar Bankası T.A.O." : 805670,
    "tuprasturkiye petrol rafinerileri as" : "---test---",
    "YAPI KREDİ FAKTORİNG A.Ş." : 12392512,
    "Eko Faktoring A.Ş." : 31741179,
    "İş Yatırım Menkul Değerler A.Ş." : 8604427,
    "Ziraat Katılım Varlık Kiralama A.Ş" : 49919802,
    "AK YATIRIM MENKUL DEĞERLER A.Ş." : 20021639,
    "GARANTİ FAKTORİNG A.Ş." : 159580
}

#for i in pdf_extracted_cleaned:
#  print(i)

maturity_m = re.search(r"(Maturity Date|Redemption Date) ([0-9]{2}(\.|\/)[0-9]{2}(\.|\/)[0-9]{4})", raw["content"])
ISIN_m = re.search(r"(.+) (TR.{10})", raw["content"])
coupon_number_m = re.search(r"(Coupon Number) (\d)", raw["content"])
currency_m = re.search(r"(Currency Unit) (TRY)|(Nominal Value) \((TL)\)", raw["content"])
type_m = re.search(r"(Type) (M.+)", raw["content"])
interest_rate_type_m = re.search(r"(Interest Rate Type) (.+)", raw["content"])
title_company_m = re.search(r"(Issuer)\n?(.+)|(Title of Related Company)\n? ?(.+)", raw["content"])

currency_m_l = None
title_company_m_l = None

currency_m_l = [i for i in currency_m.groups() if i is not None]
if title_company_m != None:
  title_company_m_l = [i for i in title_company_m.groups() if i is not None]



company_name_warning = "---- Check the company name ----"

def normalise_issuer(issuer_name):
    
    import string
    import unidecode
    
    issuer_name = issuer_name.lower()
    issuer_name = issuer_name.translate(str.maketrans('', '', string.punctuation))
    issuer_name = unidecode.unidecode(issuer_name)
    return issuer_name


def safe_execute():
  
  try:
    return BBID_Dict[normalise_issuer(pdf_extracted_cleaned[1])] if title_company_m == None else  BBID_Dict[normalise_issuer(title_company_m_l[1])]
  except:
    return company_name_warning



data = [["Issuer" if title_company_m == None else title_company_m_l[0],
         pdf_extracted_cleaned[1] if title_company_m == None else title_company_m_l[1]],
         ["BBID" , safe_execute()],
         [maturity_m.group(1), maturity_m.group(2)],
         ["ISIN" if ISIN_m == None else ISIN_m.group(1),
          "--- Check the ISIN ---" if ISIN_m == None else ISIN_m.group(2)],
         [coupon_number_m.group(1) if coupon_number_m != None else "Coupon Number",
         coupon_number_m.group(2) if coupon_number_m != None else "-------"],
         [currency_m_l[0], currency_m_l[1]],
         ["Type" if type_m == None else type_m[1],
          pdf_extracted_cleaned[2] if type_m == None else type_m[2]],
         [interest_rate_type_m.group(1) if interest_rate_type_m != None else "Interest Rate Type",
         interest_rate_type_m.group(2) if interest_rate_type_m != None else "-------"]]

df = pd.DataFrame(data)
94/1: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
94/2: print(def)
94/3: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
94/4: import camelot
94/5:
import sys
!{sys.executable} -m pip install camelot
94/6: import camelot
94/7:
import sys
!{sys.executable} -m pip install camelot-py
94/8:
import sys
!{sys.executable} -m pip uninstall camelot
95/1: import camelot
95/2: import camelot
95/3:
import pip
pip.main(['uninstall', 'camelot'])
95/4:
from pip import main
pip.main(['uninstall', 'camelot'])
95/5:
import pip
pip.main(['uninstall', 'camelot'])
95/6: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
95/7: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
95/8:
import sys
!{sys.executable} -m pip uninstall camelot
95/9:
import sys
!{sys.executable} -m pip uninstall camelot-py
96/1: import camelot
96/2:
import sys
!{sys.executable} -m pip install camelot-py
96/3: import camelot
96/4:
import sys
!{sys.executable} -m pip uninstall camelot-py
97/1: import camelot
97/2:
import sys
!{sys.executable} -m pip install camelot-py[cv]
97/3: import camelot
97/4: tables = camelot.read_pdf(r"C:\Users\Cagri\Desktop\Turkish Term Sheets\758468 floater.pdf")
97/5: tables
97/6: print(tables)
97/7: runfile('C:/Users/Cagri/Desktop/Turkish Term Sheets/Extraction_code.py', wdir='C:/Users/Cagri/Desktop/Turkish Term Sheets')
97/8: import tabula
97/9:
import sys
!{sys.executable} -m pip install tabula-py
97/10: import tabula
98/1: import tabula
98/2: tables = tabula.read_pdf(r"C:\Users\Cagri\Desktop\Turkish Term Sheets\758468 floater.pdf")
98/3: tables
99/1: list_vol = [1,6,5,9]
99/2: max(list_vol)
99/3: max(list_vol)
99/4:
for i in list_vol:
    print(i)
99/5:
for i in list_vol:
    k = 0
    i
    if i > k:
        k = i

        k
99/6:
for i in list_vol:
    k = 0
    i
    if i > k:
        k = i

k
99/7:
for i in list_vol:
    print(i)
k
99/8:
list_vol = [1,6,5,9]

for i in list_vol:
    print(i)
k
99/9:
list_vol = [1,6,7]
for i in list_vol:
    print(i)
99/10:
def indexer(ensemble_of_letters, seed):
    for i in dict_encode:
        dict_encode[i]
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5}
99/11:
dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5}
99/12: dict_encode["a"]
99/13:
def indexer(ensemble_of_letters, seed):
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5}
    
    list_of_indices = []
    
    for i in dict_encode:
        list_of_indices = dict_encode[i] + seed + 2

    return list_of_indices
99/14: indexer("faacb", 3)
99/15:
def indexer(ensemble_of_letters, seed):
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5}
    
    list_of_indices = []
    
    for i in dict_encode:
        list_of_indices.append(dict_encode[i] + seed + 2)

    return list_of_indices
99/16: indexer("faacb", 3)
99/17:
def indexer(ensemble_of_letters, seed):
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5}
    
    list_of_indices = {}
    
    for i in dict_encode:
        list_of_indices[i] = append(dict_encode[i] + seed + 2)

    return list_of_indices
99/18: indexer("faacb", 3)
99/19:
def indexer(ensemble_of_letters, seed):
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5}
    
    list_of_indices = {}
    
    for i in dict_encode:
        list_of_indices[i] = (dict_encode[i] + seed + 2)

    return list_of_indices
99/20: indexer("faacb", 3)
99/21:
def indexer(ensemble_of_letters, seed):
    
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5}
    
    list_of_indices = {}
    
    for i in ensemble_of_letters:
        list_of_indices[i] = (dict_encode[i] + seed + 2)

    return list_of_indices
99/22: indexer("faacb", 3)
99/23:
def indexer(ensemble_of_letters, seed):
    
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g"
                  "g"
                  "g"
                  "g"
                  "g"
                  "g"}
    
    list_of_indices = {}
    
    for i in ensemble_of_letters:
        list_of_indices[i] = (dict_encode[i] + seed + 2)

    return list_of_indices
99/24:
def indexer(ensemble_of_letters, seed):
    
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g"
                  "g"
                  "g"
                  "g"
                  "g"
                  "g"}
    
    list_of_indices = {}
    
    for i in ensemble_of_letters:
        list_of_indices[i] = (dict_encode[i] + seed + 2)

    return list_of_indices
99/25: a = indexer("faacb", 3)
99/26: a.key(i)
99/27: a.key(10)
99/28:
def indexer(ensemble_of_letters, seed):
    
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g":6,
                  "h":7,
                  "i":8,
                  "j":9,
                  "k":10}
    
    list_of_indices = []
    
    for i in ensemble_of_letters:
        list_of_indices.append(dict_encode[i] + seed + 2)

    return list_of_indices
99/29: a = indexer("faacb", 3)
99/30: a~
99/31: a
99/32:
dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g":6,
                  "h":7,
                  "i":8,
                  "j":9,
                  "k":10}
99/33: dict_encode.value[10]
99/34: dict_encode.value()
99/35: dict_encode.values()
99/36: dict_encode.values()[10]
99/37: dict_encode[10]
99/38: dict_encode["f"]
99/39: dict_encode.keys()[dict_encode.values().index(10)]
99/40: dict_encode.keys()[dict_encode.values()[10]]
99/41: [dict_encode.values()[10]]
99/42: dict_encode.values()
99/43: type(dict_encode.values())
99/44: dict_encode.values()~
99/45: dict_encode.values()
99/46: list(dict_encode.values())
99/47: list(dict_encode.values())[10]
99/48:
mydict = {'george':16,'amber':19}
mydict.keys()[list(dict_encode.values())[10]]
99/49:
mydict = {'george':16,'amber':19}
list(dict_encode.keys())[list(dict_encode.values()).index(16)]
99/50:
mydict = {'george':16,'amber':19}
list(dict_encode.keys())[list(dict_encode.values()).index(10)]
99/51: x = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
99/52: x.join[:]
99/53: x.join[]
99/54: x.join()
99/55: x[:] = [''.join(x[:])]
99/56:
x[:] = [''.join(x[:])]
x
99/57:
def indexer(ensemble_of_letters, seed):
    
    dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g":6,
                  "h":7,
                  "i":8,
                  "j":9,
                  "k":10}
    
    list_of_indices = []
    
    for i in ensemble_of_letters:
        list_of_indices.append(dict_encode[i] + seed + 2)
        
    encode_name_new = []
    
    for j in list_of_indices:
        encode_name_new.append(list(dict_encode.keys())[list(dict_encode.values()).index(j)])
        x[:] = [''.join(encode_name_new[:])]

    return x
99/58: a = indexer("faacb", 3)
99/59: a
99/60: a = indexer("ecadkj", 3)6
99/61: a = indexer("ecadkj", 3)
99/62: a = indexer("ecadkj", 6)
99/63:
dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g":6,
                   "h":7,
                   "i":8,
                   "j":9,
                   "k":10}
    
list_of_indices = []
    
for i in ensemble_of_letters:
    list_of_indices.append(dict_encode[i] + seed + 2)
    
list_of_indices
99/64:
ensemble_of_letters = "ecadkj"

dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g":6,
                   "h":7,
                   "i":8,
                   "j":9,
                   "k":10}
    
list_of_indices = []
    
for i in ensemble_of_letters:
    list_of_indices.append(dict_encode[i] + seed + 2)
    
list_of_indices
99/65:
ensemble_of_letters = "ecadkj"
seed = 3

dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g":6,
                   "h":7,
                   "i":8,
                   "j":9,
                   "k":10}
    
list_of_indices = []
    
for i in ensemble_of_letters:
    list_of_indices.append(dict_encode[i] + seed + 2)
    
list_of_indices
99/66:
ensemble_of_letters = "faacb"
seed = 3

dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g":6,
                   "h":7,
                   "i":8,
                   "j":9,
                   "k":10}
    
list_of_indices = []
    
for i in ensemble_of_letters:
    list_of_indices.append(dict_encode[i] + seed + 2)
    
list_of_indices
99/67:
ensemble_of_letters = "faacb"
seed = 3

dict_encode = {"a":0,
                   "b":1,
                   "c":2,
                   "d":3,
                   "e":4,
                   "f":5,
                   "g":6,
                   "h":7,
                   "i":8,
                   "j":9,
                   "k":10}
    
list_of_indices = []
    
for i in ensemble_of_letters:
    print(i)
    list_of_indices.append(dict_encode[i] + seed + 2)
    
list_of_indices
99/68: dict_encode["f"]
99/69: dict_encode["f"] + 3 + 2
99/70: list_of_indices
99/71:
for j in list_of_indices:
    print(j)
    encode_name_new.append(list(dict_encode.keys())[list(dict_encode.values()).index(j)])
    x[:] = [''.join(encode_name_new[:])]
99/72:
encode_name_new = []

for j in list_of_indices:
    print(j)
    encode_name_new.append(list(dict_encode.keys())[list(dict_encode.values()).index(j)])
    x[:] = [''.join(encode_name_new[:])]
99/73: a = indexer("faacb", 3)
99/74: a
99/75: test_string = "How many children are there with us?"
99/76:
test_string_lower_case = test_string.lower()
test_string_lower_case
99/77:
t_s_l_c_words = test_string_lower_case.split(" ")#
t_s_l_c_words
99/78:
for i in t_s_l_c_words:
    print(i)
99/79:
for i in t_s_l_c_words:
    for j in i:
        print(j)
99/80:
for i in t_s_l_c_words:
    print(i)
99/81:
for i in t_s_l_c_words:
    print(i[0])
99/82:
for i in t_s_l_c_words:
    k = 0
    if i[0] == "h":
        k += 1
99/83: k
99/84:
for i in t_s_l_c_words:
    k = 0
    if i[0] == "h":
        k =  k + 1
99/85: k
99/86:
for i in t_s_l_c_words:
    k = 0
    if i[0] == "h":
        print(i)
        k =  k + 1
99/87:
for i in t_s_l_c_words:
    k = 0
    if i[0] == "h":
        k =  k + 1
        print(k)
99/88:
for i in t_s_l_c_words:
    k = 0
    if i[0] == "h":
        k =  k + 1
        print(k)
99/89: test_string = "How many children hare there with us?"
99/90:
test_string_lower_case = test_string.lower()
test_string_lower_case
99/91:
t_s_l_c_words = test_string_lower_case.split(" ")
t_s_l_c_words
99/92:
for i in t_s_l_c_words:
    k = 0
    if i[0] == "h":
        k =  k + 1
        print(k)
99/93:
k = 0

for i in t_s_l_c_words:
    if i[0] == "h":
        k =  k + 1
        
k
102/1: import pandas as pd
102/2: path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
102/3:
ath = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
102/4: #Get rid of the columns that does not mean anything for the model such as name, ID
102/5:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 2:]
102/6:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 2:]
df
102/7:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 2:]
102/8:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 2:]
df.head()
102/9: import pandas as pd
102/10:
ath = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
102/11:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 2:]
df.head()
103/1: import pandas as pd
103/2:
ath = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/3:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/4:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:]
df.head()
103/5: import pandas as pd
103/6:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/7:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:]
df.head()
103/8: pd.get_dummies(df["Geography"])
103/9: pd.get_dummies(df["Geography"]).head()
103/10: df.insert(1, pd.get_dummies(df["Geography"]))
103/11: df["France"], df["Germany"], df["Spain"] = pd.get_dummies(df["Geography"])
103/12:
df["France"], df["Germany"], df["Spain"] = pd.get_dummies(df["Geography"])
df
103/13: import pandas as pd
103/14:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/15:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:]
df.head()
103/16: pd.get_dummies(df,prefix=['Geography'])
103/17: pd.get_dummies(df["Geography"], prefix=['France, Spain, Germany'])
103/18: pd.get_dummies(df["Geography"], prefix=['country'])
103/19: pd.get_dummies(df["Geography"], prefix='country')
103/20: pd.get_dummies(df["Geography"], prefix='')
103/21: pd.get_dummies(df["Geography"], prefix='c')
103/22: df = pd.get_dummies(df["Geography"], prefix='c')
103/23: import pandas as pd
103/24:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/25:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:]
df.head()
103/26: df = pd.get_dummies(df["Geography"], prefix='c')
103/27:
df["France"], df["Germany"], df["Spain"] = pd.get_dummies(df["Geography"])
df
103/28:
df["France"], df["Germany"], df["Spain"] = pd.get_dummies(df["Geography"])
df
103/29: import pandas as pd
103/30:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/31:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:]
df.head()
103/32:
df = pd.get_dummies(df["Geography"], prefix='c')
df
103/33:
pd.get_dummies(df["Geography"], prefix="c")
pd.get_dummies(df["Gender"], prefix= )
103/34:
pd.get_dummies(df["Geography"], prefix="c")
pd.get_dummies(df["Gender"], prefix="g")
103/35: import pandas as pd
103/36:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/37:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:]
df.head()
103/38:
pd.get_dummies(df["Geography"], prefix="c")
pd.get_dummies(df["Gender"], prefix="g")
103/39:
pd.get_dummies(df["Geography"], prefix="c")
#pd.get_dummies(df["Gender"], prefix="g")
103/40:
df["c_France"], df["c_Germany"], df["c_Spain"] = pd.get_dummies(df["Geography"], prefix="c")
#pd.get_dummies(df["Gender"], prefix="g")
103/41:
df["c_France"], df["c_Germany"], df["c_Spain"] = pd.get_dummies(df["Geography"], prefix="c")
df
#pd.get_dummies(df["Gender"], prefix="g")
103/42:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:13]
103/43:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:13]
df
103/44: import pandas as pd
103/45:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/46:
#Get rid of the columns that does not mean anything for the model such as name, ID
df = df.iloc[:, 3:13]
df
103/47:
#Get rid of the columns that does not mean anything for the model such as name, ID
X = df.iloc[:, 3:13].values
y = df.iloc[:, 14].values
103/48:
#Get rid of the columns that does not mean anything for the model such as name, ID
X = df.iloc[:, 3:13].values
y = df.iloc[:, 13].values
103/49: import pandas as pd
103/50:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
103/51:
#Get rid of the columns that does not mean anything for the model such as name, ID
X = df.iloc[:, 3:13].values
y = df.iloc[:, 13].values
103/52: y
103/53:
from sklearn.preprocessing import OneHotEncoder
enc = OneHotEncoder(handle_unknown='ignore')
X = [['Male', 1], ['Female', 3], ['Female', 2]]
enc.fit(X)
103/54: X
103/55:
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
103/56: X[:, 1]
103/57: X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
105/1: import pandas as pd
105/2:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
105/3:
#Get rid of the columns that does not mean anything for the model such as name, ID
X = df.iloc[:, 3:13].values
y = df.iloc[:, 13].values
105/4:
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
105/5: X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
105/6: X[:, 1]
105/7: import pandas as pd
105/8:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
105/9:
#Get rid of the columns that does not mean anything for the model such as name, ID
X = df.iloc[:, 3:13].values
y = df.iloc[:, 13].values
105/10:
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
105/11: X[:, 1]
105/12: X
105/13: X[:, 0]
105/14:
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])
105/15: X[:, 2]
105/16:
onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]
105/17: x
105/18: X
105/19: import pandas as pd
105/20:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
105/21:
#Get rid of the columns that does not mean anything for the model such as name, ID
X = df.iloc[:, 3:13].values
y = df.iloc[:, 13].values
105/22: X
105/23:
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
105/24:
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])
105/25:
onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]
105/26: import pandas as pd
105/27:
path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
df = pd.read_csv(path)
df.head()
105/28:
#Get rid of the columns that does not mean anything for the model such as name, ID
X = df.iloc[:, 3:13].values
y = df.iloc[:, 13].values
105/29: X
105/30:
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
105/31:
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])
105/32: X[:, 1:]
104/1: runfile('C:/Users/Cagri/Google Drive/Self Study/Deep Learning A-Z Udemy/PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)/Artificial_Neural_Networks/ann_homework_solution.py', wdir='C:/Users/Cagri/Google Drive/Self Study/Deep Learning A-Z Udemy/PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)/Artificial_Neural_Networks')
104/2:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

# Encoding categorical data
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_2.fit_transform(X[:, 2])
onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]
104/3:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values
104/4:
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_2.fit_transform(X[:, 2])
104/5:
onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]
105/33: df.iloc[:, 3:13].head()
104/6: runfile('C:/Users/Cagri/Google Drive/Self Study/Deep Learning A-Z Udemy/PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)/Artificial_Neural_Networks/STUDY-MY SOLUTION..py', wdir='C:/Users/Cagri/Google Drive/Self Study/Deep Learning A-Z Udemy/PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)/Artificial_Neural_Networks')
104/7:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv("C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, [2, 3]].values
y = dataset.iloc[:, 4].values
106/1:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv("C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values
106/2:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values
106/3: x
106/4: X
106/5:
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 0])
106/6: X
107/1:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
107/2: X
107/3:
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])
107/4:
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])
107/5: X
108/1:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])
108/2: X
108/3:
onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
108/4: X = X[:, 1:]
108/5:
from sklearn.cross_validation import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)
108/6:
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)
108/7:
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
109/1: import keras
109/2:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
109/3:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import sequential
from keras.layers import dense
109/4:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense
109/5:
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)
109/6: classifier = Sequential()
109/7: X.shape[1]
109/8:
classifier.add(Dense(input_dim = X.shape[1],
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu")
109/9:
classifier.add(Dense(input_dim = X.shape[1],
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))
109/10: print(classifier.summary())
109/11:
classifier.add(Dense(11,
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))
109/12:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

#Initialising the ANN
classifier = Sequential()
classifier.add(Dense(11,
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))
111/1:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

#Initialising the ANN
classifier = Sequential()
classifier.add(Dense(input_dim = X.shape[1],
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

print(classifier.summary())
111/2: X.shape[1]
111/3:
classifier = Sequential()
classifier.add(Dense(input_dim = X.shape[1],
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 1,
                     init = "uniform",
                     activation = "sigmoid"))

print(classifier.summary())
111/4:
classifier.compile(optimizer= "Adam",
                   loss = "binary_crossentropy",
                   metrics = ["accuracy"])
112/1:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

#Initialising the ANN
classifier = Sequential()
classifier.add(Dense(input_dim = X.shape[1],
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 1,
                     init = "uniform",
                     activation = "sigmoid"))

print(classifier.summary())

#Compiling the ANN
classifier.compile(optimizer= "Adam",
                   loss = "binary_crossentropy",
                   metrics = ["accuracy"])
112/2:
classifier.fit(X_train,
               y_train,
               batch_size = 10,
               epochs = 100)
112/3: y_pred = classifier.predict(X_test)
112/4: y_pred = y_pred*100
112/5:
y_pred[y_pred >= 50] = 1
y_pred[y_pred < 50] = 0
112/6:
y_pred[y_pred => 50] = 1
y_pred[y_pred < 50] = 0
112/7:
y_pred = classifier.predict(X_test)
y_pred = y_pred*100
112/8:
if y_pred < 50:
    y_pred = 0
else:
    y_pred = 1
112/9:
y_pred = classifier.predict(X_test)
y_pred = y_pred*100
112/10:
if y_pred < 50:
    y_pred = 0
else:
    y_pred = 1
112/11:
if y_pred <= 50:
    y_pred = 0
else:
    y_pred = 1
112/12:
if y_pred =< 50:
    y_pred = 0
else:
    y_pred = 1
112/13:
y_pred = classifier.predict(X_test)
y_pred = (y_pred > 0.5)
112/14: y_pred = classifier.predict(X_test)
112/15: y_pred = (y_pred > 0.5)
112/16:
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)
112/17: 1537+148
112/18: 1685/(1537+58+257+148)
112/19: 1537+58+257+148
112/20:
customer_1 = np.array["France",
                      600,
                      "Male",
                      40,
                      3,
                      60000,
                      2,
                      1,
                      1,
                      50000]
112/21:
customer_1 = np.array(["France",
                      600,
                      "Male",
                      40,
                      3,
                      60000,
                      2,
                      1,
                      1,
                      50000])
112/22:
customer_1 = np.array(["France",
                      600,
                      "Male",
                      40,
                      3,
                      60000,
                      2,
                      1,
                      1,
                      50000]).values
112/23:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values
112/24:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values
112/25: x
112/26: X
112/27:
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)
113/1: runfile('C:/Users/Cagri/Google Drive/Self Study/Deep Learning A-Z Udemy/PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)/Artificial_Neural_Networks/STUDY-MY SOLUTION..py', wdir='C:/Users/Cagri/Google Drive/Self Study/Deep Learning A-Z Udemy/PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)/Artificial_Neural_Networks')
113/2: q = classifier.predict(customer_1)
113/3: customer_1
113/4:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]
113/5:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

#Initialising the ANN
classifier = Sequential()
classifier.add(Dense(input_dim = X.shape[1],
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 1,
                     init = "uniform",
                     activation = "sigmoid"))

print(classifier.summary())

#Compiling the ANN
classifier.compile(optimizer= "Adam",
                   loss = "binary_crossentropy",
                   metrics = ["accuracy"])

#Fitting theANN
classifier.fit(X_train,
               y_train,
               batch_size = 10,
               epochs = 100)

y_pred = classifier.predict(X_test)
y_pred = (y_pred > 0.5)

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)

customer_1 = np.array([["France",
                        600,                    ,
                      "Male",
                      40,
                      3,
                      60000,
                      2,
                      1,
                      1,
                      50000]])
113/6:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

#Initialising the ANN
classifier = Sequential()
classifier.add(Dense(input_dim = X.shape[1],
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 1,
                     init = "uniform",
                     activation = "sigmoid"))

print(classifier.summary())

#Compiling the ANN
classifier.compile(optimizer= "Adam",
                   loss = "binary_crossentropy",
                   metrics = ["accuracy"])

#Fitting theANN
classifier.fit(X_train,
               y_train,
               batch_size = 10,
               epochs = 100)

y_pred = classifier.predict(X_test)
y_pred = (y_pred > 0.5)

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)

customer_1 = np.array([["France",
                        600,                    ,
                      "Male",
                      40,
                      3,
                      60000,
                      2,
                      1,
                      1,
                      50000]])
113/7:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense


# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1])
labelencoder_X_2 = LabelEncoder()
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])

onehotencoder = OneHotEncoder(categorical_features = [1])
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:]

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

#Initialising the ANN
classifier = Sequential()
classifier.add(Dense(input_dim = X.shape[1],
                     output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 6,
                     init = "uniform",
                     activation = "relu"))

classifier.add(Dense(output_dim = 1,
                     init = "uniform",
                     activation = "sigmoid"))

print(classifier.summary())

#Compiling the ANN
classifier.compile(optimizer= "Adam",
                   loss = "binary_crossentropy",
                   metrics = ["accuracy"])

#Fitting theANN
classifier.fit(X_train,
               y_train,
               batch_size = 10,
               epochs = 100)

y_pred = classifier.predict(X_test)
y_pred = (y_pred > 0.5)

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)

customer_1 = np.array([["France",
                        600,
                        "Male",
                      40,
                      3,
                      60000,
                      2,
                      1,
                      1,
                      50000]])

q = classifier.predict(customer_1)
113/8:
customer_1 = np.array([[0,0,
                        600,
                        1,
                      40,
                      3,
                      60000,
                      2,
                      1,
                      1,
                      50000]])

q = classifier.predict(customer_1)
113/9: customer_1_scaled = sc.transform(customer_1)
113/10: q = classifier.predict(customer_1_scaled)
113/11:
q = classifier.predict(customer_1_scaled)
q = (q > 0.5)
114/1:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense

# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1]) #label encoding the country column
labelencoder_X_2 = LabelEncoder()                 #to later pass it to one hot encoder
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])


"""
Please note that only country is hot encoded (not gender). 
This is because the number of columns there should be is;
 ==number of categories - 1==

e.g

Countries:

France
Germany
Spain

3 categories

So I need to have 2 columns (3-1)

But in the case of Gender

Male
Female

2 categories

Therefore, I need to have a single column
"""
onehotencoder = OneHotEncoder(categorical_features = [1]) 
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:] # Getting rid of one column to prevent the dummy variable trap

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y,
                                                    test_size = 0.2,
                                                    random_state = 0)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
114/2:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score
114/3:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score

def build_classifier():
    
    classifier = Sequential()
    classifier.add(Dense(input_dim = 11,
                         output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 1,
                         init = "uniform",
                         activation = "sigmoid"))    
    
    classifier.compile(optimizer= "Adam",
                       loss = "binary_crossentropy", 
                       metrics = ["accuracy"])
    
    return classifier


classifier = KerasClassifier(build_fn= build_classifier,
                             batch_size = 10,
                             epochs = 100)

accuracies = cross_val_score(estimator = classifier,
                             X = X_train,
                             y= y_train,
                             cv = 10,
                             n_jobs = -1)
114/4:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score

def build_classifier():
    
    classifier = Sequential()
    classifier.add(Dense(input_dim = 11,
                         output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 1,
                         init = "uniform",
                         activation = "sigmoid"))    
    
    classifier.compile(optimizer= "Adam",
                       loss = "binary_crossentropy", 
                       metrics = ["accuracy"])
    
    return classifier


classifier = KerasClassifier(build_fn= build_classifier,
                             batch_size = 10,
                             epochs = 100)

accuracies = cross_val_score(estimator = classifier,
                             X = X_train,
                             y= y_train,
                             cv = 10,
                             n_jobs = 8)
114/5: print(sklearn.version__)
114/6: import sklearn
114/7: print(sklearn.version__)
114/8: print(sklearn.__version__)
114/9:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score

def build_classifier():
    
    classifier = Sequential()
    classifier.add(Dense(input_dim = 11,
                         output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 1,
                         init = "uniform",
                         activation = "sigmoid"))    
    
    classifier.compile(optimizer= "Adam",
                       loss = "binary_crossentropy", 
                       metrics = ["accuracy"])
    
    return classifier


classifier = KerasClassifier(build_fn= build_classifier,
                             batch_size = 10,
                             epochs = 100)

accuracies = cross_val_score(estimator = classifier,
                             X = X_train,
                             y= y_train,
                             cv = 10,
                             n_jobs = 1)
114/10:
import sys
!{sys.executable} -m pip install joblib
114/11:
import sys
!{sys.executable} -m pip install joblib
114/12:
import sys
!{sys.executable} -m pip uninstall joblib
115/1:
import sys
!{sys.executable} -m pip install numpy
115/2: joblib
115/3:
import sys
!{sys.executable} -m pip install joblib
115/4:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix

# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1]) #label encoding the country column
labelencoder_X_2 = LabelEncoder()                 #to later pass it to one hot encoder
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])


"""
Please note that only country is hot encoded (not gender). 
This is because the number of columns there should be is;
 ==number of categories - 1==

e.g

Countries:

France
Germany
Spain

3 categories

So I need to have 2 columns (3-1)

But in the case of Gender

Male
Female

2 categories

Therefore, I need to have a single column
"""
onehotencoder = OneHotEncoder(categorical_features = [1]) 
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:] # Getting rid of one column to prevent the dummy variable trap

# Splitting the dataset into the Training set and Test set
X_train, X_test, y_train, y_test = train_test_split(X, y,
                                                    test_size = 0.2,
                                                    random_state = 0)

# Feature Scaling
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
115/5:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score

def build_classifier():
    
    classifier = Sequential()
    classifier.add(Dense(input_dim = 11,
                         output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 1,
                         init = "uniform",
                         activation = "sigmoid"))    
    
    classifier.compile(optimizer= "Adam",
                       loss = "binary_crossentropy", 
                       metrics = ["accuracy"])
    
    return classifier


classifier = KerasClassifier(build_fn= build_classifier,
                             batch_size = 10,
                             epochs = 100)

accuracies = cross_val_score(estimator = classifier,
                             X = X_train,
                             y= y_train,
                             cv = 10,
                             n_jobs = -1)
115/6:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score

def build_classifier():
    
    classifier = Sequential()
    classifier.add(Dense(input_dim = 11,
                         output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 1,
                         init = "uniform",
                         activation = "sigmoid"))    
    
    classifier.compile(optimizer= "Adam",
                       loss = "binary_crossentropy", 
                       metrics = ["accuracy"])
    
    return classifier


classifier = KerasClassifier(build_fn= build_classifier,
                             batch_size = 10,
                             epochs = 100)

accuracies = cross_val_score(estimator = classifier,
                             X = X_train,
                             y= y_train,
                             cv = 10,
                             n_jobs = 1)
115/7:
mean_acc = accuracies.mean()
std_acc = accuracies.std()
116/1:
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import keras
from keras.models import Sequential
from keras.layers import Dense
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix
from keras.layers import Dropout

# Importing the dataset
dataset = pd.read_csv(r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv")
X = dataset.iloc[:, 3:13].values
y = dataset.iloc[:, 13].values

from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_X_1 = LabelEncoder()
X[:, 1] = labelencoder_X_1.fit_transform(X[:, 1]) #label encoding the country column
labelencoder_X_2 = LabelEncoder()                 #to later pass it to one hot encoder
X[:, 2] = labelencoder_X_1.fit_transform(X[:, 2])


"""
Please note that only country is hot encoded (not gender). 
This is because the number of columns there should be is;
 ==number of categories - 1==

e.g

Countries:

France
Germany
Spain

3 categories

So I need to have 2 columns (3-1)

But in the case of Gender

Male
Female

2 categories

Therefore, I need to have a single column
"""
onehotencoder = OneHotEncoder(categorical_features = [1]) 
X = onehotencoder.fit_transform(X).toarray()
X = X[:, 1:] # Getting rid of one column to prevent the dummy variable trap

# Splitting the dataset into the Training set and Test set
X_train, X_test, y_train, y_test = train_test_split(X, y,
                                                    test_size = 0.2,
                                                    random_state = 0)

# Feature Scaling
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
116/2:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import GridSearchCV
from keras.models import Sequential
from keras.layers import Dense


def build_classifier(optimizer):
    
    classifier = Sequential()
    classifier.add(Dense(input_dim = 11,
                         output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 1,
                         init = "uniform",
                         activation = "sigmoid"))    
    
    classifier.compile(optimizer= optimizer,
                       loss = "binary_crossentropy", 
                       metrics = ["accuracy"])
    
    return classifier


classifier = KerasClassifier(build_fn= build_classifier,
                             batch_size = 10,
                             epochs = 100)


parameters = {"batch_size":[25,32],
              "epochs": [25, 50],
              "optimizer": ["adam", "rmsprop"]}

grid_search = GridSearchCV(estimator = classifier,
                           param_grid = parameters,
                           scoring = "accuracy",
                           cv = 3)

grid_search = grid_search.fit(X_train, y_train)
best_param = grid_search.best_params_
best_accuracy = grid_search.best_score_
116/3:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import GridSearchCV
from keras.models import Sequential
from keras.layers import Dense


def build_classifier(optimizer):
    
    classifier = Sequential()
    classifier.add(Dense(input_dim = 11,
                         output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 6,
                         init = "uniform",
                         activation = "relu"))
    
    classifier.add(Dense(output_dim = 1,
                         init = "uniform",
                         activation = "sigmoid"))    
    
    classifier.compile(optimizer= optimizer,
                       loss = "binary_crossentropy", 
                       metrics = ["accuracy"])
    
    return classifier


classifier = KerasClassifier(build_fn= build_classifier,
                             batch_size = 10,
                             epochs = 100)


parameters = {"batch_size":[25,32],
              "epochs": [200],
              "optimizer": ["adam", "rmsprop"]}

grid_search = GridSearchCV(estimator = classifier,
                           param_grid = parameters,
                           scoring = "accuracy",
                           cv = 3)

grid_search = grid_search.fit(X_train, y_train)
best_param = grid_search.best_params_
best_accuracy = grid_search.best_score_
116/4:
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import GridSearchCV
from keras.models import Sequential
from keras.layers import Dense


def build_classifier(optimizer,
                     activation,
                     init):
    
    classifier = Sequential()
    classifier.add(Dense(input_dim = 11,
                         output_dim = 6,
                         init = init,
                         activation = activation))
    
    classifier.add(Dense(output_dim = 6,
                         init = init,
                         activation = activation))
    
    classifier.add(Dense(output_dim = 6,
                         init = init,
                         activation = activation))
    
    classifier.add(Dense(output_dim = 1,
                         init = init,
                         activation = "sigmoid"))    
    
    classifier.compile(optimizer= optimizer,
                       loss = "binary_crossentropy", 
                       metrics = ["accuracy"])
    
    return classifier


classifier = KerasClassifier(build_fn= build_classifier,
                             batch_size = 10,
                             epochs = 100)


parameters = {"batch_size":[16,25,32],
              "epochs": [200],
              "optimizer": ["adam", "rmsprop"],
              "activation": ["relu" , "elu"],
              "init": ["lecun_uniform", "uniform"]}

grid_search = GridSearchCV(estimator = classifier,
                           param_grid = parameters,
                           scoring = "accuracy",
                           cv = 5)

grid_search = grid_search.fit(X_train, y_train)
best_param = grid_search.best_params_
best_accuracy = grid_search.best_score_
117/1:
ar = [1,2,1,2,1,3,2]

ar_unique = set(ar)
117/2: ar_unique
117/3:
for i in ar_unique:
    print(i)
117/4:
for i in ar_unique:
    print(ar.count(i))
117/5:
for i in ar_unique:
    print("number of {}:".format(ar.count(i)))
117/6:
for i in ar_unique:
    print("number of {}: {}:".format(i, ar.count(i)))
117/7:
for i in ar_unique:
    print("number of {} {}:".format(i, ar.count(i)))
117/8:
for i in ar_unique:
    print("number of {}: {}".format(i, ar.count(i)))
117/9:
no_of_socks = {}

for i in ar_unique:
    print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
117/10: no_of_socks
117/11: no_of_socks.values()
117/12: no_of_socks.values() % 2
117/13: no_of_socks.values()
117/14: list(no_of_socks.values())
117/15: 3%""
117/16: 3%2
117/17: 4%2
117/18: 3/2
117/19: int(3/2)
117/20: int(5/2)
117/21: no_of_socks
117/22:
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
117/23:
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
117/24: k
117/25:
ar = [1,2,1,2,1,3,2,2]

ar_unique = set(ar)
117/26:
no_of_socks = {}

for i in ar_unique:
    print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
117/27:
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
117/28: k
117/29:
ar = [1,2,1,2,1,3,2]

ar_unique = set(ar)
117/30:
no_of_socks = {}

for i in ar_unique:
    print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
117/31:
ar = [1,2,1,2,1,3,2]
ar_unique = set(ar)
117/32: ar_unique
117/33:
for i in ar_unique:
    print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
117/34: no_of_socks
117/35:
for i in ar_unique:
    print("number of color {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
117/36:
for i in ar_unique:
    #print("number of color {}: {}".format(i, ar.count(i)))
    print(i)
    no_of_socks[i] = ar.count(i)
117/37: no_of_socks
117/38: no_of_socks = {}
117/39: no_of_socks
117/40: no_of_socks["amine"] = "sucker"
117/41: no_of_socks
117/42:
ar = [1,2,1,2,1,3,2]
ar_unique = set(ar)
117/43: ar_unique
117/44:
no_of_socks = {}

for i in ar_unique:
    #print("number of color {}: {}".format(i, ar.count(i)))
    #print(i)
    no_of_socks[i] = ar.count(i)
117/45: no_of_socks
117/46:
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
117/47: no_of_socks
117/48: no_of_socks.values()
117/49: list(no_of_socks.values())
117/50:
for i in list(no_of_socks.values()):
    print(i)
117/51:
for i in list(no_of_socks.values()):
    print(k = k + int(i/2))
117/52: 3/2
117/53: int(3/2)
117/54: int(3.7/2)
117/55: int(5/2)
117/56: int(1/2)
117/57: ar = [1,2,1,2,1,3,2]
117/58: ar = [1,2,1,2,1,3,2]
117/59:
ar_unique = set(ar)

no_of_socks = {}

for i in ar_unique:
    print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
    
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
117/60:
ar_unique = set(ar)

no_of_socks = {}

for i in ar_unique:
    print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
    
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
    
k
117/61:
ar_unique = set(ar)

no_of_socks = {}

for i in ar_unique:
    #print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
    
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
    
k
117/62: ar = [1,2,1,2,1,3,2,1]
117/63:
ar_unique = set(ar)

no_of_socks = {}

for i in ar_unique:
    #print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
    
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
    
k
117/64: ar = [1,2,1,2,1,3,2,1,3,2]
117/65:
ar_unique = set(ar)

no_of_socks = {}

for i in ar_unique:
    #print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
    
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
    
k
117/66: ar = [1,2,1,2,1,3,2]
117/67:
ar_unique = set(ar)

no_of_socks = {}

for i in ar_unique:
    #print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
    
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
    
k
117/68: 3//2
117/69: 3.7//2
117/70:
ar_unique = set(ar)

no_of_socks = {}

for i in ar_unique:
    print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
    
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
    
k
117/71:
ar_unique = set(ar)

no_of_socks = {}

for i in ar_unique:
    #print("number of {}: {}".format(i, ar.count(i)))
    no_of_socks[i] = ar.count(i)
    
k = 0

for i in list(no_of_socks.values()):
    k = k + int(i/2)
    
k
117/72:
pairs=0
    colour=set(ar)
    l=[]
    
    for colours in colour:
        
        pairs=pairs + ar.count(colours)//2
        print(pairs)
        
    return pairs
117/73: import pandas as pd
117/74: path = r"C:\Users\Cagri\Google Drive\Self Study\Deep Learning A-Z Udemy\PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)\Artificial_Neural_Networks\Churn_Modelling.csv"
117/75:
df = pd.read_csv(path)
df.head()
117/76: ar.count(1)
117/77: a = ['34', '67', '55', '33', '12', '98']
117/78:
a = ['34', '67', '55', '33', '12', '98']
a
117/79: type(a)
117/80: set(a)
117/81: tuple(a)
117/82:
class InputOutString(object):
    def __init__(self):
        self.s = ""

    def getString(self):
        self.s = raw_input()

    def printString(self):
        print self.s.upper()

strObj = InputOutString()
strObj.getString()
strObj.printString()
117/83:
class InputOutString(object):
    def __init__(self):
        self.s = ""

    def getString(self):
        self.s = raw_input()

    def printString(self):
        print(self.s.upper())

strObj = InputOutString()
strObj.getString()
strObj.printString()
117/84:
my_string = "Hello, World!"
print(my_string)
117/85: print my_string
118/1:
"""
Created on Wed Jun  5 18:55:05 2019

@author: Cagri
"""

# coding=utf8
# the above tag defines encoding for this document and is for Python 2.x compatibility

import re

regex = r"\d{2,6}"

test_str = ("text123\n"
    "1\n"
    "mhti\n"
    "lkjlj\n"
    "ljl\n"
    "111\n"
    "1111\n"
    "111111111111111111111111111111\n"
    "oh\n"
    "ohh\n"
    "ohhh\n"
    "ohhhh\n"
    "ohhhhh\n"
    "ohhhhhhhhhho\n")

matches = re.finditer(regex, test_str, re.MULTILINE)

for matchNum, match in enumerate(matches, start=1):
    
    print ("Match {matchNum} was found at {start}-{end}: {match}".format(matchNum = matchNum, start = match.start(), end = match.end(), match = match.group()))
    
    for groupNum in range(0, len(match.groups())):
        groupNum = groupNum + 1
        
        print ("Group {groupNum} found at {start}-{end}: {group}".format(groupNum = groupNum, start = match.start(groupNum), end = match.end(groupNum), group = match.group(groupNum)))


# Note: for Python 2.7 compatibility, use ur"" to prefix the regex and u"" to prefix the test string and substitution.
119/1: runfile('C:/Users/Cagri/Google Drive/Self Study/Deep Learning A-Z Udemy/PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)/Artificial_Neural_Networks/STUDY-MY SOLUTION..py', wdir='C:/Users/Cagri/Google Drive/Self Study/Deep Learning A-Z Udemy/PART 1. ARTIFICIAL NEURAL NETWORKS (ANN)/Artificial_Neural_Networks')
120/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
120/2:
import pandas as pd
df = pd.read_csv("C:\Users\Cagri\Google Drive\order_products__train.csv")
120/3:
import pandas as pd
df = pd.read_csv(r"C:\Users\Cagri\Google Drive\order_products__train.csv")
120/4: df = df.iloc[:, :2]
120/5: df.groupby("order_id")
120/6: df.groupby("order_id").count()
120/7: df.groupby("order_id").count()
120/8:
for i in df["order_id"]:
    print(i
120/9:
for i in df["order_id"]:
    print(i)
120/10:
def get_item_pairs(order_item):
    order_item = order_item.reset_index().as_matrix()
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
        
        for item_pair in combinations(item_list, 2):
            yield item_pair
120/11:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display

def get_item_pairs(order_item):
    order_item = order_item.reset_index().as_matrix()
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
        
        for item_pair in combinations(item_list, 2):
            yield item_pair
120/12: get_item_pairs(df)
120/13: df['order_id'].unique()
120/14: df["product_id"][df["order_id"] == 1]
120/15: list(df["product_id"][df["order_id"] == 1])
120/16:
for i in df['order_id'].unique():
    list_of_lists.append(list(df["product_id"][df["order_id"] == i]))
120/17:
list_of_lists = []

for i in df['order_id'].unique():
    list_of_lists.append(list(df["product_id"][df["order_id"] == i]))
120/18: result = list_of_lists
120/19:
def item_pairer(data):
  
  from itertools import combinations
  import collections
  import pandas as pd
  
  counter_list = []
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      counter_list.append(item_pair)
  
  counter = collections.Counter(counter_list) 
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
  
  df["counts"] = df["counts"].astype("int64")  
  return df


#========================================================================================================

def getSupport(column_to_be_created,
               item_count,
               order_list,
               df):
  
  no_orders = len(order_list)
  df["{}".format(column_to_be_created)] = df["{}".format(item_count)] / no_orders
  return df


#========================================================================================================

def getItems(df,
             column_to_be_splitted,
             index_of_the_item,
             column_to_be_created):
  
  df['{}'.format(column_to_be_created)] =  df["{}".format(column_to_be_splitted)].\
  apply(lambda x : x[index_of_the_item])
  
  return df


#========================================================================================================

def getFreq(df,
            column_to_be_count,
            column_to_be_created):
  
  import itertools, collections
  
  counter = collections.Counter(itertools.chain(*test_list))
  df["{}".format(column_to_be_created)] = result["{}".format(column_to_be_count)].\
  apply(lambda x: counter[x])
  
  return df


#========================================================================================================

def getConfidence(column_name_support_pair,
                  column_to_be_created,
                  confidence_from,
                  df):
  
  df["{}".format(column_to_be_created)] = df["{}".format(column_name_support_pair)] /\
  df["{}".format(confidence_from)]
  
  return df


#========================================================================================================

def getLift(column_to_be_created,
           column_name_support_pair,
           column_name_support_first,
           column_name_support_second,
           df):
  
  df["{}".format(column_to_be_created)] = df["{}".format(column_name_support_pair)] /\
  (df["{}".format(column_name_support_first)]*df["{}".format(column_name_support_second)])
  
  return df
120/20:
result = item_pairer(list_of_lists)



result = getSupport("SupportAB",
                    "counts",
                    test_list,
                    result)

result = getItems(result,
                  "item_pair",
                  0,
                 "item_A")

result = getItems(result,
                  "item_pair",
                  1,
                 "item_B")
result = getFreq(result,
                 "item_A",
                 "freqA")

result = getFreq(result,
                 "item_B",
                 "freqB")

result = getSupport("SupportA",
          "freqA",
          test_list,
          result)

result = getSupport("SupportB",
          "freqB",
          test_list,
          result)

result = getConfidence("SupportAB",
              "Confidence_A->B",
              "SupportA",
              result)

result = getConfidence("SupportAB",
              "Confidence_B->A",
              "SupportB",
              result)

result = getLift("Lift_A->B",
                "SupportAB",
                "SupportA",
                "SupportB",
                result)
121/1:
def item_pairer(data):
  
  from itertools import combinations
  import collections
  import pandas as pd
  
  counter_list = []
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      counter_list.append(item_pair)
  
  counter = collections.Counter(counter_list) 
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
  
  df["counts"] = df["counts"].astype("int64")  
  return df


#========================================================================================================

def getSupport(column_to_be_created,
               item_count,
               order_list,
               df):
  
  no_orders = len(order_list)
  df["{}".format(column_to_be_created)] = df["{}".format(item_count)] / no_orders
  return df


#========================================================================================================

def getItems(df,
             column_to_be_splitted,
             index_of_the_item,
             column_to_be_created):
  
  df['{}'.format(column_to_be_created)] =  df["{}".format(column_to_be_splitted)].\
  apply(lambda x : x[index_of_the_item])
  
  return df


#========================================================================================================

def getFreq(df,
            column_to_be_count,
            column_to_be_created):
  
  import itertools, collections
  
  counter = collections.Counter(itertools.chain(*test_list))
  df["{}".format(column_to_be_created)] = result["{}".format(column_to_be_count)].\
  apply(lambda x: counter[x])
  
  return df


#========================================================================================================

def getConfidence(column_name_support_pair,
                  column_to_be_created,
                  confidence_from,
                  df):
  
  df["{}".format(column_to_be_created)] = df["{}".format(column_name_support_pair)] /\
  df["{}".format(confidence_from)]
  
  return df


#========================================================================================================

def getLift(column_to_be_created,
           column_name_support_pair,
           column_name_support_first,
           column_name_support_second,
           df):
  
  df["{}".format(column_to_be_created)] = df["{}".format(column_name_support_pair)] /\
  (df["{}".format(column_name_support_first)]*df["{}".format(column_name_support_second)])
  
  return df
121/2:
mport pandas as pd
df = pd.read_csv(r"C:\Users\Cagri\Google Drive\order_products__train.csv")

list_of_lists = []

for i in df['order_id'].unique():
    list_of_lists.append(list(df["product_id"][df["order_id"] == i]))


result = list_of_lists


result = item_pairer(list_of_lists)



result = getSupport("SupportAB",
                    "counts",
                    test_list,
                    result)

result = getItems(result,
                  "item_pair",
                  0,
                 "item_A")

result = getItems(result,
                  "item_pair",
                  1,
                 "item_B")
result = getFreq(result,
                 "item_A",
                 "freqA")

result = getFreq(result,
                 "item_B",
                 "freqB")

result = getSupport("SupportA",
          "freqA",
          test_list,
          result)

result = getSupport("SupportB",
          "freqB",
          test_list,
          result)

result = getConfidence("SupportAB",
              "Confidence_A->B",
              "SupportA",
              result)

result = getConfidence("SupportAB",
              "Confidence_B->A",
              "SupportB",
              result)

result = getLift("Lift_A->B",
                "SupportAB",
                "SupportA",
                "SupportB",
                result)
121/3:
import pandas as pd
df = pd.read_csv(r"C:\Users\Cagri\Google Drive\order_products__train.csv")

list_of_lists = []

for i in df['order_id'].unique():
    list_of_lists.append(list(df["product_id"][df["order_id"] == i]))


result = list_of_lists


result = item_pairer(list_of_lists)



result = getSupport("SupportAB",
                    "counts",
                    test_list,
                    result)

result = getItems(result,
                  "item_pair",
                  0,
                 "item_A")

result = getItems(result,
                  "item_pair",
                  1,
                 "item_B")
result = getFreq(result,
                 "item_A",
                 "freqA")

result = getFreq(result,
                 "item_B",
                 "freqB")

result = getSupport("SupportA",
          "freqA",
          test_list,
          result)

result = getSupport("SupportB",
          "freqB",
          test_list,
          result)

result = getConfidence("SupportAB",
              "Confidence_A->B",
              "SupportA",
              result)

result = getConfidence("SupportAB",
              "Confidence_B->A",
              "SupportB",
              result)

result = getLift("Lift_A->B",
                "SupportAB",
                "SupportA",
                "SupportB",
                result)
122/1: df = pd.read_csv(r"C:\Users\Cagri\Google Drive\order_products__train.csv")
122/2:
import pandas as pd
df = pd.read_csv(r"C:\Users\Cagri\Google Drive\order_products__train.csv")
122/3: df = df.iloc[:, :2]
122/4: (df["product_id"][df["order_id"] == 1]
122/5: )
122/6: (df["product_id"][df["order_id"] == 1])
122/7:
def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv(r"{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'.unique():
        yield list(df["product_id"][df["order_id"] == i])
122/8:
def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv(r"{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
122/9: path = "C:\Users\Cagri\Google Drive\order_products__train.csv"
122/10: path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
122/11:
def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
122/12: path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
122/13: to_listoflists(path)
122/14: next(to_listoflists(path))
122/15:
def item_pairer(data):
  
  from itertools import combinations
  import collections
  import pandas as pd
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair
122/16: item_pairer(next(to_listoflists(path)))
122/17: next(item_pairer(next(to_listoflists(path))))
122/18: item_pairer(next(to_listoflists(path)))
122/19:
for i in item_pairer(next(to_listoflists(path))):
    print(i)
122/20: item_pairer(next(to_listoflists(path)))
122/21: print(item_pairer(next(to_listoflists(path))))
122/22: next(item_pairer(next(to_listoflists(path))))
122/23:
path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
122/24: netx(to_listoflists(path))
122/25:
path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
122/26: next(to_listoflists(path))
122/27: next(to_listoflists(path))
122/28:
def item_pairer(data):
  
  from itertools import combinations
  import collections
  import pandas as pd
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair
   
   counter = collections.Counter(item_pair)
122/30:
def item_pairer(data):
  
  from itertools import combinations
  import collections
  import pandas as pd
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair
  
  counter = collections.Counter(item_pair)
122/31:
def item_pairer(data):
  
  from itertools import combinations
  import collections
  import pandas as pd
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair
  
  counter = collections.Counter(item_pair)
  return counter
122/32: item_pairer(next(to_listoflists(path)))
122/33: counter = item_pairer(next(to_listoflists(path)))
122/34:
path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




def item_pairer(data):
  
  from itertools import combinations
  import collections
  import pandas as pd
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair
  
  counter = collections.Counter(next(item_pair))
  return counter
122/35: counter = item_pairer(next(to_listoflists(path)))
122/36: counter
122/37:
def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
122/38:
path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
122/39: listoflist_gen = to_listoflists(path)
122/40: listoflist_gen
122/41:
def item_pairer(data):
  
  from itertools import combinations
  import collections
  import pandas as pd

  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair
122/42: item_pairer_gen = item_pairer(listoflist_gen)
122/43: item_pairer_gen
122/44:
def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
    yield df
122/45: item_counter_gen = item_counter(item_pairer_gen)
122/46: item_counter_gen
122/47: list(item_counter_gen)
122/48:
import collections        
from itertools import combinations
import pandas as pd


path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




def item_pairer(data):
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair


def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
    yield df

#    
#  df["counts"] = df["counts"].astype("int64")  


listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(listoflist_gen)
122/49: item_counter_gen = item_counter(item_pairer_gen)
122/50: item_counter_gen
122/51: list(item_counter_gen)
122/52:
import collections        
from itertools import combinations
import pandas as pd


path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




def item_pairer(data):
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair


def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
    yield df

#    
#  df["counts"] = df["counts"].astype("int64")  


listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(listoflist_gen)
122/53: item_pairer_gen = item_pairer(test_list)
122/54:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]




def item_pairer(data):
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair


def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
    yield df

#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
122/55: item_pairer_gen
122/56: list(item_pairer_gen)
122/57:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]




def item_pairer(data):
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair


def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
    yield df

#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(item_pairer_gen)
122/58: list(item_counter_gen)
122/59: a = list(item_counter_gen)
122/60:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]




def item_pairer(data):
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair


def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
    yield df

#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(item_pairer_gen)
a = list(item_counter_gen)
122/61:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]




def item_pairer(data):
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair


def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
  yield df

#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(item_pairer_gen)
a = list(item_counter_gen)
122/62: next(item_counter_gen)
122/63:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]




def item_pairer(data):
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair


def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
  return df
122/64:
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(item_pairer_gen)
a = item_counter_gen
122/65:
import collections        
from itertools import combinations
import pandas as pd


path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




#        
#test_list = [["apple","egg","milk"],
#            ["carrot","milk"],
#            ["apple","egg","carrot"],
#            ["apple","egg"],
#            ["apple","carrot"]]
#
#


def item_pairer(data):
  
  for orders in data:
    for item_pair in combinations(orders, 2):
      yield item_pair


def item_counter(item_pairs):
  
  counter = collections.Counter(item_pairs)
  
  df = pd.DataFrame({'item_pair': [],
                     'counts': []})
  
  for k,v in counter.items():
    df = df.append({"item_pair":k,
                   "counts":v},
                  ignore_index=True)
  return df

#    
#  df["counts"] = df["counts"].astype("int64")  


listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(listoflist_gen)
item_counter_gen = item_counter(item_pairer_gen)
a = item_counter_gen
122/66: len(set(df["order_list"]))
122/67: len(set(df["order_id"]))
122/68:
def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df,item_pairs):
    
    #no of orders
    no_orders = len(set(df["order_id"]))
    
    counter = collections.Counter(item_pairs)
    return counter
122/69:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
122/70:
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(item_pairer_gen)
a = item_counter_gen
122/71:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(item_pairs):
    
    #no of orders
    #no_orders = len(set(df["order_id"]))
    
    counter = collections.Counter(item_pairs)
    return counter
122/72:
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(item_pairer_gen)
a = item_counter_gen
122/73: item_counter_gen
122/74: type(item_counter_gen)
122/75:
def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v},ignore_index=True)
        
        df["SupportAB"] = df["counts"] / no_orders
    
    return df
122/76:
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(item_pairer_gen)
a = item_counter_gen
122/77:
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/78:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v},ignore_index=True)
        
        df["SupportAB"] = df["counts"] / no_orders
    
    return df

#        df['{}'.format(column_to_be_created)] =  df["{}".format(column_to_be_splitted)].\
#        apply(lambda x : x[index_of_the_item])












#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/79: a["item_pair"]
122/80: len(a["item_pair"])
122/81: len(a["item_pair"][0])
122/82:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v},ignore_index=True)
        
        df["SupportAB"] = df["counts"] / no_orders
        
        for i in len(a["item_pair"][0]):
            df["item_{}".format(i)] =  df["item_pair"].\
            apply(lambda x : x[i])
    
    return df
122/83:
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/84:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v},ignore_index=True)
        
        df["SupportAB"] = df["counts"] / no_orders
        
        for i in range(len(a["item_pair"][0])):
            df["item_{}".format(i)] =  df["item_pair"].\
            apply(lambda x : x[i])
    
    return df











#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/85: counter = collections.Counter(itertools.chain(*test_list))
122/86: from itertools import combinations, collections
122/87:
import collections        
from itertools import combinations
import pandas as pd
122/88:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v},ignore_index=True)
        
        df["SupportAB"] = df["counts"] / no_orders
        
        for i in range(len(a["item_pair"][0])):
            df["item_{}".format(i)] =  df["item_pair"].\
            apply(lambda x : x[i])
122/89: counter = collections.Counter(itertools.chain(*test_list))
122/90: import itertools, collections
122/91: counter = collections.Counter(itertools.chain(*test_list))
122/92: counter
122/93:
import collections        
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




#        
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v},ignore_index=True)
        
        df["SupportAB"] = df["counts"] / no_orders
        
        for i in range(len(a["item_pair"][0])):
            df["item_{}".format(i)] =  df["item_pair"].\
            apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].apply(lambda x: counter[x])
    
    return df












#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/94:
def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




#        
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v},ignore_index=True)
        
        df["Support01"] = df["counts"] / no_orders
        
        for i in range(len(a["item_pair"][0])):
            df["item_{}".format(i)] =  df["item_pair"].\
            apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].apply(lambda x: counter[x])
    
    return df












#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/95:
import collections        
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




#        
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        for i in range(len(a["item_pair"][0])):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders            
            
            
            
            
            #df["{}".format(column_to_be_created)] = df["{}".format(column_name_support_pair)] /\
            #df["{}".format(confidence_from)]
    
    return df












#    
#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/96:
import collections        
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




#        
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        for i in range(len(a["item_pair"][0])):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders            
            
            if i == 0:
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            elif i == 1:
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
    
    return df
122/97:
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/98:
import collections        
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])




#        
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
#


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        for i in range(len(a["item_pair"][0])):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders            
        
        df["confidence_0->1"] = df["Support_01"] / df["support_0"]
        df["confidence_1->0"] = df["Support_01"] / df["support_1"]
        
        df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    return df


#  df["counts"] = df["counts"].astype("int64")  


#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
a = item_counter_gen
122/99: range(2)
122/100:
for i in range(2):
    print(i)
122/101:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
#
122/102:
def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        for i in range(2):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders            
        
        df["confidence_0->1"] = df["Support_01"] / df["support_0"]
        df["confidence_1->0"] = df["Support_01"] / df["support_1"]
        
        df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    return df




path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

#listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen)
df = item_counter_gen
122/103:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        for item_pair in combinations(orders, 2):
            yield item_pair


def item_counter(df, item_pairs):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    #return counter
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        for i in range(2):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders            
        
        df["confidence_0->1"] = df["Support_01"] / df["support_0"]
        df["confidence_1->0"] = df["Support_01"] / df["support_1"]
        
        df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    return df




path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(listoflist_gen)
item_counter_gen = item_counter(test_list, item_pairer_gen)
df = item_counter_gen

t1 = time.time()
total = t1-t0
124/1:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

def to_listoflists(path):
    import pandas as pd
    df = pd.read_csv("{}".format(path))
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        if df[df["Support_01"] >= min_support] :
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df




path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"

listoflist_gen = to_listoflists(path)
item_pairer_gen = item_pairer(listoflist_gen)
item_counter_gen = item_counter(test_list, item_pairer_gen)
df = item_counter_gen

t1 = time.time()
total = t1-t0
124/2:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
124/3:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections
124/4:
def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        if df[df["Support_01"] >= min_support] :
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(listoflist_gen)
item_counter_gen = item_counter(df, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/5:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        if df[df["Support_01"] >= min_support] :
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(listoflist_gen)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/6:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections
124/7:
def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        if df[df["Support_01"] >= min_support] :
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(listoflist_gen)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/8:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
124/9:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        
        if df[df["Support_01"] >= min_support] :
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/10:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        if df["Support_01"] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0

test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
124/11:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        if (df["Support_01"] >= min_support):
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0

test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
124/12:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        if df["item_pairs"][k][Support_01] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/13:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        if df["item_pair"][k]["Support_01"] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            if df["support_1"] >= min_support and df["support_2"] >= min_support:
                
                df["confidence_0->1"] = df["Support_01"] / df["support_0"]
                df["confidence_1->0"] = df["Support_01"] / df["support_1"]
                
                df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/14:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        #if df["item_pair"][k]["Support_01"] >= min_support:
        
        for i in range(2):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
        
        if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/15:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        #if df["item_pair"][k]["Support_01"] >= min_support:
        
        for i in range(2):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
        
        #if df["support_1"] >= min_support and df["support_2"] >= min_support:
        
        df["confidence_0->1"] = df["Support_01"] / df["support_0"]
        df["confidence_1->0"] = df["Support_01"] / df["support_1"]
        
        df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/16: df["item_pair"][k]["Support_01"]
124/17: df["item_pair"][k]
124/18: df["item_pair"]
124/19: df_calc["item_pair"]
124/20: df_calc["Support_01"]
124/21: df_calc.loc[df_calc['item_pair'] == "('apple','egg')", 'Support_01']
124/22: df_calc.loc[df_calc['item_pair'] == ('apple','egg'), 'Support_01']
124/23:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
124/24:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        if df.loc[df['item_pair'] == k, 'Support_01'] >= min_support:
        
        for i in range(2):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
        
        #if df["support_1"] >= min_support and df["support_2"] >= min_support:
        
        df["confidence_0->1"] = df["Support_01"] / df["support_0"]
        df["confidence_1->0"] = df["Support_01"] / df["support_1"]
        
        df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/25:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        if df.loc[df['item_pair'] == k, 'Support_01'] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/26: df_calc.loc[df_calc['item_pair'] == ('apple','egg'), 'Support_01']
124/27: df_calc.loc[df_calc['item_pair'] == ('apple','egg'), 'Support_01'][1]
124/28: df_calc.loc[df_calc['item_pair'] == ('apple','egg'), 'Support_01'][0]
124/29:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        if df.loc[df['item_pair'] == k, 'Support_01'][0] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/30: df_calc.loc[df_calc['item_pair'] == ('apple','egg'), 'Support_01'][1]
124/31: df_calc.loc[df_calc['item_pair'] == ('apple','egg'), 'Support_01'][0]
124/32:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        temp_test = df["Support_01"]
        if temp_test >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc = item_counter_gen

t1 = time.time()
total = t1-t0
124/33:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        temp_test = df["Support_01"]
        #if temp_test >= min_support:
        
        for i in range(2):
            df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
            
            counter = collections.Counter(itertools.chain(*test_list))
            df["freq_{}".format(i)] = df["item_{}".format(i)].\
            apply(lambda x: counter[x])
            
            df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
        
        #if df["support_1"] >= min_support and df["support_2"] >= min_support:
        
        df["confidence_0->1"] = df["Support_01"] / df["support_0"]
        df["confidence_1->0"] = df["Support_01"] / df["support_1"]
        
        df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
124/34: temp_test
124/35: temp_test[0]
124/36:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        index = 0
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        temp_test = df["Support_01"]
        if temp_test[0] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
            index = index+1
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.01)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
124/37:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        index = 0
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        temp_test = df["Support_01"]
        if temp_test[0] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
            index = index+1
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.3)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
125/1:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        index = 0
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        temp_test = df["Support_01"]
        
        if temp_test[0] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
            index = index + 1
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.3)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
126/1:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]

import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        index = 0
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        temp_test = df["Support_01"]
        
        if temp_test[0] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
            index = index + 1
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.3)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
126/2:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]

import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        index = 0
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        print(df["Support_01"])
        temp_test = df["Support_01"]
        
        if temp_test[0] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
            index = index + 1
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.3)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
126/3:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        index = 0
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        temp_test = df["Support_01"]
        
        
        if temp_test[index] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
            index = index + 1
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.3)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
126/4:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        index = 0
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        print(df["Support_01"])
        temp_test = df["Support_01"]
        print("\n\n{}\n\n".format(temp_test[index]))
        
        
        if temp_test[index] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
            index = index + 1
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.3)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
126/5: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/6:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]

import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\order_products__train.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])


def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        index = 0
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        print(df["Support_01"])
        temp_test = df["Support_01"]
        index = index + 1
        print("\n\n{}\n\n".format(temp_test[index]))
        
        
        if temp_test[index] >= min_support:
            
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                counter = collections.Counter(itertools.chain(*test_list))
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            #if df["support_1"] >= min_support and df["support_2"] >= min_support:
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
    
    
    
    return df, temp_test





#listoflist_gen = to_listoflists(test_list)
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(test_list, item_pairer_gen, 0.3)
df_calc, temp_test = item_counter_gen

t1 = time.time()
total = t1-t0
126/7: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/8: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/9: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/10: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/11: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/12: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/13: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/14: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
126/15: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
127/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
127/2: temp_test[-1]
127/3: temp_test.iloc[-1]
127/4: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
127/5: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
128/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
129/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
129/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
130/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
131/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
131/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
132/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
132/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
133/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
134/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
135/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
135/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
135/3: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
135/4: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
135/5: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
135/6: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
135/7:
def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
135/8: listoflist_gen = to_listoflists(df)
135/9: listoflist_gen
135/10: list(listoflist_gen)
135/11: counter = collections.Counter(itertools.chain(*list(listoflist_gen)))
135/12:
def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
135/13: listoflist_gen = to_listoflists(df)
135/14: listoflist_gen
135/15: test_ list(listoflist_gen)
135/16: test= list(listoflist_gen)
135/17: counter = collections.Counter(itertools.chain(*test)))
135/18: counter = collections.Counter(itertools.chain(*test))
135/19: counter = collections.Counter(itertools.chain(*test))
136/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
136/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
136/3: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
137/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
137/2: listoflist_gen
137/3: netx(listoflist_gen)
137/4: next(listoflist_gen)
137/5: list(item_pairer_gen)
137/6: listoflist_gen
137/7: list(listoflist_gen)
138/1:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Google Drive\test.csv"
df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])
138/2: listoflist_gen = to_listoflists(df)
138/3: list(listoflist_gen)
138/4:
def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair
138/5:
count_list = list(listoflist_gen)
counter = collections.Counter(itertools.chain(*count_list))
138/6: listoflist_gen
138/7: list(listoflist_gen)
138/8: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
139/1:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Google Drive\test.csv"
df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])



def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair
139/2: listoflist_gen = to_listoflists(df)
139/3: item_pairer_gen = item_pairer(listoflist_gen)
139/4: list(item_pairer_gen)
140/1:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Google Drive\test.csv"
df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])



def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(counter, df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
    except:
        no_orders = len(df)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        #print(df["Support_01"])
        temp_test = df["Support_01"].iloc[-1]
        #print("\n\n{}\n\n".format(temp_test))
        #print(k,v)
        
        
        if temp_test >= min_support:
            #print("YES\n---------------------------")
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
        else:
            break
    
    df = df.dropna()
    return df





listoflist_gen = to_listoflists(df)
140/2:
count_list = list(listoflist_gen)
counter = collections.Counter(itertools.chain(*count_list))
140/3: list(listoflist_gen)
140/4: listoflist_gen = to_listoflists(df)
140/5: list(listoflist_gen)
140/6: list(listoflist_gen)
140/7: listoflist_gen = to_listoflists(df)
140/8: item_pairer_gen = item_pairer(listoflist_gen)
140/9: item_counter_gen = item_counter(counter, df, item_pairer_gen, 0.01)
140/10: counter
141/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
141/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
142/1:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
142/2:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Google Drive\test.csv"
df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])



def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(counter1, df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
        print(no_orders)
    except:
        no_orders = len(df)
        print(no_orders)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        #print(df["Support_01"])
        temp_test = df["Support_01"].iloc[-1]
        #print("\n\n{}\n\n".format(temp_test))
        #print(k,v)
        
        
        if temp_test >= min_support:
            #print("YES\n---------------------------")
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter1[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
        else:
            break
    
    df = df.dropna()
    return df
142/3:
count_list = list(test_list)
counter1 = collections.Counter(itertools.chain(*count_list))
142/4:
t1 = time.time()
total = t1-t0
142/5:
item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(counter1, test_list, item_pairer_gen, 0.01)
142/6: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
143/1:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]

import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

#path = r"C:\Users\Cagri\Google Drive\test.csv"
#df = pd.read_csv(path)

def to_listoflists(df):
    
    df = df.iloc[:, :2]
    for i in df['order_id'].unique():
        yield list(df["product_id"][df["order_id"] == i])



def item_pairer(data):
    
    for orders in data:
        if len(orders) >= 2:
            for item_pair in combinations(orders, 2):
                yield item_pair


def item_counter(counter1, df, item_pairs, min_support):
    
    #no of orders
    try:
        no_orders = len(set(df["order_id"]))
        print(no_orders)
    except:
        no_orders = len(df)
        print(no_orders)
    
    counter = collections.Counter(item_pairs)
    
    df = pd.DataFrame({'item_pair': [],
                       'counts': []})
    
    for k,v in counter.items():
        
        df = df.append({"item_pair":k,"counts":v}, ignore_index=True)
        
        df["Support_01"] = df["counts"] / no_orders
        #print(df["Support_01"])
        temp_test = df["Support_01"].iloc[-1]
        #print("\n\n{}\n\n".format(temp_test))
        #print(k,v)
        
        
        if temp_test >= min_support:
            #print("YES\n---------------------------")
            for i in range(2):
                df["item_{}".format(i)] =  df["item_pair"].apply(lambda x : x[i])
                
                df["freq_{}".format(i)] = df["item_{}".format(i)].\
                apply(lambda x: counter1[x])
                
                df["support_{}".format(i)] = df["freq_{}".format(i)] / no_orders
            
            df["confidence_0->1"] = df["Support_01"] / df["support_0"]
            df["confidence_1->0"] = df["Support_01"] / df["support_1"]
            
            df["lift"] = df["Support_01"]/ (df["support_1"] * df["support_0"])
        else:
            break
    
    df = df.dropna()
    return df





#listoflist_gen = to_listoflists(df)

count_list = list(test_list)
counter1 = collections.Counter(itertools.chain(*count_list))

#listoflist_gen = to_listoflists(df)

item_pairer_gen = item_pairer(test_list)
item_counter_gen = item_counter(counter1, test_list, item_pairer_gen, 0.01)


t1 = time.time()
total = t1-t0
144/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
144/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
145/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
145/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
145/3: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
145/4: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
146/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
146/2: df.to_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\test.csv")
147/1:
import time

t0 = time.time()
from itertools import combinations
import pandas as pd
import itertools, collections

path = r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\test.csv"
df = pd.read_csv(path)
147/2: del df.iloc[:,0]
147/3: del df.iloc[:,0]
147/4: df.iloc[:,0]
147/5: df.iloc[:, 0:2]
147/6: df.iloc[:, 1:3]
148/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
148/2: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
149/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
150/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
151/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule Kaggle Code.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
152/1: runfile('C:/Users/Cagri/Desktop/Association Rules/Association Rule Kaggle Code.py', wdir='C:/Users/Cagri/Desktop/Association Rules')
153/1:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
153/2:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
153/3:
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")
153/4:
item_stats = freq(orders).to_frame("freq")

#order_item standas for orders
153/5: item_stats
153/6: item_stats.head()
153/7: orders.value_counts("freq")
153/8: orders.value_counts("freq").rename_("freq")
153/9: orders.value_counts().rename_("freq")
153/10: pd.Series(Counter(iterable)).rename("freq")
153/11: pd.Series(Counter(orders)).rename("freq")
153/12:
#get the frequencies
pd.Series(Counter(orders)).rename("freq").head(5)
153/13: len(set(orders.index))
153/14: order_count = len(set(orders.index))
153/15: item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100
153/16: order_count = len(set(orders.index))
153/17: item_stats['support']  = item_stats['freq'] / order_count * 100
153/18: item_stats
153/19: item_stats.head()
153/20: order_item = item_stats.reset_index().as_matrix()
153/21: order_item
153/22: order_item = item_stats.reset_index().values()
153/23: order_item = item_stats.reset_index().values
153/24: order_item
153/25:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    print(key)
153/26:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    print(group)
153/27:
from itertools import groupby

empty_list = []
things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    empty_list.append(group)
153/28: empty_list
153/29: empty_list[0]
153/30: list(empty_list[0])
153/31: list(empty_list[1])
153/32: list(empty_list[2])
153/33:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print "A %s is a %s." % (thing[1], key)
    print " "
153/34:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print("A %s is a %s." % (thing[1], key))
    print()" ")
153/35:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print("A %s is a %s." % (thing[1], key))
    print(" ")
153/36:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print(thing[0])
        #print("A %s is a %s." % (thing[1], key))
    #print(" ")
153/37:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print(thing[1])
        #print("A %s is a %s." % (thing[1], key))
    #print(" ")
153/38:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for key, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print("A %s is a %s." % (thing[1], key))
    print(" ")
153/39:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for groupby_by_this_item, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print("A %s is a %s." % (thing[1], groupby_by_this_item))
    print(" ")
153/40:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for groupby_by_this_item, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print(thing[0])
        #print("A %s is a %s." % (thing[1], groupby_by_this_item))
    #print(" ")
153/41:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for groupby_by_this_item, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print(thing[1])
        #print("A %s is a %s." % (thing[1], groupby_by_this_item))
    #print(" ")
153/42:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for groupby_by_this_item, group in groupby(things, lambda x: x[0]):
    type(group)
    for thing in group:
        print(thing[1])
        #print("A %s is a %s." % (thing[1], groupby_by_this_item))
    #print(" ")
153/43:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for groupby_by_this_item, group in groupby(things, lambda x: x[0]):
    print(type(group))
    for thing in group:
        print(thing[1])
        #print("A %s is a %s." % (thing[1], groupby_by_this_item))
    #print(" ")
153/44:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for groupby_by_this_item, group in groupby(things, lambda x: x[0]):
    for thing in group:
        print(thing[1])
        #print("A %s is a %s." % (thing[1], groupby_by_this_item))
    #print(" ")
    
#group is an iterator
153/45:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for groupby_by_this_item, group in groupby(things, lambda x: x[0]):
    
    for thing in group:
        print(thing[1], thing[0])
        #print("A %s is a %s." % (thing[1], groupby_by_this_item))
    #print(" ")
    
#group is an iterator
153/46:
from itertools import groupby

things = [("animal", "bear"), ("animal", "duck"), ("plant", "cactus"), ("vehicle", "speed boat"), ("vehicle", "school bus")]

for groupby_by_this_item, group in groupby(things, lambda x: x[0]):
    
    for thing in group:
        print(thing[1], "----" ,thing[0])
        #print("A %s is a %s." % (thing[1], groupby_by_this_item))
    #print(" ")
    
#group is an iterator
153/47: order_item.shape[0]
153/48: order_item.shape[]
153/49: order_item.shape[:]
153/50: order_item_df = pd.DataFrame(order_item)
153/51: order_item_df
153/52: order_item_df.head()
153/53: order_item.apply(lambda x: x[0])
153/54: order_item.shape[:]
153/55:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    item_list = [item[1] for item in order_object]
153/56: item_list
153/57:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    print(order_id)
    item_list = [item[1] for item in order_object]
153/58:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    #print(order_id)
    item_list = [item[1] for item in order_object]
153/59:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    #print(order_id)
    for i in order_object:
        print(i)
    item_list = [item[1] for item in order_object]
153/60:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
153/61:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
153/62:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().as_matrix()
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
153/63:
item_stats = freq(orders).to_frame("freq")

#order_item standas for orders
153/64: item_stats.head()
153/65:
#get the frequencies
pd.Series(Counter(orders)).rename("freq").head(5)
153/66: order_count = len(set(orders.index))
153/67: item_stats['support']  = item_stats['freq'] / order_count * 100
153/68: item_stats.head()
153/69: order_item = item_stats.reset_index().values
153/70:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    #print(order_id)
    item_list = [item[1] for item in order_object]
153/71: item_list
153/72:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    #print(order_id)
    item_list = [item[0] for item in order_object]
153/73: item_list
153/74:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    #print(order_id)
    item_list = [item[1] for item in order_object]
153/75:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    #print(order_id)
    item_list = [item[1] for item in order_object]
    for item_pair in combinations(item_list, 2):
        print(item_pair)
153/76:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    #print(order_id)
    item_list = [item[1] for item in order_object]
    for item_pair in combinations(item_list, 2):
        print(type(item_pair) )
153/77:
for order_id, order_object in groupby(order_item, lambda x: x[0]):
    #print(order_id)
    item_list = [item[1] for item in order_object]
    for item_pair in combinations(item_list, 2):
        print(type(item_pair))
155/1:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
155/2: from itertools import groupby, Counter
155/3:
from itertools import groupby
import Counter
155/4:
from itertools import groupby
from collections import Counter
155/5: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/6: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/7:
from itertools import groupby
from collections import Counter
import pandas as pd
155/8: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/9:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
order_item = orders.values()
155/10: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/11: order_item = orders.values
155/12: # = orders.values#
155/13:
order_item = orders.values
order_item
155/14: orders.head()
155/15:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
155/16:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
155/17: orders
155/18:
orders = orders.iloc[:,:2]
orders.head()
155/19: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv"
155/20: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/21: orders
155/22: orders.heAD()
155/23: orders.head()
155/24: orders = orders.iloc[:,:2]
155/25: orders.head()
155/26:
order_item = orders.values
order_item
155/27:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    print(groupby_by_this_item)
155/28:
from itertools import groupby
from collections import Counter
import pandas as pd
155/29: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/30: orders.head()
155/31: orders = orders.iloc[:,:2]
155/32:
order_item = orders.values
order_item
155/33:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    print(groupby_by_this_item)
155/34:
test_list = [["apple","egg","milk"],
            ["carrot","milk"],
            ["apple","egg","carrot"],
            ["apple","egg"],
            ["apple","carrot"]]
155/35:
from itertools import groupby
from collections import Counter
import pandas as pd
155/36: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/37: orders.head()
155/38: orders = orders.iloc[:,:2]
155/39:
order_item = orders.values
order_item
155/40:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    print(group[0]. group[1])
155/41:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    print(group[0], group[1])
155/42:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    print(group[0])
155/43:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    print(group[1])
155/44:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    for items in group:
        print(items)
155/45:
from itertools import combinations, groupby
from collections import Counter
import pandas as pd
155/46: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/47: orders.head()
155/48: orders = orders.iloc[:,:2]
155/49:
order_item = orders.values
order_item
155/50:
def counter_obj(data):
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    item_list = [item[1] for item in items]
    
    for i in combinations(item_list,2):
        yield i
155/51:
def counter_obj(data):
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in items]
    
        for i in combinations(item_list,2):
            yield i
155/52: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
155/53: orders.head()
155/54:
def counter_obj(data):
    
    orders = orders.iloc[:,:2]
    order_item = orders.values
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in items]
    
        for i in combinations(item_list,2):
            yield i
155/55: counter_obj_gen = counter_obj(orders)
155/56: next(counter_obj_gen)
155/57:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in items]
    
        for i in combinations(item_list,2):
            yield i
155/58: counter_obj_gen = counter_obj(orders)
155/59: next(counter_obj_gen)
155/60:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
    
        for i in combinations(item_list,2):
            yield i
155/61: counter_obj_gen = counter_obj(orders)
155/62: next(counter_obj_gen)
155/63: next(counter_obj_gen)
155/64: next(counter_obj_gen)
155/65: next(counter_obj_gen)
155/66: next(counter_obj_gen)
155/67: next(counter_obj_gen)
155/68: next(counter_obj_gen)
155/69: next(counter_obj_gen)
155/70:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
    
        #for i in combinations(item_list,2):
            #yield i
155/71:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
    
    return item_list
        #for i in combinations(item_list,2):
            #yield i
155/72: counter_obj_gen = counter_obj(orders)
155/73: counter_obj_gen
155/74:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    
    list_of_lists = []
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        list_of_lists.append(item_list)
    
    return item_list
        #for i in combinations(item_list,2):
            #yield i
155/75: counter_obj_gen = counter_obj(orders)
155/76: counter_obj_gen
155/77: list_of_lists~
155/78: list_of_lists
155/79:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    
    list_of_lists = []
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        list_of_lists.append(item_list)
    
    return list_of_lists
        #for i in combinations(item_list,2):
            #yield i
155/80: counter_obj_gen = counter_obj(orders)
155/81: counter_obj_gen
155/82:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        
        for item_pairs in combinations(item_list,3):
            yield item_pairs
155/83: counter_obj_gen = counter_obj(orders)
155/84: counter_obj_gen
155/85: netx(counter_obj_gen)
155/86: next(counter_obj_gen)
155/87:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        
        for item_pairs in combinations(item_list,4):
            yield item_pairs
155/88: counter_obj_gen = counter_obj(orders)
155/89: next(counter_obj_gen)
155/90:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        
        for item_pairs in combinations(item_list,10):
            yield item_pairs
155/91: counter_obj_gen = counter_obj(orders)
155/92: next(counter_obj_gen)
155/93:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    item_list = [item[1] for item in items]
    
    for i in combinations(item_list,2):
        yield i
155/94:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        
        for item_pairs in combinations(item_list,2):
            yield item_pairs
155/95: counter_obj_gen = counter_obj(orders)
155/96: next(counter_obj_gen)
155/97:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        
        for item_pairs in combinations(item_list,2):
            yield item_pairs
155/98: counter_obj_gen = counter_obj(orders)
155/99: next(counter_obj_gen)
155/100:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        list_of_lists.append(item_list)
    
    return list_of_lists
        #for i in combinations(item_list,2):
            #yield i
155/101: counter_obj_gen = counter_obj(orders)
155/102:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    list_of_lists= []
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        list_of_lists.append(item_list)
    
    return list_of_lists
        #for i in combinations(item_list,2):
            #yield i
155/103: counter_obj_gen = counter_obj(orders)
155/104: counter_obj_gen
157/1:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
157/2:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
157/3:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().as_matrix()
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
157/4:
item_stats = freq(orders).to_frame("freq")

#order_item standas for orders
157/5: item_stats.head()
157/6:
#get the frequencies
pd.Series(Counter(orders)).rename("freq").head(5)
158/1:
from itertools import combinations, groupby
from collections import Counter
import pandas as pd
158/2: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
158/3: orders.head()
158/4:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    list_of_lists= []
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
        list_of_lists.append(item_list)
    
    return list_of_lists
        #for i in combinations(item_list,2):
            #yield i
158/5: counter_obj_gen = counter_obj(orders)
158/6: counter_obj_gen
159/1:
from itertools import combinations, groupby
from collections import Counter
import pandas as pd
159/2: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
159/3: orders.head()
159/4:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
    
    #return list_of_lists
        for i in combinations(item_list,2):
            yield i
159/5:
def counter_obj(data):
    
    data = data.iloc[:,:2]
    order_item = data.values
    for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in group]
    
    #return list_of_lists
        for i in combinations(item_list,2):
            yield i
159/6: counter_obj_gen = counter_obj(orders)
159/7: counter_obj_gen
159/8: next(counter_obj_gen)
159/9: next(counter_obj_gen)
159/10:
for groupby_by_this_item, group in groupby(order_item, lambda x: x[0]):
    item_list = [item[1] for item in items]
    
    for i in combinations(item_list,2):
        yield i
159/11: next(counter_obj_gen)
159/12: next(counter_obj_gen)
159/13: next(counter_obj_gen)
159/14: next(counter_obj_gen)
159/15: next(counter_obj_gen)
159/16: next(counter_obj_gen)
159/17: next(counter_obj_gen)
159/18: next(counter_obj_gen)
159/19: list(counter_obj_gen)
159/20: list(counter_obj_gen)
161/1: a = 2
161/2: type(a)
161/3: a = 2.5
161/4: type(a)
161/5: type(a)
162/1: a = (1,2)
162/2: type(a)
162/3: a = "Hello"
162/4: a[0]
162/5: a[1]
162/6: a[::2]
162/7: a[-1]
162/8: a[-3]
162/9: a[-1]
162/10: a[:-1]
162/11: a[0:]
162/12: a[1:]
162/13: a = "hello"
162/14: a[::2]
162/15:
a = "hello"
b= "world"
162/16: a+b
162/17: a = ["h","e","l","l","o"]
162/18: from collections import Counter
162/19: counter(a)
162/20: Counter(a)
162/21: type(Counter(a))
162/22: Counter(a)
162/23: a = Counter(a)
162/24: a = ["h","e","l","l","o"]
162/25: from collections import Counter
162/26: b = Counter(a)
162/27: b["l"]
162/28: b["h"]
162/29: b
162/30: b["l"]
162/31:
a = ["h","e","l","l","o"]
a.count("l")
162/32: a = ["h","e","l","l","o"]
162/33: print(b)
162/34: print("this is acounter object %".format(b))
162/35: print("this is acounter object {}".format(b))
162/36: print("this is acounter object {}".format(a))
162/37: print("this is acounter object {}".format(b))
162/38: a = ["h","e","l","l","l","o"]
162/39: from collections import Counter
162/40: b = Counter(a)
162/41: b
162/42: b["l"]
162/43: print("this is acounter object {}".format(b))
162/44: print("this is acounter object {} {}".format(a,b))
162/45: print("this is acounter object {1} {0}".format(a,b))
162/46: a = ["h","e","l","l","l","o"]
162/47: c = ["kayahan"]
162/48: a+c
162/49: a.append(c)
162/50:
a.append(c)
a
162/51: a = ["h","e","l","l","l","o"]
162/52: c = ["kayahan"]
162/53:
a.append(c)
a
162/54: iter(a )
162/55: iter(a)
162/56: list(iter(a))
162/57: list(iter(a))
162/58: list(iter(a))
162/59: my_dict = {}
162/60:
my_dict = {}
for i in range(2):
    my_dict[i] = i*2
162/61: my_dict
162/62:
my_dict = {}
for i in range(5):
    my_dict[i] = i*2
162/63: my_dict
162/64:
my_dict = {}
for i in range(5):
    my_dict[i] = i**2
162/65: my_dict
162/66:
my_dict = {}
for i in range(5):
    #my_dict[i] = i**2
162/67:
my_dict = {}
for i in range(5):
    #my_dict[i] = i**2
162/68:
my_dict = {}
for i in range(5):
162/69:
my_dict = {}
for i in range(5):
    print(i
    #my_dict[i] = i**2
162/70:
my_dict = {}
for i in range(5):
    print(i
162/71:
my_dict = {}
for i in range(5):
    print(i)
    #my_dict[i] = i**2
162/72:
my_dict={"kayahan":"gizem",
        "cagri":"alina",
        "atalay":"mine",
        "selo": "sag el"}
162/73: my_dict.keys(*)
162/74: my_dict.keys()
162/75: my_dict.values()
162/76: my_dict["kayahn"]
162/77: my_dict["kayahan"]
162/78: my_dict.items()
162/79: my_dict
162/80: type(my_dict.items())
162/81: type(my_dict)
162/82: my_dict.items()
162/83: my_dict
162/84: a = ["h","e","l","l","l","o"]
162/85: set(a)
162/86: len(set(a))
162/87: count(set(a))
162/88: a = ["h","e","l","l","l","o"].count("l")
162/89:
a = ["h","e","l","l","l","o"].count("l")
a
162/90: a = ["h","e","l","l","l","o"]
162/91: count(set(a))
162/92: set(a).count()
162/93: set(a).count("l")
162/94: set(a)
162/95: ["h","e","l","l","l","o"].count("l")
162/96: a = ["h","e","l","l","l","o"].count("l")
162/97:
a = ["h","e","l","l","l","o"].count("l")
a
162/98:
a = ["h","e","l","l","l","o"]
a
b
c
162/99:
a = ["h","e","l","l","l","o"]
a
b
162/100:
a = ["h","e","l","l","l","o"]
a
162/101: a = ["h","e","l","l","l","o"]
162/102:
a = ["h","e","l","l","l","o"]
a
162/103: a = ["h","e","l","l","l","o"]
162/104:
for eleman in a:
    print(eleman)
162/105:
for yarrak in a:
    print(yarrak)
162/106:
for asd in a:
    print(asd)
162/107:
for asd in b:
    print(asd)
162/108:
for asd,tre in b:
    print(asd,tre)
162/109:
for asd in b:
    print(ab)
162/110:
for letter in "kayahan":
    print(letter)
162/111: list2 = [("kayahan","gizem"),("cagri","alina",),("selo","sag el")]
162/112:
for i in list2:
    print(i)
162/113: list2 = [("kayahan","gizem"),("cagri","alina"),("selo","sag el")]
162/114:
for i in list2:
    print(i)
162/115:
for i in list2:
    for j in i:
        print(j)
162/116:
for i,j in list2:
    print(j)
162/117: test = [2,3,6,6,5]
162/118: max(test)
162/119: max(test<6)
162/120: max_list = max(test)
162/121: max_list
162/122: test.pop(max_list)
162/123: test.index(max_list)
162/124: max_list_index = test.index(max_list)
162/125: test.pop(max_list_index)
162/126: test
162/127: max_list_index = test.index(max_list)
162/128: max_list_index
162/129: test.pop(max_list_index)
162/130: test
162/131: max(test)
162/132: set(test)
162/133: test = [2,3,6,6,5]
162/134: set(test)
162/135: test = [2,3,6,6,5]
162/136: set(test)
162/137: test_unique = set(test)
162/138: test_unique.index(max(test))
162/139: test_unique
162/140: list(test_unique)
162/141: test_unique= list(test_unique)
162/142: test_unique.index(max(test))
162/143: maxa_index = test_unique.index(max(test))
162/144: max_index = test_unique.index(max(test))
162/145: test_unique
162/146: test.pop(max_index)
162/147: test
162/148: max_index = test_unique.index(max(test_unique))
162/149: max_index
162/150: max_index = test_unique.index(max(test_unique_list))
162/151: test = [2,3,6,6,5]
162/152: test_unique = set(test)
162/153: test_unique_list= list(test_unique)
162/154: max_index = test_unique.index(max(test_unique_list))
162/155: max_index = test_unique_list.index(max(test_unique_list))
162/156: max_index
162/157: test_unique_list.pop(max_index)
162/158: test_unique_list
162/159: max(test_unique_list)
162/160:
def yarrak(list_item):
    
    test_unique = set(list_item)
    test_unique_list= list(test_unique)
    max_index = test_unique_list.index(max(test_unique_list))
    test_unique_list.pop(max_index)
    return max(test_unique_list)
162/161: yarrak(test)
162/162: test = [2,3,6,6,11,5]
162/163: yarrak(test)
162/164: test
162/165: test = test1
162/166: test1 = test
162/167: test1
162/168: test1.append(2)
162/169: test1
162/170: test
162/171: test = [2,3,6,6,5]
162/172: test
162/173: set(test)
162/174: type(set)
162/175: type(set(test))
162/176: a = set(test)
162/177: a.append(2)
162/178: a.append("2")
162/179: list(a)
162/180: type(a)
162/181: my_list = list(a)
162/182: type(my_list~)
162/183: type(my_list)
162/184: max_list
163/1: test = [2,3,6,6,5]
163/2: test
163/3: a = set(test)
163/4: type(set(test))
163/5: my_list = list(a)
163/6: type(my_list)
163/7: max()
163/8: max(my_list)
163/9: max(my_list).pop
163/10: max(my_list)
163/11: my_list.pop(max(my_list))
163/12: my_list.pop
163/13: my_list.index(6)
163/14: my_list.pop(3)
163/15: max(my_list)
163/16: max(my_list.index())
163/17: max(my_list.index(0))
163/18: max(my_list.index(1))
163/19: my_list.index(max)
163/20: my_list.index(max(my_list))
163/21: test = [2,3,6,6,5]
163/22: test
163/23: a = set(test)
163/24: type(set(test))
163/25: my_list = list(a)
163/26: type(my_list)
163/27: my_list.index(max(my_list))
163/28: my_list.pop(3)
163/29: max(my_list)
163/30: def getRunnerup()
163/31:
def getRunnerup()

test = [2,3,6,6,5]
set(test)
163/32:
def getRunnerup()

test = [2,3,6,6,5]
max(test)
163/33: set(test)
163/34: my_list = set(test)
163/35: my_list
163/36: list(my_list)
163/37: max(my_list)
163/38: my_list.pop(my_list.index(max(my_list))
163/39: my_list.pop(my_list.index(max(my_list)))
163/40: my_list = set(test)
163/41: max(set_unique_items)
163/42:
#get the list
test = [2,3,6,6,5]
163/43: max(set_unique_items)
163/44:
#Get the uniq items from the list above
set_unique_items = set(test)
163/45:
#Changing set to list so that we can use functions (max etc.)
list(set_unique_items)
163/46: max(set_unique_items)
163/47:
#find max value
set_unique_items.index(max(set_unique_items))
163/48: type(set_unique_items)
163/49: #find max value
163/50:
#find max value
max(list_unique_items)
163/51:
#Changing set to list and assigning a varibale , so that we can use functions (max etc.)
list_unique_items = list(set_unique_items)
165/1:
#get the list
test = [2,3,6,6,5]
165/2:
#Get the uniq items from the list above
set_unique_items = set(test)
165/3:
#find max value
max(list_unique_items)
165/4:
#Changing set to list and assigning a varibale , so that we can use functions (max etc.)
list_unique_items = list(set_unique_items)
165/5:
#find max value
max(list_unique_items)
165/6: my_list.pop(3)
165/7:
#get the list
test = [2,3,6,6,5]
166/1:
#get the list
test = [2,3,6,6,5]
166/2:
#Get the uniq items from the list above
set_unique_items = set(test)
166/3:
#Changing set to list and assigning a varibale , so that we can use functions (max etc.)
list_unique_items = list(set_unique_items)
166/4:
#find max value
max(list_unique_items)
166/5:
#find max value and assign a variable
max_value = max(list_unique_items)
166/6: #find the index of the max value
166/7: list_unique_items.index(max_value)
166/8:
#find the index of the max value
list_unique_items.index(max_value)
166/9:
#find the index of the max value and assign a variable
max_value_index = list_unique_items.index(max_value)
166/10:
#find the index of the max value and assign a variable
max_value_index = list_unique_items.index(max_value)
166/11:
#find the index of the max value and assign a variable
max_value_index = list_unique_items.index(max_value)
max_value_index
166/12: #pop max value variable's index
166/13:
#pop max value variable's index 
list_unique_items.pop(max_value_index)
166/14: #find runner up after popping max value
166/15:
#find runner up after popping max value
max(test)
166/16:
#find runner up after popping max value
max(list_unique_items)
166/17:
#get the list
test = [2,3,6,6,5,7]
166/18:
#Get the uniq items from the list above
set_unique_items = set(test)
166/19:
#Changing set to list and assigning a varibale , so that we can use functions (max etc.)
list_unique_items = list(set_unique_items)
166/20:
#find max value and assign a variable
max_value = max(list_unique_items)
166/21:
#find the index of the max value and assign a variable
max_value_index = list_unique_items.index(max_value)
166/22:
#pop max value variable's index 
list_unique_items.pop(max_value_index)
166/23:
#find runner up after popping max value
max(list_unique_items)
166/24:
def getRunnerup(test):
    

    
    #Get the uniq items from the list above
    set_unique_items = set(test)
    
    #Changing set to list and assigning a varibale , so that we can use functions (max etc.)
    list_unique_items = list(set_unique_items)
    
    #find max value and assign a variable
    max_value = max(list_unique_items)
    
    #find the index of the max value and assign a variable
    max_value_index = list_unique_items.index(max_value)
    
    #pop max value variable's index 
    list_unique_items.pop(max_value_index)
    
    #find runner up after popping max value
    return max(list_unique_items)
166/25: getRunnerup
166/26:
#get the list
test = [2,3,11,6,5,7]
166/27: getRunnerup(test)
166/28:
#get the list
test = [2,3,11,9,5,7]
166/29: getRunnerup(test)
166/30:
if n % 2 > 0
print(wierd)
166/31:
if n % 2 > 0
    wierd
    else: 
    even
166/32:
if n % 2 > 0
       pass odd
else:
    pass even
166/33:
if n % 2 > 0
    pass 'wierd'
else 
 pass 'even'
166/34:
if n % 2 > 0 :
    pass 'wierd'
else 
 pass 'even'
166/35:
if n % 2 > 0 :
    pass 'wierd':
else 
 pass 'even'
166/36:
if n % 2 > 0 :
    pass 'wierd'
else 
 pass 'even'
166/37:
if n % 2 > 0 :
     print('wierd')
166/38: n=5
166/39:
if n % 2 > 0 :
     print('wierd')
166/40:
#
if n % 2 > 0 :
     print('wierd')
elif n % 2 == 0 and 2<n<5 : 
    print('not wierd')
166/41:
#assign variable
n=4
166/42:
#
if n % 2 > 0 :
     print('wierd')
elif n % 2 == 0 and 2<n<5 : 
    print('not wierd')
166/43:
#
if n % 2 > 0 :
     print('weird')
elif n % 2 == 0 and 2<n<5 : 
    print('not weird')
elif n%2==0 and 6<n<20 :
    print('weird')
elif: n%2==0 and n>20
    print('not weird')
166/44:
#
if n % 2 > 0 :
     print('weird')
elif n % 2 == 0 and 2<n<5 : 
    print('not weird')
elif n%2==0 and 6<n<20 :
    print('weird')
elif: n%2==0 and n>20 :
    print('not weird')
166/45:
#
if n % 2 > 0 :
     print('weird')
elif n % 2 == 0 and 2<n<5 : 
    print('not weird')
elif n%2==0 and 6<n<20 :
    print('weird')
elif n%2==0 and n>20 :
    print('not weird')
166/46:
#assign variable
n=25
166/47:
#
if n % 2 > 0 :
     print('weird')
elif n % 2 == 0 and 2<n<5 : 
    print('not weird')
elif n%2==0 and 6<n<20 :
    print('weird')
elif n%2==0 and n>20 :
    print('not weird')
166/48: n = 10
166/49: range(n)
166/50: range(10)
166/51: range(10)
166/52: range(),10)
166/53: range(0,10)
166/54: range(1,10)
166/55: b = range(1,10)
166/56: type(b)
166/57: type(n)
166/58: n = [1,2,3,4,5,6,7,8,9,10]
166/59: type(n)
166/60: type(n)
166/61:
for num in n:
    print(num)
166/62:
for num in n:
    range(n)
166/63: range(5)
166/64:
for i in range(5):
    print(i)
166/65: range(n)
166/66: for num in n:
166/67: n = 5
166/68:
for i in range(n):
    print(i)
166/69: n = 5
166/70: range(n)
166/71:
for i in range(n):
    print(i)
166/72: n = 2)
166/73: n = 20
166/74: range(n)
166/75:
for i in range(n):
    print(i)
166/76:
for i in range(n):
    print(i**2)
160/1:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
160/2:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
160/3:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
160/4:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().as_matrix()
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
160/5: freq(orders)
160/6: freq(orders).to_frame("freq")
160/7: freq(orders).to_frame("freq").heaD()
160/8: freq(orders).to_frame("freq").head()
160/9: orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
160/10: orders[orders["product_id"] > 30000]
160/11: orders[orders["product_id"] > 100000]
160/12: orders[orders["product_id"] > 50000]
160/13: orders[orders["product_id"] > 35000]
160/14: orders[orders["product_id"] > 40000]
160/15: orders[orders["product_id"] > 45000]
160/16:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
160/17: orders
160/18:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id']
160/19: orders
160/20:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
160/21: orders
160/22: freq(order_item.index).to_frame()
160/23: freq(order_item.index).to_frame("non").heaD()
160/24: freq(order_item.index).to_frame("non").hea()
160/25: freq(orders.index).to_frame("non").head()
160/26: orders.to_frame().head()
160/27:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    orders = freq(orders).to_frame("freq")
    orders["support"] = freq(orders)/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = orders[orders["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items#
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= threshold]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    return orders
160/28: association_rules(orders, 0.01)
160/29:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
160/30:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().as_matrix()
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
160/31:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    orders = freq(orders).to_frame("freq")
    orders["support"] = freq(orders)/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = orders[orders["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items#
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= threshold]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    return orders
160/32: association_rules(orders, 0.01)
160/33:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = item_stats[item_stats["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items#
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= threshold]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    return orders
160/34: association_rules(orders, 0.01)
160/35: a, b = association_rules(orders, 0.01)
160/36: a= association_rules(orders, 0.01)
160/37: a
160/38:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = item_stats[item_stats["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= 2]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Get item pairs generator
    get_item_pairs_gen = get_item_pairs(orders)
    
    # Calculate item pair frequency and support
    return item_stats
160/39: item_stats = aassociation_rules(orders, 0.01)
160/40:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = item_stats[item_stats["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= 2]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Get item pairs generator
    get_item_pairs_gen = get_item_pairs(orders)
    
    # Calculate item pair frequency and support
    return item_stats
160/41: item_stats = aassociation_rules(orders, 0.01)
160/42:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = item_stats[item_stats["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= 2]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Get item pairs generator
    get_item_pairs_gen = get_item_pairs(orders)
    
    # Calculate item pair frequency and support
    return item_stats
160/43: item_stats = association_rules(orders, 0.01)
160/44: item_stats
160/45:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = item_stats[item_stats["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= 2]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Get item pairs generator
    get_item_pairs_gen = get_item_pairs(orders)
    item_pairs = freq(get_item_pairs_gen).to_frame("freqAB")
    item_pairs["support"] = item_pairs["freqAB"]/order_count(orders)*100
    
    # Calculate item pair frequency and support
    return orders
160/46: orders = association_rules(orders, 0.01)
160/47: item_stats
160/48: orders
160/49: order_count(orders)
160/50:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))


    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
160/51:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))


    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    return order_item
160/52: orders = association_rules(orders, 0.01)
160/53: orders
160/54:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = item_stats[item_stats["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= 2]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Get item pairs generator
    get_item_pairs_gen = get_item_pairs(orders)
    
    # Calculate item pair frequency and support
    item_pairs = freq(get_item_pairs_gen).to_frame("freqAB")
    item_pairs["supportAB"] = item_pairs["freqAB"]/order_count(orders)*100
    
    return orders
160/55: orders = association_rules(orders, 0.01)
160/56: orders
160/57:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
160/58:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().values()
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
160/59:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = item_stats[item_stats["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= 2]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Get item pairs generator
    get_item_pairs_gen = get_item_pairs(orders)
    
    # Calculate item pair frequency and support
    item_pairs = freq(get_item_pairs_gen).to_frame("freqAB")
    item_pairs["supportAB"] = item_pairs["freqAB"]/order_count(orders)*100
    
    return orders
160/60: orders = association_rules(orders, 0.01)
160/61:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().values
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
160/62:
def association_rules(orders, threshold):
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Filter from order_item items below min support 
    qualifying_items = item_stats[item_stats["support"] >= threshold].index
    orders = orders[orders.isin(qualifying_items)]
    
    # Filter from order_item orders with less than 2 items
    order_size = freq(orders.index)
    qualifying_orders = order_size[order_size >= 2]
    orders = orders[orders.index.isin(qualifying_orders)]
    
    # Calculate item frequency and support    
    item_stats = freq(orders).to_frame("freq")
    item_stats["support"] = item_stats["freq"]/order_count(orders)*100
    
    # Get item pairs generator
    get_item_pairs_gen = get_item_pairs(orders)
    
    # Calculate item pair frequency and support
    item_pairs = freq(get_item_pairs_gen).to_frame("freqAB")
    item_pairs["supportAB"] = item_pairs["freqAB"]/order_count(orders)*100
    
    return orders
160/63: orders = association_rules(orders, 0.01)
160/64: orders
160/65:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
160/66: orders.shape[]
160/67: orders.shape[:]
160/68:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().values
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
160/69:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    return order_item
160/70: orders = association_rules(orders, 0.01)
167/1:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
167/2:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
167/3:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items {}:".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    return order_item
167/4: orders = association_rules(orders, 0.01)
167/5:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().values
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
167/6:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items {}:".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    return order_item
167/7: orders = association_rules(orders, 0.01)
167/8:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items: {:15d}".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    return order_item
167/9: orders = association_rules(orders, 0.01)
167/10:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items: {:40d}".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    return order_item
167/11: orders = association_rules(orders, 0.01)
167/12:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items: {:34d}".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    return order_item
167/13: orders = association_rules(orders, 0.01)
167/14:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items: {:32d}".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    return order_item
167/15: orders = association_rules(orders, 0.01)
167/16:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
168/1:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
168/2:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
168/3:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
168/4: orders.shape[:]
168/5: orders.to_frame().head()
168/6:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().values
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
168/7: freq(orders).to_frame("freq").head()
168/8:
item_stats = freq(orders).to_frame("freq")

#order_item standas for orders
168/9: item_stats.head()
168/10: order_count = len(set(orders.index))
168/11: item_stats['support']  = item_stats['freq'] / order_count * 100
168/12: item_stats.head()
168/13: order_item = item_stats.reset_index().values
168/14:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items: {:32d}".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    
    # Filter from item_pairs those below min support
    item_pairs = item_pairs[item_pairs["supportAB"] >= threshold]
    
    return item_pairs
168/15: orders = association_rules(orders, 0.01)
168/16:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
168/17:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items: {:32d}".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    
    # Filter from item_pairs those below min support
    item_pairs = item_pairs[item_pairs["supportAB"] >= threshold]
    
    return item_pairs
168/18: orders = association_rules(orders, 0.01)
169/1:
import pandas as pd
import numpy as np
import sys
from itertools import combinations, groupby
from collections import Counter
from IPython.display import display
169/2:
orders = pd.read_csv(r"C:\Users\Cagri\Desktop\Association Rules\instacart_2017_05_01\order_products__prior.csv")
orders = orders.set_index('order_id')['product_id'].rename('item_id')
169/3:
# Returns frequency counts for items and item pairs
def freq(iterable):
    if type(iterable) == pd.core.series.Series:
        return iterable.value_counts().rename("freq")
    else: 
        return pd.Series(Counter(iterable)).rename("freq")

# Returns number of unique orders
def order_count(order_item):
    return len(set(order_item.index))

# Returns generator that yields item pairs, one at a time
def get_item_pairs(order_item):
    order_item = order_item.reset_index().values
    for order_id, order_object in groupby(order_item, lambda x: x[0]):
        item_list = [item[1] for item in order_object]
              
        for item_pair in combinations(item_list, 2):
            yield item_pair
169/4:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items: {:32d}".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    
    # Filter from item_pairs those below min support
    item_pairs = item_pairs[item_pairs["supportAB"] >= threshold]
    
    return item_pairs
169/5: orders = association_rules(orders, 0.01)
169/6:
def association_rules(order_item, min_support):

    print("Starting order_item: {:22d}".format(len(order_item)))

    # Calculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Filter from order_item items below min support 
    qualifying_items       = item_stats[item_stats['support'] >= min_support].index
    order_item             = order_item[order_item.isin(qualifying_items)]

    print("Items with support >= {}: {:15d}".format(min_support, len(qualifying_items)))
    print("All items: {:32d}".format(len(item_stats.index)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Filter from order_item orders with less than 2 items
    order_size             = freq(order_item.index)
    qualifying_orders      = order_size[order_size >= 2].index
    order_item             = order_item[order_item.index.isin(qualifying_orders)]

    print("Remaining orders with 2+ items: {:11d}".format(len(qualifying_orders)))
    print("Remaining order_item: {:21d}".format(len(order_item)))


    # Recalculate item frequency and support
    item_stats             = freq(order_item).to_frame("freq")
    item_stats['support']  = item_stats['freq'] / order_count(order_item) * 100


    # Get item pairs generator
    item_pair_gen          = get_item_pairs(order_item)


    # Calculate item pair frequency and support
    item_pairs              = freq(item_pair_gen).to_frame("freqAB")
    item_pairs['supportAB'] = item_pairs['freqAB'] / len(qualifying_orders) * 100
    
    
    # Filter from item_pairs those below min support
    item_pairs = item_pairs[item_pairs["supportAB"] >= min_support]
    
    return item_pairs
169/7: orders = association_rules(orders, 0.01)
169/8: orders
169/9: orders.index(1)
169/10: orders.index()[0]
169/11: orders.index.get_level_values(0)
169/12:
"-".join(orders.index.get_level_values(0),
         orders.index.get_level_values(1))
169/13: "-".join(df.index.get_level_values(i) for i in range(2))
169/14: "-".join(orders.index.get_level_values(i) for i in range(2))
169/15: "-".join(orders.get_level_values(i) for i in range(2))
169/16: "-".join(orders.get_level_values(i) for i in range(2))
169/17: "-".join(orders.index.get_level_values(i) for i in range(2))
169/18: "-".join(orders.index.get_level_values(str(i)) for i in range(2))
169/19: orders
169/20: orders.index()
169/21: orders.get_level_values(0)
169/22: orders.index.get_level_values(0)
169/23: orders.index.get_level_values(1)
169/24: orders.index.get_level_values(0)
169/25: orders.index.get_level_values(0)
169/26: orders.index.get_level_values(1)
169/27: orders.index.get_level_values(0)
169/28: list_1 = [i for i in range(2)]
169/29: list_1
169/30: "-".join(orders.index.get_level_values(i) for i in range(2))
169/31: "-".join(str(orders.index.get_level_values(i)) for i in range(2))
169/32: "-".join(str(orders.index.get_level_values(i)) for i in range(2)).to_frame("concat")
169/33: "-".join(str(orders.index.get_level_values(i)) for i in range(2))
169/34: type()"-".join(str(orders.index.get_level_values(i)) for i in range(2)))
169/35: type("-".join(str(orders.index.get_level_values(i)) for i in range(2)))
169/36: "-".join(str(orders.index.get_level_values(i)) for i in range(2))
169/37: "-".join(str(orders.index.get_level_values(i).values) for i in range(2))
169/38:
orders["items"] = orders.index.get_level_values(0).
apply(x: str(orders.index.get_level_values(0))+str(orders.index.get_level_values(1)))
169/39:
orders["items"] = orders.index.get_level_values(0).\
apply(x: str(orders.index.get_level_values(0))+str(orders.index.get_level_values(1)))
169/40:
orders["items"] = orders.index.get_level_values(0).\
apply(x: str(x.index.get_level_values(0))+str(x.index.get_level_values(1)))
169/41: orders["items"] = orders.index.get_level_values(0).apply(x: str(orders.index.get_level_values(0))+str(orders.index.get_level_values(1)))
169/42: orders["items"] = orders.index.get_level_values(0).apply(lambda x: str(orders.index.get_level_values(0))+str(orders.index.get_level_values(1)))
169/43: orders.index.get_level_values(0).apply(lambda x: str(orders.index.get_level_values(0))+str(orders.index.get_level_values(1)))
169/44: orders.index.get_level_values(0)
169/45: orders.index.get_level_values(0).to_frame("none")
169/46: orders.index.get_level_values(0).to_frame("select").apply(lambda x: str(orders.index.get_level_values(0))+str(orders.index.get_level_values(1)))
169/47: orders
169/48: orders.reset_index()
172/1:
v1 = np.array([ 2,  4, -3 ])
v2 = np.array([ 0, -3, -3 ])
v3 = np.array([ 1,  8, -9 ])
172/2: import numpy as np
172/3:
v1 = np.array([ 2,  4, -3 ])
v2 = np.array([ 0, -3, -3 ])
v3 = np.array([ 1,  8, -9 ])
172/4:
print(np.transpose(v1)(np.transpose(v2)*v3))
print(np.transpose(np.transpose(v1)*v2)*v3)
172/5: print(v1.transpose()*(v2.transpose()*v3))
172/6:
print(v1.transpose()*(v2.transpose()*v3))
print(((v1.transpose()*v2).transpose())*v3)
172/7:
result1 = v1.transpose()*(v2.transpose()*v3)
result2 = ((v1.transpose()*v2).transpose())*v3
172/8:
v1 = np.array([ 2,  4, -3, 5, 1 ])
v2 = np.array([ 0, -3, -3 ])
v3 = np.array([ 1,  8, -9 ]) 

result1 = v1.transpose()*(v2.transpose()*v3)
172/9:
v1 = np.array([ 2,  4, -3, 5, 1 ])
v2 = np.array([ 0, -3, -3 ])
v3 = np.array([ 1,  8, -9 ])
172/10: result2 = ((v1.transpose()*v2).transpose())*v3
172/11:
import numpy as np


v1 = np.array([ 2,  4, -3, 5, 1 ])
v2 = np.array([ 0, -3, -3 ])
v3 = np.array([ 1,  8, -9 ]) 

result1 = v1.transpose()*(v2.transpose()*v3)
result2 = ((v1.transpose()*v2).transpose())*v3
172/12: v1*v2=v2*v1
172/13: v1*v2==v2*v1
172/14:
v1 = np.array([ 2,  4, -3 ])
v2 = np.array([ 0, -3, -3 ])
v3 = np.array([ 1,  8, -9 ]) 

result1 = v1.transpose()*(v2.transpose()*v3)
result2 = ((v1.transpose()*v2).transpose())*v3

v1*v2==v2*v1
172/15: v1*v2==v2*v1
172/16: v1*(v2+v3) == v1*v2+v1*v3
172/17: np.random.rand(4,6)
172/18: np.random.rand(4,6)*10
172/19: np.random.randint(15, size=(4, 6))
172/20: matrix_1 = np.random.randint(15, size=(4, 6))
172/21: matrix_2 = np.random.randint(15, size=(4, 6))
172/22:
for i in matrix_1:
    print(i)
172/23: matrix_1[:][0]
172/24: matrix_1[0][:]
172/25: matrix_1[0][0]
172/26: matrix_1[1]
172/27: matrix_1[][0]
172/28: matrix_1[:,0]
172/29: matrix_1.shape
172/30: matrix_1.shape[1]
172/31: matrix_1[:,6]
172/32: dot_products = [(matrix_1[:,i]*matrix_2[:,i]) for i in range(matrix_1.shape[1]]
172/33: dot_products = [(matrix_1[:,i]*matrix_2[:,i]) for i in range(matrix_1.shape[1])]
172/34: matrix_1[:,6]*matrix_1[:,6]
172/35: matrix_1[:,5]*matrix_1[:,5]
172/36:
for i in range(matrix_1.shape[1]):
    dot_products.append(matrix_1[:,i]*matrix_2[:,i])
172/37:
matrix_1 = np.random.randint(15, size=(4, 6))
matrix_2 = np.random.randint(15, size=(4, 6))

dot_products = []

for i in range(matrix_1.shape[1]):
    dot_products.append(matrix_1[:,i]*matrix_2[:,i])
172/38: import numpy as np
172/39:
matrix_1 = np.random.randint(15, size=(4, 6))
matrix_2 = np.random.randint(15, size=(4, 6))

dot_products = []

for i in range(matrix_1.shape[1]):
    dot_products.append(matrix_1[:,i]*matrix_2[:,i])
172/40: matrix_1
172/41: matrix_2
172/42: matrix_1[:,0]*matrix_2[:,0]
172/43: dot_products = [(matrix_1[:,i].transpose()*matrix_2[:,i]) for i in range(matrix_1.shape[1])]
172/44: import numpy as np
172/45:
matrix_1 = np.random.randint(15, size=(4, 6))
matrix_2 = np.random.randint(15, size=(4, 6))
172/46: dot_products = [(matrix_1[:,i].transpose()*matrix_2[:,i]) for i in range(matrix_1.shape[1])]
172/47:
import numpy as np

matrix_1 = np.random.randint(15, size=(4, 6))
matrix_2 = np.random.randint(15, size=(4, 6))
172/48: dot_products = [np.dot(matrix_1[:,i]*matrix_2[:,i]) for i in range(matrix_1.shape[1])]
172/49: dot_products = [np.dot(matrix_1[:,i],matrix_2[:,i]) for i in range(matrix_1.shape[1])]
172/50: from numpy import linalg as LA
172/51: LA.norm(v1)
172/52: v1 = np.array([ 2,  4, -3 ])
172/53: LA.norm(v1)
172/54: v3 = np.array([ 3, 4 ])
172/55: LA.norm(v3)
172/56: np.dot(v3,v3.T)
172/57: np.arccos(np.dot(v1,v2)/ (LA.norm(v1)*LA.norm(v2)))
172/58: v2 = np.array([ 0, -3, -3 ])
172/59: np.arccos(np.dot(v1,v2)/ (LA.norm(v1)*LA.norm(v2)))
172/60:
v4 = np.array([ 16,  -2, 4 ])
v5 = np.array([ 0.5, 2, -1 ])
172/61: np.arccos(np.dot(v4,v5)/ (LA.norm(v4)*LA.norm(v5)))
172/62: np.dot(v4,v5)
172/63:
a = [ 1, -2 ]
b = [ 2,  3 ]
c = [ 0,  2 ]
172/64: np.arccos(np.dot(a,b)/ (LA.norm(a)*LA.norm(b)))
172/65: 2.08*180
172/66: np.dot(a,b)/ (LA.norm(a)*LA.norm(b))
172/67: 2.08/3.14
172/68: 0.662*180
172/69:
def getAngle(arcvalue):
    
    return (arcvalue/numpy.pi) * 180
172/70:
def getAngle(arcvalue):
    
    return (arcvalue/np.pi) * 180
172/71: getAngle(np.arccos(np.dot(a,b)/ (LA.norm(a)*LA.norm(b))))
172/72: np.arccos(np.dot((a,b),(b,c))/ (LA.norm(a,b)*LA.norm(b,c)))
172/73:
a = [ 1, -2 ]
b = [ 2,  3 ]
c = [ 0,  2 ]
172/74: np.dot(a,b)
172/75: np.dot(np.dot(a,b),np.dot(b,c))
172/76: np.dot(np.dot(a,b),np.dot(a,c))
172/77: np.dot(np.dot(a,b),np.dot(b,c))
172/78: np.dot(np.dot(a,b),np.dot(b,c))
172/79: np.dot(a,b)
172/80: np.dot(np.dot(a,b),np.dot(b,c))
172/81: np.dot(np.dot(a,b),np.dot(a,c))
172/82: np.dot(b,c)
172/83: np.dot(a,b)
172/84: np.dot(a,c)
173/1: import nump as np
173/2: import numpy as np
173/3:
v_1 = [1,4,5]
v_2 = [3,2,4]
173/4: np.outer(v_1,v_2)
173/5:
# create vectors
v1  = [ -3,  2, 5 ]
v2  = [  4, -3, 0 ]

# Python's cross-product function
v3a = np.cross( v1,v2 )
173/6:
# create vectors
v1  = [ -3,  2, 5 ]
v2  = [  4, -3, 0 ]

# Python's cross-product function
v3a = np.cross( v1,v2 )
v3a
173/7:
xx, yy = np.meshgrid(np.linspace(-10,10,10),np.linspace(-10,10,10))
z1 = (-v3a[0]*xx - v3a[1]*yy)/v3a[2]
ax.plot_surface(xx,yy,z1)

## plot the two vectors
ax.plot([0, v1[0]],[0, v1[1]],[0, v1[2]],'k')
ax.plot([0, v2[0]],[0, v2[1]],[0, v2[2]],'k')
ax.plot([0, cp[0]],[0, cp[1]],[0, cp[2]],'r')


ax.view_init(azim=150,elev=45)
plt.show()
173/8:
fig = plt.figure()
ax = fig.gca(projection='3d')

xx, yy = np.meshgrid(np.linspace(-10,10,10),np.linspace(-10,10,10))
z1 = (-v3a[0]*xx - v3a[1]*yy)/v3a[2]
ax.plot_surface(xx,yy,z1)

## plot the two vectors
ax.plot([0, v1[0]],[0, v1[1]],[0, v1[2]],'k')
ax.plot([0, v2[0]],[0, v2[1]],[0, v2[2]],'k')
ax.plot([0, cp[0]],[0, cp[1]],[0, cp[2]],'r')


ax.view_init(azim=150,elev=45)
plt.show()
173/9:
import numpy as np
import matplotlib.pyplot as plt
173/10:
# create vectors
v1  = [ -3,  2, 5 ]
v2  = [  4, -3, 0 ]

# Python's cross-product function
v3a = np.cross( v1,v2 )
v3a
173/11:
fig = plt.figure()
ax = fig.gca(projection='3d')

xx, yy = np.meshgrid(np.linspace(-10,10,10),np.linspace(-10,10,10))
z1 = (-v3a[0]*xx - v3a[1]*yy)/v3a[2]
ax.plot_surface(xx,yy,z1)

## plot the two vectors
ax.plot([0, v1[0]],[0, v1[1]],[0, v1[2]],'k')
ax.plot([0, v2[0]],[0, v2[1]],[0, v2[2]],'k')
ax.plot([0, cp[0]],[0, cp[1]],[0, cp[2]],'r')


ax.view_init(azim=150,elev=45)
plt.show()
173/12: v_1 = [1,4,5]
173/13: from numpy import linalg as LA
173/14: LA.norm
173/15: mu = 1 / LA.norm(v_1)
173/16:
mu = 1 / LA.norm(v_1)
mu
173/17: LA.norm(mu*v_1)
173/18: LA.norm(np.dot(mu,v_1))
173/19:
v_1 = [1,4,5,2]
v_2 = [3,2,4,3]
173/20:
len_v1 = LA.norm(v_1)
len_v2 = LA.norm(v_2)
173/21: np.dot(v_1,v_2)
173/22: dot_product = np.dot(v_1,v_2)
173/23:
dot_product = np.dot(v_1,v_2)
dot_product
173/24: mu_1 = 1/len_v1
173/25:
mu_1 = 1/len_v1
mu_2 = 1/len_v2
173/26: np.dot(np.dot(mu_1,v1),np.dot(mu_2,v2))
173/27: print(mu_1, mu_2)
173/28: arccos(np.dot(np.dot(mu_1,v1),np.dot(mu_2,v2)))
175/1: df_ 1 = pd.read_csv(r"C:\Users\Cagri\Desktop\KMD FULL LIST 29.06.2019.xls")
175/2: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\KMD FULL LIST 29.06.2019.xls")
175/3: import pandas as pd
175/4: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\KMD FULL LIST 29.06.2019.xls")
175/5:
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
175/6: import sys
175/7: sys.setdefaultencoding('utf-8')
175/8: import sys
175/9: sys.getdefaultencoding()
175/10: reload(sys)
175/11: sys.setdefaultencoding('utf-8')
175/12: sys.getdefaultencoding()
175/13: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\KMD FULL LIST 29.06.2019.xls")
175/14: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\KMD FULL LIST 29.06.2019.xls", encoding = "windows-1251")
175/15: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\KMD FULL LIST 29.06.2019.xls", encoding = "windows-1251")
175/16: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\KMD FULL LIST 29.06.2019.xls", encoding = "windows-1251")
175/17: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\KMD FULL LIST 29.06.2019.xls", encoding = "windows-1251")
175/18: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019.csv", encoding = "windows-1251")
175/19: df.columns
175/20: df_1.columns
175/21: df_1.columns[-1]
175/22: import numpy as np
175/23: df[~df[df_1.columns[-1]] == np.nan]
175/24: df_1[~df_1[df_1.columns[-1]] == np.nan]
175/25: df_1[df_1[df_1.columns[-1]] != np.nan]
175/26: df_1[df_1[df_1.columns[-1]] != np.nan][df_1[df_1.columns[-1]]
175/27: df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119 отчет.csv")
175/28: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019.csv", encoding = "windows-1251")
175/29: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv", encoding = "windows-1251")
175/30: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv", encoding = "windows-1251")
175/31: sys.getdefaultencoding()
177/1: import pandas as pd
177/2: df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv", encoding = "cp866")
177/3:
df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "cp855")
178/1:
df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "cp855")
178/2: import pandas as pd
178/3:
df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "cp855")
178/4:
df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
178/5: df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119 отчет.csv",encoding = "utf-8")
178/6:
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119 отчет.csv",
                   encoding = "utf-8")
178/7:
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")
178/8: list_1 = [1,2,3,4,5,6]
178/9: list_1[2:]
178/10: df_2 = df_2.iloc[2:,:]
178/11: df_2.iloc[:4,:]
178/12: df_2.iloc[:3,:]
178/13: test = df_2.iloc[:3,:]
178/14: test.apply(lambda x: "-".join(x))
178/15: test = df_2.replace(np.nan, '', regex=True)
178/16: import numpy as np
178/17: test = df_2.replace(np.nan, '', regex=True)
178/18: df_2 = df_2.replace(np.nan, '', regex=True)
178/19: test = df_2.iloc[:3,:]
178/20: xl_file = pd.ExcelFile(r"C:\Users\Cagri\Desktop\1119.xls")
178/21: import xlrd
178/22:
import sys
!{sys.executable} -m pip uninstall xlrd
179/1:
import sys
!{sys.executable} -m pip install xlrd
179/2: import xlrd
179/3:
import sys
!{sys.executable} -m pip install xlrd
179/4:
import sys
!{sys.executable} -m pip install xlrd
179/5: import xlrd
179/6: xl_file = pd.ExcelFile(r"C:\Users\Cagri\Desktop\1119.xls")
179/7: import pandas as pd
179/8: xl_file = pd.ExcelFile(r"C:\Users\Cagri\Desktop\1119.xls")
179/9: xl_file = pd.ExcelFile(r"C:\Users\Cagri\Desktop\1119.xls")
179/10: print(xl_file)
179/11: dfs = pd.read_excel(r"C:\Users\Cagri\Desktop\1119.xls", sheet_name=None)
179/12: dfs.columns
179/13: dfs[0]
179/14: dfs["TDSheet"]
179/15: df_2 = dfs["TDSheet"]
179/16: df_2.columns
179/17:
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")
179/18:
df_2 = df_2.iloc[2:,:]
df_2 = df_2.replace(np.nan, '', regex=True)
179/19: test = df_2.iloc[:3,:]
180/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")

#Delete the first 2 rows of df_2
df_2 = df_2.iloc[2:,:]
df_2 = df_2.replace(np.nan, '', regex=True)

test = df_2.iloc[:3,:]
180/2:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")

#Delete the first 2 rows of df_2
df_2 = df_2.iloc[2:,:]
df_2 = df_2.replace(np.nan, '', regex=True)

test = df_2.iloc[:3,:]
181/1:
import pandas as pd
import numpy as np
181/2:
df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
181/3:
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")
181/4:
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")
181/5:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")
181/6: df_2 = df_2.iloc[2:,:]
181/7: df_2 = df_2.replace(np.nan, '', regex=True)
181/8: test = df_2.iloc[:3,:]
182/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")
182/2: df_2.column
182/3: test = df_2.iloc[:3,:]
182/4: df_2 = df_2.replace(np.nan, '', regex=True)
182/5: test = df_2.iloc[:1,:]
182/6: test = df_2.iloc[:2,:]
182/7: test.columns
182/8:
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")
183/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")
183/2: df_2.columns
183/3: test = df_2.columns
183/4: df_2.columns
183/5: test = list(df_2.columns)
183/6: new = [i.strip() for i in test]
183/7: df_2.columns = new
184/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")


column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in test]
184/2:
column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in column_names]
184/3: "АП-3161" in df_2
184/4: "АП-3161" in df_1
184/5: test = df_2[["Позиция марки"],["№ Цеха"]]
184/6: test = df_2[["Позиция марки", "№ Цеха"]]
184/7: gb = test.groupby("Позиция марки").count
184/8: gb = test.groupby("Позиция марки").count()
184/9: df_1 = df_1.iloc[1:,:]
184/10: df_1 = df_1.iloc[1:,:-2]
184/11: df_1 = df_1.iloc[1:,:-1]
184/12:
df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
184/13: df_1 = df_1.iloc[1:,:]
184/14: df_1 = df_1.iloc[1:,:-1]
184/15: df_1 = df_1.iloc[1:,:-50]
184/16:
df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
184/17: df_1 = df_1.iloc[1:-2,:]
184/18:
df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
184/19: df_1 = df_1.iloc[1:-3,:]
184/20: product_count_2 = df_2[["Позиция марки", "№ Цеха"]]
185/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")


column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in column_names]

product_count_2 = df_2[["Позиция марки", "№ Цеха"]]
count_of_products = product_count_2.groupby("Позиция марки").count()
185/2: df_1 = df_1.iloc[1:-3,:]
185/3: df_1 = df_1[["POZ","Adet"]]
186/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")


column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in column_names]

product_count_2 = df_2[["Позиция марки", "№ Цеха"]]
count_of_products_2 = product_count_2.groupby("Позиция марки").count()




df_1 = df_1.iloc[1:-3,:]
product_count_1 = df_1[["POZ","Adet"]]
count_of_products_1 = product_count_1.groupby("POZ").count()
187/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")

#==============================================================================

df_1 = df_1.iloc[1:-3,:]
product_count_1 = df_1[["POZ","Adet"]]
count_of_products_1 = product_count_1.groupby("POZ").count()

#==============================================================================

column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in column_names]

product_count_2 = df_2[["Позиция марки", "TEMPODAN GELENLER - Отгружено заказчику - шт."]]
187/2: count_of_products_2 = product_count_2.groupby("Позиция марки").count()
187/3: product_count_2 = product_count_2.fillna(0)
187/4: product_count_2 = product_count_2.fillna(0)
187/5: product_count_2.iloc[:,1] =product_count_2.iloc[:,1].astype("int")
187/6: product_count_2.iloc[:,1] =product_count_2.iloc[:,1].astype("int64")
187/7: product_count_2.iloc[:,1]
187/8: product_count_2.iloc[:,1] =product_count_2.iloc[:,1].astype("float64")
187/9: product_count_2.iloc[:,1] =product_count_2.iloc[:,1].replace(",", "")
187/10: product_count_2 = product_count_2[:-1,:]
187/11: product_count_2 = product_count_2[:,:]
187/12: product_count_2 = product_count_2.iloc[:-1,:]
187/13: product_count_2.iloc[:,1] = product_count_2.iloc[:,1].astype("float64")
187/14: product_count_2.iloc[:,1] = product_count_2.iloc[:,1].astype("float64").astype("int64")
187/15: product_count_2.groupby('Позиция марки')['TEMPODAN GELENLER - Отгружено заказчику - шт.'].sum()
187/16: test = product_count_2.groupby('Позиция марки')['TEMPODAN GELENLER - Отгружено заказчику - шт.'].sum()
187/17:
product_count_2 = product_count_2.groupby('Позиция марки') \
['TEMPODAN GELENLER - Отгружено заказчику - шт.'].sum()
187/18: product_count_2 = product_count_2.reset_index
187/19: product_count_2 = product_count_2.reset_index(0)
187/20: product_count_2 = product_count_2.reset_index()
187/21:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")

#==============================================================================

df_1 = df_1.iloc[1:-3,:]
product_count_1 = df_1[["POZ","Adet"]]
count_of_products_1 = product_count_1.groupby("POZ").count()

#==============================================================================

column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in column_names]

product_count_2 = df_2[["Позиция марки", "TEMPODAN GELENLER - Отгружено заказчику - шт."]]
count_of_products_2 = product_count_2.groupby("Позиция марки").count()

product_count_2 = product_count_2.fillna(0)
product_count_2 = product_count_2.iloc[:-1,:]
product_count_2.iloc[:,1] = product_count_2.iloc[:,1].astype("float64").astype("int64")

product_count_2 = product_count_2.groupby('Позиция марки') \
['TEMPODAN GELENLER - Отгружено заказчику - шт.'].sum()
187/22: product_count_2 = product_count_2.reset_index()
187/23:
dict(zip(product_count_2["Позиция марки"],
         product_count_2["TEMPODAN GELENLER - Отгружено заказчику - шт."]))
187/24:
DICT_product_count_2 = dict(zip(product_count_2["Позиция марки"],
         product_count_2["TEMPODAN GELENLER - Отгружено заказчику - шт."]))
187/25: "K-5509" in DICT_product_count_2.keys(
187/26: "K-5509" in DICT_product_count_2.keys()
187/27: "K-2" in DICT_product_count_2.keys()
187/28: "K-2" in DICT_product_count_2.keys
187/29: "K-2" in list(DICT_product_count_2.keys())
187/30: list(DICT_product_count_2.keys())
187/31: "Р-2120" in list(DICT_product_count_2.keys())
187/32: product_count_1["Tempodan Gelenler"] =  product_count_1["POZ"].apply(lambda x: DICT_product_count_2[x] if x in list(DICT_product_count_2.keys()) else 0)
187/33: df_1["Tempodan Gelener"]
187/34: df_1["Tempodan Gelener"] = product_count_1["Tempodan Gelenler"]
187/35: df_1.to_csv(r"C:\Users\Cagri\Desktop\Semih\output.csv")
187/36: df_1.to_csv(r"C:\Users\Cagri\Desktop\Semih\output.csv", encoding="utf-8")
187/37: df_1.iloc[:,:-1].to_csv(r"C:\Users\Cagri\Desktop\Semih\output.csv", encoding="utf-8")
187/38: df_1.iloc[:,:-1].to_csv(r"C:\Users\Cagri\Desktop\Semih\output.csv", encoding="utf-8-sig")
187/39: product_count_1 = product_count_1.reset_index()
188/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")

#==============================================================================

df_1 = df_1.iloc[1:-3,:]
product_count_1 = df_1[["POZ","Adet"]]
count_of_products_1 = product_count_1.groupby("POZ").count()

#==============================================================================

column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in column_names]

product_count_2 = df_2[["Позиция марки", "TEMPODAN GELENLER - Отгружено заказчику - шт."]]
count_of_products_2 = product_count_2.groupby("Позиция марки").count()

product_count_2 = product_count_2.fillna(0)
product_count_2 = product_count_2.iloc[:-1,:]
product_count_2.iloc[:,1] = product_count_2.iloc[:,1].astype("float64").astype("int64")

product_count_2 = product_count_2.groupby('Позиция марки') \
['TEMPODAN GELENLER - Отгружено заказчику - шт.'].sum()

product_count_2 = product_count_2.reset_index()

DICT_product_count_2 = dict(zip(product_count_2["Позиция марки"],
         product_count_2["TEMPODAN GELENLER - Отгружено заказчику - шт."]))

product_count_1["Tempodan Gelenler"] =  product_count_1["POZ"]. \
apply(lambda x: DICT_product_count_2[x] if x in list(DICT_product_count_2.keys()) else 0)
188/2: count_of_products_1 = count_of_products_1.reset_index()
188/3:
DICT_count_of_products_1 = dict(zip(count_of_products_1["POZ"],
         count_of_products_1["ADET"]))
188/4:
count_of_products_1 = count_of_products_1.reset_index()
DICT_count_of_products_1 = dict(zip(count_of_products_1["POZ"],
         count_of_products_1["Adet"]))
188/5: product_count_1["Beklenen"] = product_count_1]["POZ"].apply(lambda x: DICT_count_of_products_1[x]])
188/6: product_count_1["Beklenen"] = product_count_1["POZ"].apply(lambda x: DICT_count_of_products_1[x]])
188/7: product_count_1["Beklenen"] = product_count_1["POZ"].apply(lambda x: DICT_count_of_products_1[x])
188/8: product_count_1["POZ"]
188/9: product_count_1["Beklenen"] = product_count_1["POZ"].apply(lambda x: DICT_count_of_products_1[x])
188/10: product_count_1["Beklenen"] = product_count_1["POZ"].apply(lambda x: DICT_count_of_products_1[x] if x in list(DICT_count_of_products_1.keys()) else 0)
188/11: product_count_1.groupby("POZ")
188/12: product_count_1.groupby("POZ").count()
189/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")

#==============================================================================

df_1 = df_1.iloc[1:-3,:]
product_count_1 = df_1[["POZ","Adet"]]
count_of_products_1 = product_count_1.groupby("POZ").count()

#==============================================================================

column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in column_names]

product_count_2 = df_2[["Позиция марки", "TEMPODAN GELENLER - Отгружено заказчику - шт."]]
count_of_products_2 = product_count_2.groupby("Позиция марки").count()

product_count_2 = product_count_2.fillna(0)
product_count_2 = product_count_2.iloc[:-1,:]
product_count_2.iloc[:,1] = product_count_2.iloc[:,1].astype("float64").astype("int64")

product_count_2 = product_count_2.groupby('Позиция марки') \
['TEMPODAN GELENLER - Отгружено заказчику - шт.'].sum()

product_count_2 = product_count_2.reset_index()

DICT_product_count_2 = dict(zip(product_count_2["Позиция марки"],
         product_count_2["TEMPODAN GELENLER - Отгружено заказчику - шт."]))

product_count_1["Tempodan Gelenler"] =  product_count_1["POZ"]. \
apply(lambda x: DICT_product_count_2[x] if x in list(DICT_product_count_2.keys()) else 0)


count_of_products_1 = count_of_products_1.reset_index()
DICT_count_of_products_1 = dict(zip(count_of_products_1["POZ"],
         count_of_products_1["Adet"]))
189/2: product_count_1.groupby("POZ").count()
189/3: test  = product_count_1.groupby("POZ").count()
189/4: product_count_1["Beklenen"] = product_count_1["POZ"].apply(lambda x: DICT_count_of_products_1[x] if x in list(DICT_count_of_products_1.keys()) else 0)
189/5: df_1["Beklenen"] = product_count_1["Beklenen"]
189/6: df_1["Tempodan Gelener"] = product_count_1["Tempodan Gelenler"]
189/7: del df_1["Unnamed: 12"]
189/8: df_1.to_csv(r"C:\Users\Cagri\Desktop\Semih\output.csv", encoding="utf-8-sig")
189/9: df_1.to_csv(r"C:\Users\Cagri\Desktop\Semih\output.csv", encoding="utf-8-sig")
189/10:
def status(row):
    if row['Tempodan Gelenler'] > row['Beklenen']:
        val = "Gelen fazla"
    else:
        val = "Gelen eksik"
    return val
189/11: df_1["Karsilastirma"] = df.apply(status, axis=1)
189/12: df_1["Karsilastirma"] = df_1.apply(status, axis=1)
189/13: product_count_1["Karsilastirma"] = product_count_1.apply(status, axis=1)
189/14:
def status(row):
    if row['Tempodan Gelenler'] > row['Beklenen']:
        val = "Gelen fazla"
    elif row['Tempodan Gelenler'] == row['Beklenen']:
        val = "Esit"
    elif row['Tempodan Gelenler'] < row['Beklenen']:
        val = "Gelen eksik"
    return val


product_count_1["Karsilastirma"] = product_count_1.apply(status, axis=1)
189/15: df_1["Karsilastirma"] = product_count_1["Karsilastirma"]
190/1:
import pandas as pd
import numpy as np


df_1 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\KMD FULL LIST 29.06.2019 1.csv",
                   encoding = "utf-8")
df_2 = pd.read_csv(r"C:\Users\Cagri\Desktop\Semih\1119.csv",
                   encoding = "utf-8")

#==============================================================================

df_1 = df_1.iloc[1:-3,:]
product_count_1 = df_1[["POZ","Adet"]]
count_of_products_1 = product_count_1.groupby("POZ").count()

#==============================================================================

column_names = list(df_2.columns)
df_2.columns = [i.strip() for i in column_names]

product_count_2 = df_2[["Позиция марки", "TEMPODAN GELENLER - Отгружено заказчику - шт."]]
count_of_products_2 = product_count_2.groupby("Позиция марки").count()

product_count_2 = product_count_2.fillna(0)
product_count_2 = product_count_2.iloc[:-1,:]
product_count_2.iloc[:,1] = product_count_2.iloc[:,1].astype("float64").astype("int64")

product_count_2 = product_count_2.groupby('Позиция марки') \
['TEMPODAN GELENLER - Отгружено заказчику - шт.'].sum()

product_count_2 = product_count_2.reset_index()

DICT_product_count_2 = dict(zip(product_count_2["Позиция марки"],
         product_count_2["TEMPODAN GELENLER - Отгружено заказчику - шт."]))

product_count_1["Tempodan Gelenler"] =  product_count_1["POZ"]. \
apply(lambda x: DICT_product_count_2[x] if x in list(DICT_product_count_2.keys()) else 0)

count_of_products_1 = count_of_products_1.reset_index()
DICT_count_of_products_1 = dict(zip(count_of_products_1["POZ"],
         count_of_products_1["Adet"]))

product_count_1["Beklenen"] = product_count_1["POZ"].apply(lambda x: DICT_count_of_products_1[x] \
               if x in list(DICT_count_of_products_1.keys()) else 0)

def status(row):
    if row['Tempodan Gelenler'] > row['Beklenen']:
        val = "Gelen fazla"
    elif row['Tempodan Gelenler'] == row['Beklenen']:
        val = "Esit"
    elif row['Tempodan Gelenler'] < row['Beklenen']:
        val = "Gelen eksik"
    return val


product_count_1["Karsilastirma"] = product_count_1.apply(status, axis=1)

df_1["Tempodan Gelener"] = product_count_1["Tempodan Gelenler"]
df_1["Beklenen"] = product_count_1["Beklenen"]
df_1["Karsilastirma"] = product_count_1["Karsilastirma"]

del df_1["Unnamed: 12"]


df_1.to_csv(r"C:\Users\Cagri\Desktop\Semih\output.csv", encoding="utf-8-sig")
191/1: import numpy as np
191/2:
M1 = np.array([1,4,5],
              [2,7,6],
              [8,1,9])

M1 = np.array([6,3,1],
              [9,5,2],
              [6,1,7])
191/3:
M1 = np.array([1,4,5],
              [2,7,6],
              [8,1,9])

M2 = np.array([6,3,1],
              [9,5,2],
              [6,1,7])
191/4:
M1 = np.array([[1,4,5],
               [2,7,6],
               [8,1,9]])

M2 = np.array([[6,3,1],
               [9,5,2],
               [6,1,7]])
191/5: M1
191/6:
for i in M1:
    print(i)
191/7:
for i in M1:
    for i in j:
        print(j)
191/8:
for i in M1:
    for j in i:
        print(j)
191/9:
for i in M1:
    print(i)
191/10: MR = np.zeros(3)
191/11:
MR = np.zeros(3)
MR
191/12:
MR = np.zeros(3,3)
MR
191/13:
MR = np.zeros((3,3))
MR
191/14: M1(:,1)*M(1,:)
191/15: M1(:,1)*M2(1,:)
191/16: M1[:,1]*M2[1,:]
191/17: M1[:,0]*M2[0,:]
191/18: MR[0]
191/19:
for i in range(M1.shape[0]):
    MR[i] = M1[:,i]*M2[i,:]
191/20: MR
191/21: np.matmul(M1,M2)
191/22: M1.dot(M2
191/23: M1.dot(M2)
191/24:
M1 = np.array([[1,4,5],
               [2,7,6],
               [8,1,9]])

M2 = np.array([[6,3,1],
               [9,5,2],
               [6,1,7]])
191/25:
MR = np.zeros((3,3))
MR
191/26:
for i in range(M1.shape[0]):
    MR[i] = M1[:,i]*M2[i,:]
191/27: M1.dot(M2)
191/28: MR
191/29:
MR1 = np.zeros((3,3))
MR2 = np.zeros((3,3))
MR3 = np.zeros((3,3))
191/30:
for i in range(M1.shape[0]):
    MR1[i] = M1[:,i]*M2[0,:]
    MR2[i] = M1[:,i]*M2[1,:]
    MR3[i] = M1[:,i]*M2[2,:]
191/31: MR1
191/32:
for i in range(M1.shape[0]):
    MR[i] = M1[:,i]*M2[i,:]
191/33: MR
191/34:
for i in range(M1.shape[0]):
    MR1[i] = M1[:,i]*M2[0,:]
    MR2[i] = M1[:,i]*M2[1,:]
    MR3[i] = M1[:,i]*M2[2,:]
191/35: MR1
191/36: MR1+ MR2+ MR3
191/37: M1[:,1]
191/38:
M1 = np.array([[1,4,5],
               [2,7,6],
               [8,1,9]])

M2 = np.array([[6,3,1],
               [9,5,2],
               [6,1,7]])
191/39: M1[:,1]
191/40: M1[:,0]
191/41: M1[:,0]*6
191/42: M1[:,0]*3
191/43: M1[:,0]*3
191/44: MR = np.zeros((3,3))
191/45: MR
191/46: M1[:,0]*1
191/47:
MR[0,:] = M1[:,0]*6
MR[1,:] = M1[:,0]*3
MR[2,:] = M1[:,0]*1
191/48: MR
191/49: MR.T
191/50: M2[0,:]
191/51: M2[0,:][0]
191/52:
MR1 = np.zeros((3,3))
MR1 = np.zeros((3,3))
191/53:
MR1 = np.zeros((3,3))
MR1 = np.zeros((3,3))
191/54:
MR1 = np.zeros((3,3))
MR2 = np.zeros((3,3))
MR3 = np.zeros((3,3))
191/55:
for i in range(M1.shape[0]):
    MR1 = M1[:,0]*M2[0,:][i]
    MR2 = M1[:,1]*M2[1,:][i]
    MR3 = M1[:,2]*M2[2,:][i]
191/56: MR1
191/57:
for i in range(M1.shape[0]):
    MR1 = M1[:,0]*M2[0,:][i]
    MR2 = M1[:,1]*M2[1,:][i]
    MR3 = M1[:,2]*M2[2,:][i]
191/58: MR1
191/59: MR2
191/60: M1[:,0]*M2[0,:][0]
191/61: M1[:,0]*M2[0,:][2]
191/62: M1[:,0]*M2[0,:][0]
191/63:
for i in range(M1.shape[0]):
    MR1[i] = M1[:,0]*M2[0,:][i]
    MR2[i] = M1[:,1]*M2[1,:][i]
    MR3[i] = M1[:,2]*M2[2,:][i]
191/64:
MR1 = np.zeros((3,3))
MR2 = np.zeros((3,3))
MR3 = np.zeros((3,3))
191/65:
for i in range(M1.shape[0]):
    MR1[i] = M1[:,0]*M2[0,:][i]
    MR2[i] = M1[:,1]*M2[1,:][i]
    MR3[i] = M1[:,2]*M2[2,:][i]
191/66: MR1
194/1: import numpy as np
194/2:
M1 = np.array([[1,4,5],
               [2,7,6],
               [8,1,9]])

M2 = np.array([[6,3,1],
               [9,5,2],
               [6,1,7]])
194/3:
for i in range(M1.shape[0]):
    MR"{}".format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/4: MR"{}".format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/5:
for i in range(M1.shape[0]):
    MR+"{}".format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/6:
for i in range(M1.shape[0]):
    MR_"{}".format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/7:
for i in range(M1.shape[0]):
    MR{}.format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/8:
for i in range(M1.shape[0]):
    MR('{}').format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/9:
for i in range(M1.shape[0]):
    MR'{}'.format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/10:
for i in range(M1.shape[0]):
    MR+str(i+1)[i] = M1[:,i]*M2[i,:][i]
194/11:
for i in range(M1.shape[0]):
    'MR{}'.format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/12:
for i in range(M1.shape[0]):
    MR'{}'.format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/13:
for i in range(M1.shape[0]):
    MR_str(i+1)[i] = M1[:,i]*M2[i,:][i]
194/14:
for i in range(M1.shape[0]):
    MR+str(i+1)[i] = M1[:,i]*M2[i,:][i]
194/15:
for i in range(M1.shape[0]):
    MR'{}'.format(i+1) = np.zeros((3,3))
    MR'{}'.format(i+1)[i] = M1[:,i]*M2[i,:][i]
194/16:
for i in range(M1.shape[0]):
    MRi = np.zeros((3,3))
    MRi[i] = M1[:,i]*M2[i,:][i]
194/17: MR1
194/18: MRi
194/19:
for i in range(M1.shape[0]):
    MR['{}'.format(i+1)] = np.zeros((3,3))
    MR['{}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/20: import numpy as np
194/21:
M1 = np.array([[1,4,5],
               [2,7,6],
               [8,1,9]])

M2 = np.array([[6,3,1],
               [9,5,2],
               [6,1,7]])
194/22:
for i in range(M1.shape[0]):
    MR['{}'.format(i+1)] = np.zeros((3,3))
    MR['{}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/23:
MR = np.zeros((3,3))

for i in range(M1.shape[0]):
    MR['{}'.format(i+1)] = np.zeros((3,3))
    MR['{}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/24:
MR = np.zeros((3,3))

for i in range(M1.shape[0]):
    MR['{0}'.format(i+1)] = np.zeros((3,3))
    MR['{0}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/25:
MR = np.zeros((3,3))

for i in range(M1.shape[0]):
    MR['{0}'.format(i+1)] = np.zeros((3,3))
    MR['{0}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/26:
MR = np.zeros((3,3))

for i in range(M1.shape[0]):
    MR['{0}'.format(int(i)+1)] = np.zeros((3,3))
    MR['{0}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/27:
MR = np.zeros((3,3))

for i in range(M1.shape[0]):
    MR['{0}'.format(int(i)] = np.zeros((3,3))
    MR['{0}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/28:
MR = np.zeros((3,3))

for i in range(M1.shape[0]):
    MR['{0}'.format(int(i))] = np.zeros((3,3))
    MR['{0}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/29:
MR = np.zeros((3,3))

for i in range(M1.shape[0]):
    MR['{0}'.format(str(i+1))] = np.zeros((3,3))
    MR['{0}'.format(i+1)][i] = M1[:,i]*M2[i,:][i]
194/30:
MR1 = np.zeros((3,3))
MR2 = np.zeros((3,3))
MR3 = np.zeros((3,3))
194/31:
for i in range(M1.shape[0]):
    MR1[i] = M1[:,0]*M2[0,:][i]
    MR2[i] = M1[:,1]*M2[1,:][i]
    MR3[i] = M1[:,2]*M2[2,:][i]
194/32: MR1"
194/33: MR1
194/34: MR1+MR2+MR3
195/1: M1.dot(M2)
195/2: import numpy as np
195/3:
M1 = np.array([[1,4,5],
               [2,7,6],
               [8,1,9]])

M2 = np.array([[6,3,1],
               [9,5,2],
               [6,1,7]])
195/4:
MR1 = np.zeros((3,3))
MR2 = np.zeros((3,3))
MR3 = np.zeros((3,3))
195/5:
for i in range(M1.shape[0]):
    MR1[i] = M1[:,0]*M2[0,:][i]
    MR2[i] = M1[:,1]*M2[1,:][i]
    MR3[i] = M1[:,2]*M2[2,:][i]
195/6: MR1+MR2+MR3
195/7: M1.dot(M2)
195/8: (MR1+MR2+MR3).T
196/1: v = [3, -2]
196/2: import math
196/3:
import math

pi = math.pi
196/4:
v = [3, -2]
theta = pi/30
196/5: theta
196/6:
import math
import numpy as np

pi = math.pi
196/7:
v = np.array([3, -2])
theta = pi/30
196/8:
A = np.array([[math.cos(theta), -math.sin(theta)],
             [math.sin(theta),math.cos(theta) ]])
196/9: A
196/10:
import math
import numpy as np
import matplotlib.pyplot as plt

pi = math.pi
196/11: w = np.dot(a,v)
196/12: w = np.dot(A,v)
196/13:
w = np.dot(A,v)
w
196/14:
origin = [0], [0] # origin point

plt.quiver(*origin, V[0], V[1], color=['r','b','g'], scale=21)
plt.show()
196/15:
origin = [0], [0] # origin point

plt.quiver(*origin, w[0], w[1], color=['r','b','g'], scale=21)
plt.show()
196/16:
origin = [0], [0] # origin point

plt.quiver(*origin, w[0], w[1], color=['r','b','g'], scale=21)
plt.quiver(*origin, v[0], v[1], color=['r','b','g'], scale=21)
plt.show()
196/17:
origin = [0], [0] # origin point

plt.quiver(*origin, w[0], w[1], color=['r'], scale=10)
plt.quiver(*origin, v[0], v[1], color=['b'], scale=10)
plt.show()
196/18:
v = np.array([3, -2])
theta = pi/10
196/19:
A = np.array([[math.cos(theta), -math.sin(theta)],
             [math.sin(theta),math.cos(theta) ]])
196/20:
w = np.dot(A,v)
w
196/21:
origin = [0], [0] # origin point

plt.quiver(*origin, w[0], w[1], color=['r'], scale=10)
plt.quiver(*origin, v[0], v[1], color=['b'], scale=10)
plt.show()
196/22:
v = np.array([3, -2])
theta = pi/5
196/23:
A = np.array([[math.cos(theta), -math.sin(theta)],
             [math.sin(theta),math.cos(theta) ]])
196/24:
w = np.dot(A,v)
w
196/25:
origin = [0], [0] # origin point

plt.quiver(*origin, w[0], w[1], color=['r'], scale=10)
plt.quiver(*origin, v[0], v[1], color=['b'], scale=10)
plt.show()
196/26:
def rotateVector(theta):
    
    theta = pi/5
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),math.cos(theta) ]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=10)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=10)
    plt.show()
    
    return None
196/27: rotateVector(5)
196/28: rotateVector(0)
196/29: rotateVector(10)
196/30: rotateVector(20)
196/31: rotateVector(50)
196/32: rotateVector(250)
196/33:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=10)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=10)
    plt.show()
    
    return None
196/34: rotateVector(250)
196/35: rotateVector(50)
196/36: rotateVector(60)
196/37: rotateVector(150)
196/38: rotateVector(20)
196/39: rotateVector(1)
196/40:
v = np.array([3, -2])
theta = pi/5
196/41:
A = np.array([[math.cos(theta), -math.sin(theta)],
             [math.sin(theta),math.cos(theta) ]])
196/42:
w = np.dot(A,v)
w
196/43:
origin = [0], [0] # origin point

plt.quiver(*origin, w[0], w[1], color=['r'], scale=10)
plt.quiver(*origin, v[0], v[1], color=['b'], scale=10)
plt.show()
196/44: rotateVector(5)
196/45: rotateVector(10)
196/46: rotateVector(-5)
196/47:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=10)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=15)
    plt.show()
    
    return None
196/48:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=15)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=15)
    plt.show()
    
    return None
196/49: rotateVector(-5)
196/50:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=25)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=25)
    plt.show()
    
    return None
196/51: rotateVector(-5)
196/52:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=5)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=5)
    plt.show()
    
    return None
196/53: rotateVector(-5)
196/54:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=12)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=12)
    plt.show()
    
    return None
196/55: rotateVector(-5)
196/56:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=12)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=12)
    plt.show()
196/57: rotateVector(-5)
196/58:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[2*math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=12)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=12)
    plt.show()
196/59: rotateVector(-5)
196/60: rotateVector(5)
196/61:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[4*math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=12)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=12)
    plt.show()
196/62: rotateVector(5)
196/63:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[2*math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=12)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=12)
    plt.show()
196/64: rotateVector(5)
196/65: rotateVector(25)
196/66: rotateVector(1)
196/67: rotateVector(60)
196/68: rotateVector(120)
196/69: rotateVector(180)
196/70: rotateVector(240)
196/71: rotateVector()
196/72: rotateVector(5)
196/73:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(*origin, w[0], w[1], color=['r'], scale=12)
    plt.quiver(*origin, v[0], v[1], color=['b'], scale=12)
    plt.show()
196/74: rotateVector(5)
196/75:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(w[0], w[1], color=['r'], scale=12)
    plt.quiver(v[0], v[1], color=['b'], scale=12)
    plt.show()
196/76: rotateVector(5)
196/77:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin point

    plt.quiver(w[0], w[1], color=['r'], scale=12)
    plt.quiver(v[0], v[1], color=['b'], scale=12)
    plt.show()
196/78: rotateVector(5)
196/79:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin 
    point

    plt.quiver(w[0], w[1], color=['r'], scale=12)
    plt.quiver(v[0], v[1], color=['b'], scale=12)
    plt.show()
196/80: rotateVector(5)
196/81:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin 
    point

    plt.quiver(w[0], w[1], color=['r'], scale=12)
    plt.quiver(v[0], v[1], color=['b'], scale=12)
    plt.show()
196/82:
def rotateVector(theta):
    
    pi = math.pi
    
    theta = pi/theta
    v = np.array([3, -2])
    
    A = np.array([[math.cos(theta), -math.sin(theta)],
                  [math.sin(theta),  math.cos(theta)]])
    
    w = np.dot(A,v)
    
    origin = [0], [0] # origin 

    plt.quiver(w[0], w[1], color=['r'], scale=12)
    plt.quiver(v[0], v[1], color=['b'], scale=12)
    plt.show()
196/83: rotateVector(5)
197/1: import numpy as np
197/2: np.random.randint(10,4)
197/3: np.random.randint(9 size = (10,4))
197/4: np.random.randint(9,size = (10,4))
197/5: A = np.random.randint(9,size = (10,4))
197/6:
A = np.random.randint(9,size = (10,4))
B = np.random.randint(9,size = (10,4))
197/7: A
197/8: B
197/9: print(matrix_rank(A),matrix_rank(B))
197/10:
import numpy as np
from numpy.linalg import matrix_rank
197/11: print(matrix_rank(A),matrix_rank(B))
197/12: AB = A.dot(B)
197/13: AB = A.dot(B.T)
197/14: AB
197/15: AB = A.T.dot(B)
197/16: AB
197/17:
def rank(array):
    return matrix_rank(array)
197/18: rank(AB)
197/19: AB
197/20: rank(AB)
197/21:
def generate_r_rank_matrix_square_matrix(rank):
    
    A = np.random.randint(9,size = (10,rank))
    B = np.random.randint(9,size = (10,rank))
    
    AB = A.T.dot(B)
    return AB, rank(AB)
197/22: generate_r_rank_matrix_square_matrix(5)
197/23: AB, rank = generate_r_rank_matrix_square_matrix(5)
197/24:
def rank(array):
    return matrix_rank(array)
197/25:
def generate_r_rank_matrix_square_matrix(rank):
    
    A = np.random.randint(9,size = (10,rank))
    B = np.random.randint(9,size = (10,rank))
    
    AB = A.T.dot(B)
    return AB, rank(AB)
197/26: AB, rank = generate_r_rank_matrix_square_matrix(5)
197/27: generate_r_rank_matrix_square_matrix(5)
197/28:
def generate_r_rank_matrix_square_matrix(rank):
    
    A = np.random.randint(9,size = (10,rank))
    B = np.random.randint(9,size = (10,rank))
    
    AB = A.T.dot(B)
    return AB
197/29: generate_r_rank_matrix_square_matrix(5)
197/30: rank(generate_r_rank_matrix_square_matrix(5))
197/31: rank(generate_r_rank_matrix_square_matrix(5))
197/32: generate_r_rank_matrix_square_matrix(5)
197/33: generate_r_rank_matrix_square_matrix(10)
197/34: rank(generate_r_rank_matrix_square_matrix(10))
197/35:
def generate_r_rank_matrix_square_matrix(rank):
    
    A = np.random.randint(9,size = (10,rank))
    B = np.random.randint(9,size = (10,rank))
    
    AB = A.T.dot(B)
    return AB
197/36: generate_r_rank_matrix_square_matrix(55)
197/37: rank(generate_r_rank_matrix_square_matrix(10))
197/38: rank(generate_r_rank_matrix_square_matrix(55))
197/39:
def generate_r_rank_matrix_square_matrix(rows, columns, rank):
    
    A = np.random.randint(9,size = (rows,columns))
    B = np.random.randint(9,size = (rows,rank))
    
    AB = A.T.dot(B)
    return AB
197/40: generate_r_rank_matrix_square_matrix(3,3,1)
197/41:
def generate_r_rank_matrix_square_matrix(rows, columns, rank):
    
    A = np.random.randint(9,size = (rows,columns))
    B = np.random.randint(9,size = (rows,rank))
    
    AB = A.T.dot(B)
    return AB
197/42: generate_r_rank_matrix_square_matrix(3,3,1)
197/43: array_generated = generate_r_rank_matrix_square_matrix(3,3,1)
197/44:
array_generated = generate_r_rank_matrix_square_matrix(3,3,1)
array_generated
197/45: rank(array_generated)
197/46:
array_generated = generate_r_rank_matrix_square_matrix(3,3,4)
array_generated
197/47: rank(array_generated)
197/48:
array_generated = generate_r_rank_matrix_square_matrix(3,5,4)
array_generated
197/49: rank(array_generated)
197/50:
array_generated = generate_r_rank_matrix_square_matrix(3,5,4)
array_generated
197/51: rank(array_generated)
197/52:
def generate_r_rank_matrix_square_matrix(rows, columns, rank):
    
    A = np.random.randint(9,size = (rows,columns))
    B = np.random.randint(9,size = (rows,rank))
    
    AB = A.T.dot(B)
    return AB
197/53:
array_generated = generate_r_rank_matrix_square_matrix(3,5,4)
array_generated
197/54: rank(array_generated)
197/55:
def generate_r_rank_matrix_square_matrix(rows, columns, rank):
    
    A = np.random.randint(9,size = (rows,columns))
    B = np.random.randint(9,size = (rows,rank))
    
    AB = A.T.dot(B)
    return AB
197/56:
array_generated = generate_r_rank_matrix_square_matrix(5,5,4)
array_generated
197/57: rank(array_generated)
202/1:
import sys
!{sys.executable} -m pip install selenium
202/2: import selenium
203/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
203/2: browser = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project")
203/3: browser = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
203/4:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
203/5: browser = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
203/6: browser = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
203/7: driver.get("https://www.facebook.com/")
203/8: driver = webdriver()
203/9: driver = webdriver
203/10: driver.get("https://www.facebook.com/")
203/11: driver = webdriver.Chrome()
203/12: driver.get("https://www.facebook.com/")
203/13:
inputElement = driver.find_element_by_xpath("[@id='email']")
inputElement.send_keys('1')
203/14:
inputElement = driver.find_element_by_xpath("//*[@id='email']")
inputElement.send_keys('1')
203/15:
input_email = driver.find_element_by_xpath("//*[@id='email']")
inputElement.send_keys('cagri_ardic@hotmail.com')
203/16:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
inputElement.send_keys('18229993126A')
203/17:
input_email = driver.find_element_by_xpath("//*[@id='email']")
inputElement.send_keys('cagri_ardic@hotmail.com')
203/18: input_password = driver.find_element_by_xpath('//*[@id="pass"]')
203/19: inputElement.send_keys('18229993126A')
203/20: input_password = driver.find_element_by_xpath('//*[@id="pass"]')
203/21: input_password = driver.find_element_by_xpath('//*[@id="pass"]')
203/22: inputElement.send_keys('18229993126A')
203/23: inputElement.send_keys('18229993126A')
203/24: inputElement.send_keys('asd')
203/25:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
203/26: driver = webdriver.Chrome()
203/27: driver.get("https://www.facebook.com/")
203/28: inputElement.send_keys('18229993126A')
203/29: input_password = driver.find_element_by_xpath('//*[@id="pass"]')
203/30: inputElement.send_keys('18229993126A')
203/31:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
203/32: driver = webdriver.Chrome()
203/33: #browser = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
203/34: driver.get("https://www.facebook.com/")
203/35: input_password = driver.find_element_by_xpath('//*[@id="pass"]')
203/36: inputElement.send_keys('18229993126A')
203/37:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
203/38: driver = webdriver.Chrome()
203/39: #browser = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
203/40: driver.get("https://www.facebook.com/")
203/41:
input_email = driver.find_element_by_xpath("//*[@id='email']")
inputElement.send_keys('cagri_ardic@hotmail.com')
203/42:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
203/43: driver = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
203/44: driver.get("https://www.facebook.com/")
203/45:
input_email = driver.find_element_by_xpath("//*[@id='email']")
inputElement.send_keys('cagri_ardic@hotmail.com')
205/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
205/2: driver = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
205/3: driver.get("https://www.facebook.com/")
205/4:
input_email = driver.find_element_by_xpath("//*[@id='email']")
inputElement.send_keys('cagri_ardic@hotmail.com')
205/5:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.inputElement.send_keys('cagri_ardic@hotmail.com')
205/6:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys('cagri_ardic@hotmail.com')
205/7:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys('18229993126A')
205/8: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
205/9:
with open('"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json"') as keys:
    data = json.load(keys)
205/10:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as keys:
    data = json.load(keys)
205/11:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import json
205/12:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as keys:
    data = json.load(keys)
205/13:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/14:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/15:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/16:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/17:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/18: data
205/19: data[0]
205/20: data[email]
205/21: data["email"]
205/22: data.values()[0]
205/23: data
205/24: next(iter(data.values()))
205/25: next(iter(data.values()))
205/26: data[0]
205/27: list(data.values())[0]
205/28:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import json
205/29:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/30: driver = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
205/31: driver.get("https://www.facebook.com/")
205/32:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
205/33:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
205/34: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
205/35: list(data.values())[1]
205/36: list(data.values())[1]
205/37:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/38: list(data.values())[1]
205/39:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import json
205/40:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import json
205/41:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/42: driver = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
205/43: driver.get("https://www.facebook.com/")
205/44:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
205/45:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
205/46: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
205/47: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
205/48: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
205/49: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
205/50:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
205/51: driver = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
205/52: driver.get("https://www.facebook.com/")
205/53:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
205/54:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
205/55: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
206/1:
#import sys
#!{sys.executable} -m pip install selenium
206/2:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import json
206/3:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
206/4: driver = webdriver.Chrome(executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
206/5: driver.get("https://www.facebook.com/")
206/6:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
206/7:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
206/8: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
206/9:
driver.waitForVisible("[name=__CONFIRM__]");
driver.keys("Escape")
206/10:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })

driver = webdriver.Chrome(chrome_options=option, executable_path='path-of- 
driver\chromedriver.exe')
driver.get('https://www.facebook.com')
206/11:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })

driver = webdriver.Chrome(chrome_options=option, executable_path='path-of-driver\chromedriver.exe')
driver.get('https://www.facebook.com')
206/12:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
206/13:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })

driver = webdriver.Chrome(chrome_options=option, executable_path='path-of-driver\chromedriver.exe')
driver.get('https://www.facebook.com')
206/14:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
206/15:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
206/16:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
206/17:
driver = webdriver.Chrome(chrome_options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
206/18:
driver.waitForVisible("[name=__CONFIRM__]");
driver.keys("Escape")
206/19:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
206/20: driver.get("https://www.facebook.com/")
206/21:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
206/22:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
206/23: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
207/1:
#import sys
#!{sys.executable} -m pip install selenium
207/2:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
207/3:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
207/4:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
207/5:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
207/6: driver.get("https://www.facebook.com/")
207/7:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
207/8:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
207/9: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
208/1:
#import sys
#!{sys.executable} -m pip install selenium
208/2:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
208/3:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
208/4:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
208/5:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
208/6: driver.get("https://www.facebook.com/")
208/7:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
208/8:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
208/9: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
208/10: driver.find_element_by_xpath('//*[@id="u_0_a"]').click()
208/11:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
208/12:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
208/13:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
208/14:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
208/15: driver.get("https://www.facebook.com/")
208/16:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
208/17:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
208/18: driver.find_element_by_name("submit").click()
208/19: ebElement.sendKeys(Keys.ENTER)
208/20: keys.ENTER
208/21: driver.find_element_by_xpath('//*[@id="u_0_a"]').sendKeys(u'\ue007')
208/22:
submit = driver.find_element_by_xpath('//*[@id="u_0_a"]')
submit.sendKeys(u'\ue007')
209/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
209/2:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
209/3:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
209/4:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
209/5: driver.get("https://www.facebook.com/")
209/6:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
209/7:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
209/8:
submit = driver.find_element_by_xpath('//*[@id="u_0_a"]')
submit.sendKeys(u'\ue007')
209/9:
submit = driver.find_element_by_xpath('//*[@id="u_0_a"]')
submit.send_keys(u'\ue007')
210/1:
#import sys
#!{sys.executable} -m pip install selenium
210/2:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
210/3:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
210/4:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
210/5:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
210/6: driver.get("https://www.facebook.com/")
210/7:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
210/8:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
210/9:
submit = driver.find_element_by_xpath('//*[@id="u_0_a"]')
submit.send_keys(u'\ue007')
210/10:
submit = driver.find_element_by_xpath('//*[@id="u_0_a"]')
submit.send_keys(keys.ENTER)
211/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
211/2:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
211/3:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
211/4:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
211/5: driver.get("https://www.facebook.com/")
211/6:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
211/7:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
211/8:
submit = driver.find_element_by_xpath('//*[@id="u_0_a"]')
submit.send_keys(keys.ENTER)
211/9:
submit = driver.find_element_by_xpath('//*[@id="u_0_a"]')
submit.send_keys(u'\ue007')
211/10:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
211/11:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
211/12:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
211/13:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
211/14: driver.get("https://www.facebook.com/")
211/15:
input_email = driver.find_element_by_xpath("//*[@id='email']")
input_email.send_keys(list(data.values())[0])
211/16:
input_password = driver.find_element_by_xpath('//*[@id="pass"]')
input_password.send_keys(list(data.values())[1])
211/17:
submit = driver.find_element_by_xpath('//*[@id="u_0_a"]')
submit.send_keys(u'\ue007')
211/18:
class LoginPage(object):
    
    def __init__(self, email, password, submit_button):
        
        self.email = driver.find_element_by_xpath("//*[@id='email']")
        self.password = driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
211/19:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
211/20:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
211/21:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
211/22: LoginPage()
211/23:
class LoginPage(object):
    
    driver.get("https://www.facebook.com/")
    
    def __init__(self, email, password, submit_button):
        
        self.email = driver.find_element_by_xpath("//*[@id='email']")
        self.password = driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
211/24:
class LoginPage(object):
    
    driver.get("https://www.facebook.com/")
    
    def __init__(self):
        
        self.email = driver.find_element_by_xpath("//*[@id='email']")
        self.password = driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
211/25: LoginPage()
211/26:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
212/1:
#import sys
#!{sys.executable} -m pip install selenium
212/2:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
212/3:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
212/4:
with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
    data = json.load(f)
212/5:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", { 
    "profile.default_content_setting_values.notifications": 1 })
212/6:
driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
212/7:
class LoginPage(object):
    
    driver.get("https://www.facebook.com/")
    
    def __init__(self):
        
        self.email = driver.find_element_by_xpath("//*[@id='email']")
        self.password = driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/8: LoginPage()
212/9: login = LoginPage()
212/10: login.login()
212/11:
class InitialiseFacebook(object):
    
    def __init__(object):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
        data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        driver.get("https://www.facebook.com/")


class LoginPage(object):
    
    
    def __init__(self):
        
        self.email = driver.find_element_by_xpath("//*[@id='email']")
        self.password = driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/12:
class InitialiseFacebook(object):
    
    def __init__(object):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        driver.get("https://www.facebook.com/")


class LoginPage(object):
    
    
    def __init__(self):
        
        self.email = driver.find_element_by_xpath("//*[@id='email']")
        self.password = driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/13: InitialiseFacebook()
212/14: login = LoginPage()
212/15: InitialiseFacebook()
212/16: login = LoginPage()
212/17:
class InitialiseFacebook(object):
    
    def __init__(object):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        driver.get("https://www.facebook.com/")


class LoginPage(InitialiseFacebook):
    
    
    def __init__(self):
        
        self.email = driver.find_element_by_xpath("//*[@id='email']")
        self.password = driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/18: InitialiseFacebook()
212/19: login = LoginPage()
212/20:
class InitialiseFacebook(object):
    
    def __init__(object):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        driver.get("https://www.facebook.com/")


class LoginPage(InitialiseFacebook):
    
    facebook_page = InitialiseFacebook
    
    def __init__(self):
        
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/21: InitialiseFacebook()
212/22: login = LoginPage()
212/23:
class InitialiseFacebook(object):
    
    def __init__(object):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        driver.get("https://www.facebook.com/")


class LoginPage(InitialiseFacebook):
    
    def __init__(self):
        
        facebook_page = InitialiseFacebook    
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/24:
class InitialiseFacebook(object):
    
    def __init__(object):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        driver.get("https://www.facebook.com/")


class LoginPage(InitialiseFacebook):
    
    def __init__(self):
        
        facebook_page = InitialiseFacebook    
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/25: InitialiseFacebook()
212/26: login = LoginPage()
212/27:
class InitialiseFacebook(object):
    
    def __init__(object):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")


class LoginPage(InitialiseFacebook):
    
    def __init__(self):
        
        facebook_page = InitialiseFacebook    
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/28: InitialiseFacebook()
212/29:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")


class LoginPage(InitialiseFacebook):
    
    def __init__(self):
        
        facebook_page = InitialiseFacebook    
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/30: InitialiseFacebook()
212/31: login = LoginPage()
212/32:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")


class LoginPage(InitialiseFacebook):
    InitialiseFacebook.mro
    
    def __init__(self):

        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
212/33: InitialiseFacebook()
212/34: login = LoginPage()
212/35:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
212/36: InitialiseFacebook()
212/37: InitialiseFacebook.driver
212/38: InitialiseFacebook.data
213/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import json
213/2:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/3:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)

        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/4: InitialiseFacebook.
213/5:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/6:
class LoginPage(InitialiseFacebook):
    
    def __init__(self):

        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/7: InitialiseFacebook()
213/8:
class LoginPage(InitialiseFacebook):
    
    def __init__(self):
        facebook_page = InitialiseFacebook.driver
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/9: InitialiseFacebook()
213/10:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/11:
class LoginPage(InitialiseFacebook):
    
    def __init__(self):
        facebook_page = InitialiseFacebook.driver
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/12: InitialiseFacebook()
213/13: login = LoginPage(InitialiseFacebook)
213/14: login = LoginPage()
213/15: login = LoginPage(InitialiseFacebook)
213/16:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        facebook_page = InitialiseFacebook.driver
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/17: InitialiseFacebook()
213/18: login = LoginPage(InitialiseFacebook)
213/19: login.login()
213/20:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        facebook_page = InitialiseFacebook.driver
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/21: login = LoginPage(InitialiseFacebook)
213/22:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/23:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        facebook_page = InitialiseFacebook.driver
        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/24: InitialiseFacebook
213/25: InitialiseFacebook()
213/26: InitialiseFacebook()
213/27: login = LoginPage(InitialiseFacebook)
213/28: login = LoginPage(InitialiseFacebook())
213/29:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):

        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/30:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/31:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):

        self.email = facebook_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = facebook_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = facebook_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/32: login = LoginPage(InitialiseFacebook())
213/33:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):

        self.email = InitialiseFacebook.driver.find_element_by_xpath("//*[@id='email']")
        self.password = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/34: login = LoginPage(InitialiseFacebook())
213/35:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/36:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):

        self.email = InitialiseFacebook.driver.find_element_by_xpath("//*[@id='email']")
        self.password = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(data.values())[0])
        self.password.send_keys(list(data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/37: login = LoginPage(InitialiseFacebook())
213/38: login.login()
213/39:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):

        self.email = InitialiseFacebook.driver.find_element_by_xpath("//*[@id='email']")
        self.password = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(InitialiseFacebook.data.values())[0])
        self.password.send_keys(list(InitialiseFacebook.data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/40: login = LoginPage(InitialiseFacebook())
213/41: login.login()
213/42:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):

        self.email = InitialiseFacebook.driver.find_element_by_xpath("//*[@id='email']")
        self.password = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self, InitialiseFacebook):
        
        self.email.send_keys(list(InitialiseFacebook.data.values())[0])
        self.password.send_keys(list(InitialiseFacebook.data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/43: login = LoginPage(InitialiseFacebook())
213/44: login.login()
213/45: login.login(InitialiseFacebook())
213/46:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):

        self.email = InitialiseFacebook.driver.find_element_by_xpath("//*[@id='email']")
        self.password = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self, InitialiseFacebook):
        
        self.email.send_keys(list(InitialiseFacebook.data.values())[0])
        self.password.send_keys(list(InitialiseFacebook.data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/47:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):

        self.email = InitialiseFacebook.driver.find_element_by_xpath("//*[@id='email']")
        self.password = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        attrs = vars(InitialiseFacebook)
        print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(InitialiseFacebook.data.values())[0])
        self.password.send_keys(list(InitialiseFacebook.data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/48: login = LoginPage(InitialiseFacebook())
213/49: login.login()
213/50:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.fb_page = InitialiseFacebook
        self.email = self.fb_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.fb_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.fb_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        attrs = vars(InitialiseFacebook)
        print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.fb_page.data.values())[0])
        self.password.send_keys(list(self.fb_page.data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/51: login = LoginPage(InitialiseFacebook())
213/52: login.login()
213/53:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/54:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.fb_page = InitialiseFacebook
        self.email = self.fb_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.fb_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.fb_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        attrs = vars(InitialiseFacebook)
        print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.fb_page.data.values())[0])
        self.password.send_keys(list(self.fb_page.data.values())[1])
        self.submit_button.send_keys(u'\ue007')
213/55: login = LoginPage(InitialiseFacebook())
213/56: login.login()
213/57:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.fb_page = InitialiseFacebook
        self.email = self.fb_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.fb_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.fb_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.fb_page.data.values())[0])
        self.password.send_keys(list(self.fb_page.data.values())[1])
        self.submit_button.click()
213/58: login = LoginPage(InitialiseFacebook())
213/59: login.login()
213/60:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.email = InitialiseFacebook.driver.find_element_by_xpath("//*[@id='email']")
        self.password = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = InitialiseFacebook.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self, InitialiseFacebook = InitialiseFacebook):
        
        self.email.send_keys(list(InitialiseFacebook.data.values())[0])
        self.password.send_keys(list(InitialiseFacebook.data.values())[1])
        self.submit_button.click()
213/61: login = LoginPage(InitialiseFacebook())
213/62: login.login()
213/63:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/64:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.fb_page = InitialiseFacebook
        self.email = self.fb_page.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.fb_page.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.fb_page.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self, InitialiseFacebook = InitialiseFacebook):
        
        self.email.send_keys(list(self.fb_page.data.values())[0])
        self.password.send_keys(list(self.fb_page.data.values())[1])
        self.submit_button.click()
213/65: login = LoginPage(InitialiseFacebook())
213/66: login.login()
213/67:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self..data.values())[0])
        self.password.send_keys(list(self..data.values())[1])
        self.submit_button.click()
213/68:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self..data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
213/69:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
213/70: login = LoginPage(InitialiseFacebook())
213/71: login.login()
213/72:
class LoginPage(InitialiseFacebook):
    
    def __init__(self):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
213/73: login = LoginPage(InitialiseFacebook())
213/74: login.login()
213/75: login = LoginPage()
213/76:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/77:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
213/78: login = LoginPage(InitialiseFacebook())
213/79: login.login()
213/80:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/81:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
213/82: login = LoginPage(InitialiseFacebook())
213/83: login.login()
213/84: login.login()
213/85:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/86:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
213/87: login = LoginPage(InitialiseFacebook())
213/88: login.login()
213/89:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/90:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
        #attrs = vars(InitialiseFacebook)
        #print(', '.join("%s: %s" % item for item in attrs.items()))
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
213/91: login = LoginPage(InitialiseFacebook())
213/92: login.login()
213/93:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/94: login = LoginPage(InitialiseFacebook())
213/95: login.login()
213/96:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/97:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/98: login = LoginPage(InitialiseFacebook())
213/99: login.login()
213/100: login.search_user("Mustafa Cagri Ardic")
213/101:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_i_2"]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/102:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_i_2"]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/103: login = LoginPage(InitialiseFacebook())
213/104: login.login()
213/105: login.search_user("Mustafa Cagri Ardic")
213/106:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_i_2"]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/107: login = LoginPage(InitialiseFacebook())
213/108: login.login()
213/109:
class InitialiseFacebook(object):
    
    def __init__(self):
        
        with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
            self.data = json.load(f)
               
        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", { 
        "profile.default_content_setting_values.notifications": 1 })
        
        self.driver = webdriver.Chrome(options=option,
                          executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")
        
        self.driver.get("https://www.facebook.com/")
213/110:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="js_56"]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/111: login = LoginPage(InitialiseFacebook())
213/112: login.login()
213/113: login.search_user("Mustafa Cagri Ardic")
213/114: login.search_user("Mustafa Cagri Ardic")
213/115:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_f_2"]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/116: login.search_user("Mustafa Cagri Ardic")
213/117:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_f_2"]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/118: login.search_user("Mustafa Cagri Ardic")
213/119: login = LoginPage(InitialiseFacebook())
213/120: login.login()
213/121: login.search_user("Mustafa Cagri Ardic")
213/122:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_a_2"]/input[2]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/123: login = LoginPage(InitialiseFacebook())
213/124: login.login()
213/125: login.search_user("Mustafa Cagri Ardic")
213/126:
class LoginPage(InitialiseFacebook):
    
    def __init__(self, InitialiseFacebook):
        
        self.driver = InitialiseFacebook.driver
        self.data = InitialiseFacebook.data
        self.email = self.driver.find_element_by_xpath("//*[@id='email']")
        self.password = self.driver.find_element_by_xpath('//*[@id="pass"]')
        self.submit_button = self.driver.find_element_by_xpath('//*[@id="u_0_a"]')
        
    def login(self):
        
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.click()
        
    def search_user(self, username):
        
        search_bar = self.driver.find_element_by_xpath('//*[@id="u_g_2"]')
        search_bar_bar.send_keys(username)
        
        search_execute = self.driver.find_element_by_xpath('//*[@id="js_2s"]/form/button')
        search_execute.submit_button.click()
213/127: login = LoginPage(InitialiseFacebook())
213/128: login.login()
213/129: login.search_user("Mustafa Cagri Ardic")
214/1: from Selenium Automation import *
214/2: from Selenium import *
214/3: from SeleniumFBimport *
214/4: from SeleniumFB import *
214/5: login = LoginPage(InitialiseFacebook())
214/6: login.login()
214/7: login.search_user("Mustafa Cagri Ardic")
214/8: from SeleniumFB import *
214/9:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", {
"profile.default_content_setting_values.notifications": 1 })

diver = webdriver.Chrome(options=option,
                               executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")

driver.get("https://www.facebook.com/")
214/10:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", {
"profile.default_content_setting_values.notifications": 1 })

driver = webdriver.Chrome(options=option,
                               executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")

driver.get("https://www.facebook.com/")
214/11: login = LoginPage(InitialiseFacebook, driver)
214/12: login = LoginPage(InitialiseFacebook)
214/13: from SeleniumFB import *
214/14:
option = Options()

option.add_argument("--disable-infobars")
option.add_argument("start-maximized")
option.add_argument("--disable-extensions")

# Pass the argument 1 to allow and 2 to block
option.add_experimental_option("prefs", {
"profile.default_content_setting_values.notifications": 1 })

driver = webdriver.Chrome(options=option,
                               executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")

driver.get("https://www.facebook.com/")
214/15: login = LoginPage(InitialiseFacebook)
214/16: login = LoginPage(InitialiseFacebook, driver)
214/17: login = LoginPage(InitialiseFacebook)
214/18: from SeleniumFB import *
214/19: login = LoginPage(InitialiseFacebook)
214/20: from SeleniumFB import *
214/21: login = LoginPage(InitialiseFacebook)
214/22: login = LoginPage(InitialiseFacebook())
214/23: login.login()
214/24: login.search_user("Mustafa Cagri Ardic")
214/25: login.driver
214/26: driver = login.driver
214/27: driver.find_element_by_xpath('//*[@id="u_g_2"]')
214/28: driver.find_element_by_xpath('//*[@id="u_q_2"]')
214/29: search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]')
214/30:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]')
search_box.send_keys("Mustafa Cagri Ardic")
214/31: search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]')
214/32: search_box.send_keys("Mustafa Cagri Ardic")
214/33: search_box.send_keys("1")
214/34:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/35: search_box.send_keys("1")
214/36: login.search_user("Mustafa Cagri Ardic")
214/37: from SeleniumFB import *
214/38: login = LoginPage(InitialiseFacebook())
214/39: login.login()
214/40: login.search_user("Mustafa Cagri Ardic")
214/41: from SeleniumFB import *
214/42: login = LoginPage(InitialiseFacebook())
214/43: login.login()
214/44: login.search_user("Mustafa Cagri Ardic")
214/45:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/46: driver = login.driver
214/47:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/48:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/49: from SeleniumFB import *
214/50: login = LoginPage(InitialiseFacebook())
214/51: login.login()
214/52: driver = login.driver
214/53:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/54:
driver = login.driver
driver
214/55:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/56: search_box.send_keys("1")
214/57: from SeleniumFB import *
214/58: login = LoginPage(InitialiseFacebook())
214/59: login.login()
214/60:
driver = login.driver
driver
214/61: login.login()
214/62: from SeleniumFB import *
214/63: login = LoginPage(InitialiseFacebook())
214/64: login.login()
214/65:
from SeleniumFB import *
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
214/66: login = LoginPage(InitialiseFacebook())
214/67:
driver = login.driver
driver
214/68:
delay = 0.5
WebDriverWait(driver, delay).until(EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]')))
214/69: login.login()
214/70:
element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
                WebDriverWait(driver, timeout).until(element_present)
214/71:
element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
WebDriverWait(driver, timeout).until(element_present)
214/72:
timeout = 5
element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
WebDriverWait(driver, timeout).until(element_present)
214/73: from SeleniumFB import *
214/74: login = LoginPage(InitialiseFacebook())
214/75: login.login()
214/76:
driver = login.driver
driver
214/77:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
214/78:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
214/79:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/80:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/81: my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
214/82:
my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
my_name
214/83:
my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
my_name.send_keys.click()
214/84:
my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
my_name.click()
214/85:
my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
my_name.click()
214/86:
search_box = driver.find_element_by_xpath('//*[@id="u_q_2"]/input[2]')
search_box
214/87:
search_box = driver.find_element_by_xpath('//*[@id="js_1wn"]')
search_box
214/88: search_box.send_keys("1")
214/89:
search_box = driver.find_element_by_id('search_input')
search_box
214/90:
search_box = driver.find_element_by_link_text('search_input')
search_box
214/91:
search_box = driver.find_element_by_link_text('search_input')
search_box
214/92:
search_box = driver.find_element_by_link_text('search_input')
search_box
214/93: from SeleniumFB import *
214/94: login = LoginPage(InitialiseFacebook())
214/95: login.login()
214/96: from SeleniumFB import *
214/97: login = LoginPage(InitialiseFacebook())
214/98: login.login()
214/99: from SeleniumFB import *
214/100: login = LoginPage(InitialiseFacebook())
214/101: login.login()
214/102: from SeleniumFB import *
214/103: login = LoginPage(InitialiseFacebook())
214/104: login.login()
214/105: from SeleniumFB import *
214/106: login = LoginPage(InitialiseFacebook())
214/107: login.login()
214/108:
driver = login.driver
driver
214/109:
search_box = driver.find_element_by_link_text('search_input')
search_box
214/110:
search_box = driver.find_element_by_tag_name('search_input')
search_box
214/111: from SeleniumFB import *
214/112: login = LoginPage(InitialiseFacebook())
214/113: login.login()
214/114: login.search_user("Mustafa Cagri Ardic")
214/115:
text = "u_"
search_box = driver.find_element_by_xpathment_by('//div[contains(text(), "{0}") and @class="_1frb"]'.format(text))
search_box
214/116:
text = "u_"
search_box = driver.find_element_by_xpath('//div[contains(text(), "{0}") and @class="_1frb"]'.format(text))
search_box
214/117: from SeleniumFB import *
214/118: login = LoginPage(InitialiseFacebook())
214/119: login.login()
214/120:
driver = login.driver
driver
214/121:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
214/122:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
214/123:
text = "u_"
search_box = driver.find_element_by_xpath('//div[contains(text(), "{0}") and @class="_1frb"]'.format(text))
search_box
214/124:
search_box = driver.find_elements_by_xpath("//*[contains(text(), 'u_')]"
search_box
214/125:
search_box = driver.find_elements_by_xpath("//*[contains(text(), 'u_')]")
search_box
214/126:
search_box = driver.find_elements_by_xpath("//*[contains(text(), 'u_[a-z]_2')]")
search_box
214/127:
search_box = driver.find_elements_by_xpath("//*[contains(text(), '_2')]")
search_box
214/128:
search_box = driver.find_elements_by_xpath("//*[contains(text(), 'u_g_2')]")
search_box
214/129:
search_box = driver.find_element_by_class_name("_1frb")
search_box
214/130: search_box.send_keys("1")
214/131: from SeleniumFB import *
214/132: login = LoginPage(InitialiseFacebook())
214/133: login.login()
214/134:
driver = login.driver
driver
214/135:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
214/136:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
214/137:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
214/138:
search_box = driver.find_element_by_class_name("_1frb")
search_box
214/139: search_box.send_keys("1")
214/140: from SeleniumFB import *
214/141: login = LoginPage(InitialiseFacebook())
214/142: login.login()
214/143:
driver = login.driver
driver
214/144:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
214/145:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
214/146:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
214/147: login.search_user("Mustafa Cagri Ardic")
214/148: from SeleniumFB import *
214/149: login = LoginPage(InitialiseFacebook())
214/150: login.login()
214/151:
driver = login.driver
driver
214/152:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
214/153:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
214/154:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
214/155:
#search_box = driver.find_element_by_class_name("_1frb")
#search_box
214/156: login.search_user("Mustafa Cagri Ardic")
214/157: from SeleniumFB import *
215/1: reload(from SeleniumFB import *)
215/2: reload(SeleniumFB)
215/3:
import importlib
importlib.reload(from SeleniumFB import *)
215/4:
import importlib
importlib.reload(from SeleniumFB import *)
215/5:
import importlib
importlib.reload(SeleniumFB)
215/6:
import importlib
importlib.reload(import.SeleniumFB)
215/7:
import importlib
importlib.reload(import SeleniumFB)
215/8:
from SeleniumFB import *
import importlib
importlib.reload(from SeleniumFB import *)
215/9:
from SeleniumFB import *
import importlib
importlib.reload(SeleniumFB)
215/10:
from SeleniumFB import *
import importlib
SeleniumFB = importlib.reload(SeleniumFB)
215/11:
from importlib import reload
from SeleniumFB import *

SeleniumFB = importlib.reload(SeleniumFB)
215/12:
from importlib import reload
import SeleniumFB

SeleniumFB = importlib.reload(SeleniumFB)
216/1:
from importlib import reload
import SeleniumFB

SeleniumFB = importlib.reload(SeleniumFB)
216/2:
from importlib
import SeleniumFB

SeleniumFB = importlib.reload(SeleniumFB)
216/3:
import importlib
import SeleniumFB

SeleniumFB = importlib.reload(SeleniumFB)
216/4: login = LoginPage(InitialiseFacebook())
216/5: from SeleniumFB import *
216/6: login = LoginPage(InitialiseFacebook())
216/7: login.login()
216/8:
driver = login.driver
driver
216/9:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
216/10:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
216/11:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
216/12:
#search_box = driver.find_element_by_class_name("_1frb")
#search_box
216/13: login.search_user("Mustafa Cagri Ardic")
216/14:
import importlib
import SeleniumFB

SeleniumFB = importlib.reload(SeleniumFB)
216/15: from SeleniumFB import *
216/16: login = LoginPage(InitialiseFacebook())
216/17: login.login()
216/18:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
216/19:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
216/20:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
216/21:
#search_box = driver.find_element_by_class_name("_1frb")
#search_box
216/22: login.search_user("Mustafa Cagri Ardic")
216/23:
%load_ext autoreload
%autoreload 2

from SeleniumFB import *
216/24:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
216/25: login = LoginPage(InitialiseFacebook())
216/26: login.login()
217/1:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
217/2: login = LoginPage(InitialiseFacebook())
217/3: login.login()
217/4:
driver = login.driver
driver
217/5: login.search_user("Mustafa Cagri Ardic")
217/6: login = LoginPage(InitialiseFacebook())
217/7: login.login()
217/8:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
217/9:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
217/10:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
217/11:
#search_box = driver.find_element_by_class_name("_1frb")
#search_box
217/12: login.search_user("Mustafa Cagri Ardic")
217/13: login = LoginPage(InitialiseFacebook())
217/14: login.login()
217/15:
driver = login.driver
driver
217/16:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
217/17:
#search_box = driver.find_element_by_class_name("_1frb")
#search_box
217/18: login.search_user("Mustafa Cagri Ardic")
217/19: login.search_user("Mustafa Cagri Ardic")
217/20: driver.find_element_by_xpath('//*[@id="js_1l"]/form/button')
217/21: search_execute = driver.find_element_by_class_name("_42ft")
217/22:
search_execute = driver.find_element_by_class_name("_42ft")
search_execute
217/23:
search_execute = driver.find_element_by_class_name("_42ft")
search_execute.click()
217/24:
search_execute = driver.find_element_by_class_name("_42ft _4jy0 _4w98 _4jy3 _517h _51sy")
search_execute.click()
217/25: search_execute = driver.find_element_by_class_name("_42ft _4jy0 _4w98 _4jy3 _517h _51sy")
217/26:
search_execute = driver.find_element_by_class_name("_42ft _4jy0 _4w98 _4jy3 _517h _51sy")
search_execute
#search_execute.click()
217/27:
search_execute = driver.find_element_by_class_name("_42ft _4jy0 _4w98 _4jy3 _517h _51sy")
search_execute
#search_execute.click()
217/28:
search_execute = driver.find_element_by_class_name("_585_")
search_execute
#search_execute.click()
217/29:
search_execute = driver.find_element_by_class_name("_585_")
search_execute
search_execute.click()
218/1:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
218/2: login = LoginPage(InitialiseFacebook())
218/3:
driver = login.driver
driver
218/4: login.login()
218/5:
driver = login.driver
driver
218/6:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
218/7:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
218/8:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
218/9:
#search_box = driver.find_element_by_class_name("_1frb")
#search_box
218/10: login.search_user("Mustafa Cagri Ardic")
218/11:
search_execute = driver.find_element_by_class_name("_585_")
search_execute
search_execute.click()
218/12:
search_execute = driver.find_element_by_class_name("_585_")
search_execute
search_execute.click()
218/13: login.search_user("Mustafa Cagri Ardic")
218/14: login.search_user("Mustafa Cagri Ardic")
218/15:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
219/1:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
219/2: login = LoginPage(InitialiseFacebook())
219/3: login.login()
219/4:
driver = login.driver
driver
219/5:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
219/6:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
219/7:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
219/8:
#search_box = driver.find_element_by_class_name("_1frb")
#search_box
219/9: login.search_user("Mustafa Cagri Ardic")
219/10: login.search_user("Mustafa Cagri Ardic")
219/11: driver
219/12: driver.find_element_by_class_name
219/13: login.search_user("Mustafa Cagri Ardic")
220/1:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
220/2: login = LoginPage(InitialiseFacebook())
220/3: login.login()
220/4:
driver = login.driver
driver
220/5:
#delay = 0.5
#WebDriverWait(driver, delay).until(EC.presence_of_element_located())
220/6:
#timeout = 5
#element_present = EC.presence_of_element_located((By.XPATH, '//*[@id="u_0_a"]'))
#WebDriverWait(driver, timeout).until(element_present)
220/7:
#my_name = driver.find_element_by_xpath('//*[@id="u_0_a"]/div[1]/div[1]/div/a/span/span')
#my_name.click()
220/8:
#search_box = driver.find_element_by_class_name("_1frb")
#search_box
220/9: login.search_user("Mustafa Cagri Ardic")
221/1:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
221/2: login = Login(InitialiseFacebook())
221/3: login = Login(InitialiseFacebook())
222/1:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
222/2: login = Login(InitialiseFacebook())
222/3: login.login()
222/4:
driver = login.driver
driver
222/5:
login = Login()
fb = Facebook(InitialiseFacebook())
222/6: fb = Facebook(InitialiseFacebook())
222/7:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
223/1:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
223/2:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
224/1:
%load_ext autoreload
%autoreload 1

from SeleniumFB import *
224/2: InitialiseFacebook
224/3: driver, data = InitialiseFacebook("www.facebook.com")
224/4: driver, data = InitialiseFacebook("https://www.facebook.com/")
224/5: login = Login(driver, data)
224/6: login = Login(driver, data)
224/7: login = Login(driver, data)
224/8: login = Login(driver, data)
225/1:
%load_ext autoreload
%autoreload 0.01

from SeleniumFB import *
225/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
225/3: login = Login(driver, data)
225/4: login = Login(driver, data)
225/5: login = Login(driver, data)
225/6: login = Login(driver, data)
225/7: login.login()
225/8: login = Login(driver, data)
225/9: login = Login(driver=driver, data=data)
225/10: driver, data = InitialiseFacebook("https://www.facebook.com/")
225/11: driver
225/12: login = Login(driver, data)
225/13: login = Login()
225/14: login = Login(driver, data)
225/15: login = Login(driver, data)
225/16: login = Login(driver, data)
225/17:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
226/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
226/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
226/3: driver, data
226/4: driver
226/5: login = Login(driver, data)
226/6: login.login()
226/7: fb = Facebook(driver)
226/8: fb = Facebook(driver)
227/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
227/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
227/3: driver
227/4: login = Login(driver, data)
227/5: login.login()
227/6: fb = Facebook(driver)
227/7: fb.search_user("Mustafa Cagri Ardic")
227/8: fb.driver
227/9: fb.driver.find_element_by_id("xt_uniq_3")
227/10: fb.driver.find_element_by_class_name("_77we")
227/11: test = fb.driver.find_element_by_class_name("_77we")
227/12:
test = fb.driver.find_element_by_class_name("_77we")
test.getAttribute
227/13:
test = fb.driver.find_element_by_class_name("_77we")
test.get_attribute("href")
227/14:
test = fb.driver.find_element_by_class_name("_77we")
a = test.get_attribute("href")
227/15: a
227/16:
test = fb.driver.find_element_by_class_name("_6v_0")
a = test.get_attribute("href")
227/17: a
227/18:
test = fb.driver.find_element_by_class_name("_6v_0")
a = test.get_attribute("stye")
227/19: a
227/20:
test = fb.driver.find_element_by_class_name("_6v_0")
test
227/21: a = test.get_attribute("stye")
227/22: a
227/23:
test = fb.driver.find_element_by_class_name("_6xu6")
test
227/24: a = list(get_attribute("href"))
227/25: a = list(test.get_attribute("href"))
227/26: a
227/27: a = test.get_attribute("href")
227/28: a
228/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
228/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
228/3: login = Login(driver, data)
228/4: login.login()
228/5: fb = Facebook(driver)
228/6: fb.search_user("Mustafa Cagri Ardic")
228/7:
test = fb.driver.find_element_by_class_name("_6xu6")
test
228/8: a = test.get_attribute("href")
228/9: a
228/10: driver.get(a)
228/11: driver, data = InitialiseFacebook("https://www.facebook.com/")
228/12: login = Login(driver, data)
228/13: login.login()
228/14: fb = Facebook(driver)
228/15: fb.search_user("Mustafa Cagri Ardic")
228/16: first_result_url = fb.search_user("Mustafa Cagri Ardic")
228/17: first_result_url
228/18: first_result, first_result_url = fb.search_user("Mustafa Cagri Ardic")
228/19: first_result, first_result_url = fb.search_user("Mustafa Cagri Ardic")
228/20: first_result, first_result_url = fb.search_user("Mustafa Cagri Ardic")
228/21: driver, data = InitialiseFacebook("https://www.facebook.com/")
228/22: login = Login(driver, data)
228/23: login.login()
228/24: fb = Facebook(driver)
228/25: first_result, first_result_url = fb.search_user("Mustafa Cagri Ardic")
228/26: fb.search_user("Mustafa Cagri Ardic")
229/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
229/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
229/3: login = Login(driver, data)
229/4: login.login()
229/5: fb = Facebook(driver)
229/6: fb.search_user("Mustafa Cagri Ardic")
229/7: fb.driver
229/8: fb.driver.find_element_by_class_name("fb")
229/9: fb.driver.find_element_by_class_name("_6xu6")
229/10: fb.search_user("Mustafa Cagri Ardic")
229/11: fb.search_user("Mustafa Cagri Ardic")
230/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
230/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
230/3: login = Login(driver, data)
230/4: login.login()
230/5: fb = Facebook(driver)
230/6: fb.search_user("Mustafa Cagri Ardic")
230/7: fb.search_user("Mustafa Cagri Ardic")
230/8: fb.search_user("Mustafa Cagri Ardic")
231/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
231/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
231/3: login = Login(driver, data)
231/4: login.login()
231/5: fb = Facebook(driver)
231/6: fb.search_user("Mustafa Cagri Ardic")
232/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
232/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
232/3: login = Login(driver, data)
232/4: login.login()
232/5: fb = Facebook(driver)
232/6: fb.search_user("Mustafa Cagri Ardic")
232/7: fb.search_user("Atalay Sahin")
232/8: fb.search_user("Gamze Aydin")
232/9: fb.search_user("Nursel Ardic")
232/10: fb.search_user("Gizem Altan")
232/11: fb.search_user('ali na')
232/12: fb.search_user('nursel ardic')
232/13: fb.driver
232/14: fb.driver.current_url
233/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
233/2: driver, data = InitialiseFacebook("https://www.facebook.com/")
233/3: login = Login(driver, data)
233/4: login.login()
233/5: login.login()
233/6: fb = Facebook(driver)
233/7: fb.search_user('atalay sahin')
233/8: fb.driver.current_url
233/9: fb.search_user('nursel ardic')
233/10: fb.driver.current_url
233/11: url = fb.driver.current_url
233/12: url
233/13: fb.search_user('nursel ardic')
233/14: user_id = re.compile("(?<=com\/).+(?=\?)")
233/15: import re
233/16: user_id_pattern = re.compile("(?<=com\/).+(?=\?)")
233/17: re.search(user_id_patter)
233/18: re.search(user_id_pattern)
233/19: re.search(user_id_pattern, url)
233/20: re.search(user_id_pattern, url).group()
233/21: user_id = re.search(user_id_pattern, url).group()
233/22: url = ''
233/23: url = 'https://www.facebook.com/atalay.sahin.5'
233/24: user_id_pattern = re.compile("(?<=com\/).+(?=\?)")
233/25: user_id = re.search(user_id_pattern, url).group()
234/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
234/2: import re
234/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
234/4: login = Login(driver, data)
234/5: login.login()
234/6: fb = Facebook(driver)
234/7: fb.search_user('nursel ardic')
235/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
235/2: import re
235/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
235/4: login = Login(driver, data)
235/5: login.login()
235/6: fb = Facebook(driver)
235/7: fb.search_user('nursel ardic')
235/8:
url = fb.driver.current_url
url
235/9: fb.getFriends
235/10: fb.getFriends()
235/11: fb.getFriends()
236/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
236/2: import re
236/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
236/4: login = Login(driver, data)
236/5: login.login()
236/6: fb = Facebook(driver)
236/7: fb.search_user('nursel ardic')
237/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
237/2: import re
237/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
237/4: login = Login(driver, data)
237/5: login.login()
237/6: fb = Facebook(driver)
237/7: fb.search_user('nursel ardic')
237/8:
url = fb.driver.current_url
url
237/9: fb.getFriends()
238/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
238/2: import re
238/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
238/4: login = Login(driver, data)
238/5: login.login()
238/6: fb = Facebook(driver)
238/7: fb.search_user('mustafa cagri ardic')
238/8: fb.getFriends()
238/9: fb.search_user('atalay sahin')
238/10: fb.search_user('atalay sahin kayahan')
238/11: fb.search_user('atalay sahin')
238/12: fb.getFriends()
238/13: fb.search_user('selahattin ozen')
238/14: fb.getFriends()
238/15: fb.driver
238/16: fb.driver.find_element_by_class_name("_3i9")
238/17: friend_list = fb.driver.find_element_by_class_name("_3i9")
238/18:
friend_list = fb.driver.find_element_by_class_name("_3i9")
friend_list.get_attribute("href")
238/19:
friend_list = fb.driver.find_element_by_class_name("5h60 _30f")
friend_list.get_attribute("href")
238/20:
friend_list = fb.driver.find_element_by_class_name("5h60 _30f")
#friend_list.get_attribute("href")
238/21:
friend_list = fb.driver.find_element_by_class_name("uiList _262m expandedList _4kg")
#friend_list.get_attribute("href")
238/22:
friend_list = fb.driver.find_element_by_class_name("_1qp6")
#friend_list.get_attribute("href")
238/23: friend_list
238/24:
friend_list = fb.driver.find_element_by_class_name("_698")
#friend_list.get_attribute("href")
238/25: friend_list
238/26: friend_list.get_attribute("href")
238/27:
friend_list = fb.driver.find_element_by_class_name("clearfix _5qo4")
#friend_list.get_attribute("href")
238/28:
friend_list = fb.driver.find_element_by_class_name("_698")
#friend_list.get_attribute("href")
238/29: friend_list.text
238/30: fb.driver.find_element_by_class_name("clearfix")
238/31: test = fb.driver.find_element_by_class_name("clearfix")
238/32: test.text
238/33: test = fb.driver.find_element_by_class_name("clearfix._50zj")
238/34: test = fb.driver.find_element_by_class_name("clearfix")
238/35:
a = [1,2,3]
b = a
a = a+[4]
238/36: b
238/37: a
238/38:
a = [1,2,3]
b = a
a.append(4)
238/39: b
238/40: a
238/41:
a = [1,2,3]
b = a
a.append(4)
238/42: a
238/43: b
238/44:
a = [1,2,3]
b = a
a = a + [4]
238/45: a
238/46: b
239/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
239/2: import re
239/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
239/4: login = Login(driver, data)
239/5: login.login()
239/6: fb.search_user('selahattin ozen')
239/7: fb = Facebook(driver)
239/8: fb.search_user('selahattin ozen')
239/9: fb.getFriends()
239/10: fb.driver.find_element_by_xpath('//*[@id="u_fetchstream_2_3"]/li[2]/a')
239/11: test = fb.driver.find_element_by_xpath('//*[@id="u_fetchstream_2_3"]/li[2]/a')
239/12: test.click()
239/13: fb.driver.find_element_by_class_name("_50f8")
239/14: fb.driver.find_element_by_class_name("_50f8").text
239/15: fb.driver.find_element_by_class_name("_6a _6b").text
239/16: fb.driver.find_element_by_class_name("_50f8").text
239/17: fb.driver.find_element_by_class_name("_50f8 _2iem").text
239/18: fb.driver.find_element_by_xpath('//*[@id="u_17_2"]/div[1]/ul/li[1]/div/div[2]/div/div[2]/span').text
239/19:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
240/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
240/2: import re
240/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
240/4: login = Login(driver, data)
240/5: login.login()
240/6: fb = Facebook(driver)
240/7: fb.search_user('selahattin ozen')
240/8: fb.search_user('selahattin ozen')
240/9: navigate_to_hakkinda = fb.driver.find_element_by_xpath('//*[@id="u_fetchstream_2_3"]/li[2]/a')
240/10: navigate_to_hakkinda = fb.driver.find_element_by_class_name('_6-6')
240/11:
navigate_to_hakkinda = fb.driver.find_element_by_class_name('_6-6')
navigate_to_hakkinda.click()
240/12:
hakkinda_url = fb.driver.find_element_by_class_name('_6-6')
hakkinda_url.get_attribute("href")
240/13:
hakkinda_url = fb.driver.find_element_by_class_name('_6-6')
hakkinda_url.get_attribute("href")
fb.driver(hakkinda_url)
240/14:
hakkinda_url = fb.driver.find_element_by_class_name('_6-6')
hakkinda_url.get_attribute("href")
fb.driver.get(hakkinda_url)
240/15:
hakkinda_class = fb.driver.find_element_by_class_name('_6-6')
hakkinda_url = hakkinda_class.get_attribute("href")
fb.driver.get(hakkinda_url)
240/16: hakkinda_url
240/17:
hakkinda_class = fb.driver.find_element_by_class_name('_6-6')
hakkinda_url = hakkinda_class.get_attribute("href")
240/18: hakkinda_url
240/19:
hakkinda_class = fb.driver.find_element_by_class_name('_6-6')
#hakkinda_url = hakkinda_class.get_attribute("href")
#fb.driver.get(hakkinda_url)
hakkinda_class.text
240/20: re.sub("timeline","about", hakkinda_url)hakkinda_url
240/21: re.sub("timeline","about", hakkinda_url)
240/22: fb.getHakkinda
241/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
241/2:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
241/3: import re
241/4: driver, data = InitialiseFacebook("https://www.facebook.com/")
241/5: login = Login(driver, data)
241/6: login.login()
241/7: fb = Facebook(driver)
241/8: fb.search_user('selahattin ozen')
241/9: fb.getFriends()
241/10: fb.getHakkinda()
241/11: fb.getHakkinda()
241/12: fb.getHakkinda()
241/13: fb.getHakkinda()
241/14: fb = Facebook(driver)
241/15: fb.getHakkinda()
242/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
242/2: import re
242/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
242/4: login = Login(driver, data)
242/5: login.login()
242/6: fb = Facebook(driver)
242/7: fb.search_user('selahattin ozen')
242/8: fb.getFriends()
242/9: fb.getHakkinda()
242/10: fb.getHakkinda()
242/11: fb.getHakkinda()
243/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
243/2: import re
243/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
243/4: login = Login(driver, data)
243/5: login.login()
243/6: fb = Facebook(driver)
243/7: fb.search_user('selahattin ozen')
243/8: fb.getFriends()
243/9: fb.getHakkinda()
243/10: fb.driver.find_element_by_class_name("_4ms4")
243/11: fb.driver.find_element_by_class_name("_4ms4").text
243/12: test = fb.driver.find_element_by_class_name("_4ms4").text
243/13: test.split("\n")
243/14: test_list = test.split("\n")
243/15:
for i in test_list:
    print(i)
243/16:
test = fb.driver.find_element_by_class_name("_4ms4").text
test
243/17: fb.search_user('Mustafa Cagri Ardic')
243/18: fb.getFriends()
243/19: fb.getHakkinda()
243/20: fb.getHakkinda()
243/21: fb.getHakkinda()
243/22: fb.driver.find_element_by_class_name('_6-6')()
243/23: fb.driver.find_element_by_class_name('_6-6')
243/24: fb.driver.find_element_by_class_name('_6-6').text
243/25: fb.driver.find_element_by_class_name('"_513x')
243/26: fb.driver.find_element_by_class_name('_513x')
243/27: fb.driver.find_element_by_class_name('_513x').text
243/28: fb.driver.find_element_by_class_name('_6-__513x')
243/29: fb.driver.find_element_by_class_name('_6-6_513x')
243/30: fb.driver.find_element_by_class_name('_6-6._513x')
243/31: fb.driver.find_element_by_css_selector('#u_0_17 > li:nth-child(2) > a')
243/32: fb.driver.find_element_by_css_selector('#u_0_17 > li:nth-child(2) > a').text
243/33:
test = fb.driver.find_element_by_css_selector('#u_0_17 > li:nth-child(2) > a')
test.get_attribute("href")
243/34:
test = fb.driver.find_element_by_css_selector('#u_0_17 > li:nth-child(2) > a')
test_url = test.get_attribute("href")
fb.driver.get(test_url)
244/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
244/2: import re
244/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
244/4: login = Login(driver, data)
244/5: login.login()
245/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
245/2: import re
245/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
245/4: login = Login(driver, data)
245/5: login.login()
245/6: login.login()
246/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
246/2: import re
246/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
246/4: login = Login(driver, data)
246/5: login.login()
246/6:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
246/7: import re
246/8: driver, data = InitialiseFacebook("https://www.facebook.com/")
247/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
247/2: import re
247/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
247/4: login = Login(driver, data)
247/5: login.login()
248/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
248/2: import re
248/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
248/4: login = Login(driver, data)
248/5: login.login()
248/6: driver.find_element_by_id("loginbutton")
248/7: driver.find_element_by_id("loginbutton").send_keys(Keys.ENTER)
248/8:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
248/9: import re
248/10: driver, data = InitialiseFacebook("https://www.facebook.com/")
248/11: driver.find_element_by_link_text("W3Schools XPath Tutorial")
248/12: driver.find_element_by_link_text("W3Schools XPath Tutorial").text
248/13: driver.find_element_by_link_text("W3Schools XPath Tutorial")
248/14: driver.find_element_by_link_text("W3Schools XPath Tutorial").text
248/15: driver.find_element_by_partial_link_text("W3School").text
248/16: driver.find_element_by_partial_link_text("W3").text
248/17: driver.find_element_by_partial_link_text("W3").get_attribute("href")
248/18: driver, data = InitialiseFacebook("https://www.facebook.com/")
248/19: login = Login(driver, data)
248/20: login.login()
249/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
249/2: import re
249/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
249/4: fb = Facebook(driver)
249/5: fb.search_user('Mustafa Cagri Ardic')
249/6: fb.getHakkinda()
249/7: fb.getFriends()
249/8: fb.getFriends()
249/9: fb.getHakkinda()
249/10: fb.search_user('Mustafa Cagri Ardic')
249/11: fb.getHakkinda()
249/12: test = fb.driver.find_element_by_css_selector('#u_0_2j')
249/13:
test = fb.driver.find_element_by_css_selector('#u_0_2j')
test
249/14:
test = fb.driver.find_element_by_css_selector('#u_0_2j')
test.text
249/15:
test = fb.driver.find_element_by_css_selector('#u_0_2j')
test.text.split(/n)
249/16:
test = fb.driver.find_element_by_css_selector('#u_0_2j')
test.text.split("\n")
249/17: fb.getHakkinda()
249/18: self.hakkinda_information_all
249/19: fb.hakkinda_information_all
249/20: fb.hakkinda_information_all
250/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
250/2: import re
250/3: driver, data = InitialiseFacebook("https://www.facebook.com/")
250/4: fb = Facebook(driver)
250/5: fb.search_user('Mustafa Cagri Ardic')
250/6: fb.getHakkinda()
250/7: fb.hakkinda_information_all
250/8: fb.hakkinda_information_all.text
250/9: fb.hakkinda_information_all
250/10: fb.hakkinda_information_all
251/1:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com
     "password":"amele123"
}
251/2:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com,
     "password":"amele123"
}
251/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
252/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
252/2: import re
252/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
252/4: login = Login(driver, data)
252/5: login.login()
252/6:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
252/7: import re
252/8:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
252/9: fb = Facebook(driver)
252/10: fb.search_user('Mustafa Cagri Ardic')
252/11: fb.getHakkinda()
252/12: fb.hakkinda_information_all
252/13: print(fb.hakkinda_information_all)
253/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
253/2: import re
253/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
253/4: login = Login(driver, data)
253/5: login.login()
254/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
254/2: import re
254/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
255/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
255/2: import re
255/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
255/4: login = Login(driver, data)
255/5: login.login()
255/6: fb.search_user('Mustafa Cagri Ardic')
255/7: fb = Facebook(driver)
255/8: fb.search_user('Mustafa Cagri Ardic')
255/9: fb.getFriends()
255/10: fb.getHakkinda()
255/11: print(fb.hakkinda_information_all)
255/12: hakkinda_information = fb.getHakkinda()
255/13: hakkinda_information = fb.getHakkinda()
255/14: hakkinda_information
255/15: hakkinda_information
255/16: hakkinda_information
256/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
256/2: import re
256/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
256/4: login = Login(driver, data)
256/5: login.login()
256/6: fb = Facebook(driver)
256/7: fb.search_user('Mustafa Cagri Ardic')
256/8: hakkinda_information = fb.getHakkinda()
256/9: hakkinda_information = fb.getHakkinda()
257/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
257/2: import re
257/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
257/4: login = Login(driver, data)
257/5: login.login()
257/6: fb = Facebook(driver)
257/7: fb.search_user('Mustafa Cagri Ardic')
257/8: fb.getFriends()
257/9: hakkinda_information = fb.getHakkinda()
257/10: hakkinda_information = fb.getHakkinda()
257/11: fb = Facebook(driver)
257/12: fb.search_user('Mustafa Cagri Ardic')
257/13: hakkinda_information = fb.getHakkinda()
258/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
258/2: import re
258/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
258/4: login = Login(driver, data)
258/5: login.login()
258/6: fb = Facebook(driver)
258/7: fb.search_user('Mustafa Cagri Ardic')
258/8: hakkinda_information = fb.getHakkinda()
258/9: fb._getHakkindaInformation
258/10: ())
258/11: fb._getHakkindaInformation()
258/12: hakkinda_information = fb.getHakkinda()
258/13: hakkinda_information = fb.getHakkinda()
258/14: hakkinda_information
258/15: fb = Facebook(driver)
258/16: fb.search_user('Mustafa Cagri Ardic')
258/17: fb.getFriends()
258/18: hakkinda_information = fb.getHakkinda()
260/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
260/2: import re
260/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
260/4: login = Login(driver, data)
260/5: login.login()
260/6: fb = Facebook(driver)
260/7: fb.search_user('Mustafa Cagri Ardic')
260/8: fb.getFriends()
260/9: hakkinda_information = fb.getHakkinda()
260/10: hakkinda_information = fb.getHakkinda()
260/11: hakkinda_information = fb.getHakkinda()
260/12: hakkinda_information = fb.getHakkinda()
260/13: hakkinda_information = fb.getHakkinda()
261/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
261/2: import re
261/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
261/4: login = Login(driver, data)
261/5: login.login()
261/6: fb = Facebook(driver)
261/7: fb.search_user('Mustafa Cagri Ardic')
261/8: hakkinda_information = fb.getHakkinda()
262/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
262/2: import re
262/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
262/4: login = Login(driver, data)
262/5: login.login()
262/6: fb = Facebook(driver)
262/7: fb.search_user('Mustafa Cagri Ardic')
262/8: hakkinda_information = fb.getHakkinda()
262/9: fb.getHakkindaInformation()
263/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
263/2: import re
263/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
263/4: login = Login(driver, data)
263/5: login.login()
263/6: fb = Facebook(driver)
263/7: fb.search_user('Mustafa Cagri Ardic')
263/8: #fb.getFriends()
263/9: hakkinda_information = fb.getHakkinda()
263/10: hakkinda_information = fb.getHakkinda()
263/11: hakkinda_information = fb.getHakkinda()
264/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
264/2: import re
264/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
264/4: login = Login(driver, data)
264/5: login.login()
264/6: fb = Facebook(driver)
264/7: fb.search_user('Mustafa Cagri Ardic')
264/8: hakkinda_information = fb.getHakkinda()
264/9: hakkinda_information
264/10: fb.getFriends()
264/11: fb.getFriends()
264/12: fb.search_user('Mustafa Cagri Ardic')
264/13: fb.getFriends()
264/14: driver.find_element_by_xpath('//*[@id="pagelet_timeline_medley_friends"]')
264/15: driver.find_element_by_xpath('//*[@id="pagelet_timeline_medley_friends"]').text
264/16: hakkinda_information
264/17: driver.find_element_by_xpath('//*[@id="collection_wrapper_2356318349"]').text
264/18: driver.find_element_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]').text
264/19: driver.find_element_by_class_name("_2w3")
264/20: driver.find_element_by_class_name("_2w3").text
264/21: driver.find_element_by_class_name("_6a").text
264/22: driver.find_element_by_class_name("uiProfileBlockContent").text
264/23: driver.find_element_by_xpath('clearfix _42ef').text
264/24: driver.find_element_by_id('js_v9')
264/25: driver.find_element_by_id('_698')
264/26: driver.find_element_by_class_name("_698").text
264/27:
all_spans = driver.find_elements_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]')
for span in all_spans:
    print span.text
264/28:
all_spans = driver.find_elements_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]')
for span in all_spans:
    print(span.text)
264/29:
all_spans = driver.find_elements_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]')
for span in all_spans:
    print(span.text)
264/30: all_spans = driver.find_elements_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]')
264/31: all_spans
264/32: all_spans.text
264/33:
all_spans = driver.find_elements_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]')
for span in all_spans:
    print(span.text)
264/34: driver.find_element_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]')
264/35: driver.find_element_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]').text
264/36:
test = driver.find_element_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]')
for i in test:
    print(i)
264/37: test = driver.find_element_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]')
264/38:
all_spans = driver.find_elements_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]/div/a/img')
all_spans.text
264/39:
all_spans = driver.find_elements_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]/div/a/img')
for text in all_spans:
    print(text)
264/40:
all_spans = driver.find_elements_by_xpath('//*[@id="pagelet_timeline_app_collection_100006506431074:2356318349:2"]/ul[1]/li[1]/div/a/img')
for text in all_spans:
    print(text.text)
264/41: driver.find_element_by_class_name('clearfix _5qo4')
264/42: driver.find_element_by_class_name('#pagelet_timeline_app_collection_100006506431074\:2356318349\:2 > ul:nth-child(2) > li:nth-child(1) > div')
264/43: driver.find_element_by_css_selector('#pagelet_timeline_app_collection_100006506431074\:2356318349\:2 > ul:nth-child(2) > li:nth-child(1) > div')
264/44: test = driver.find_element_by_css_selector('#pagelet_timeline_app_collection_100006506431074\:2356318349\:2 > ul:nth-child(2) > li:nth-child(1) > div')
264/45: test.text
264/46:
all_spans = driver.find_elements_by_xpath("//span[@class='_698']")
for text in all_spans:
    print(text)
264/47:
all_spans = driver.find_elements_by_xpath("//span[@class='_698']")
for text in all_spans:
    print(text)
264/48: driver.find_element_by_tag_name('img')
264/49: driver.find_element_by_tag_name('img').text
264/50: driver.find_element_by_tag_name('img')
264/51:
test = driver.find_element_by_tag_name('img')

for text in test:
    print(text.text)
264/52:
test = driver.find_element_by_tag_name('img')

test
264/53:
test = driver.find_element_by_tag_name('img')

test.text
264/54:
test = driver.find_element_by_tag_name('a')

test.text
264/55: content_blocks = driver.find_element_by_class_name("_3i9")
264/56:
for block in content_blocks:
    print("block")
265/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
265/2: import re
265/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
265/4: login = Login(driver, data)
265/5: login.login()
265/6: fb = Facebook(driver)
265/7: fb.search_user('Mustafa Cagri Ardic')
265/8: fb.getFriends()
265/9: hakkinda_information = fb.getHakkinda()
265/10: hakkinda_information
265/11: driver.find_element_by_class_name("_5pwr")
265/12: driver.find_element_by_class_name("_5pwr").text
265/13: driver.find_element_by_class_name("_5pws").text
265/14: driver.find_element_by_class_name("_2iem").text
265/15: driver.find_element_by_class_name("_2iem").text
265/16: driver.find_element_by_class_name("_698").text
265/17: driver.find_element_by_id("pagelet_timeline_app_collection_100006506431074:2327158227:8").text
265/18: driver.find_element_by_id("pagelet_timeline_app_collection_100006506431074:2327158227:8").text.split('\n')
265/19: fb.getFriends()
265/20: fb.search_user('Mustafa Cagri Ardic')
265/21: fb.getFriends()
265/22: driver.find_element_by_class_name("_698").text
265/23: import beautifulsoup4
265/24: import BeautifulSoup
266/1: import re
266/2:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
266/3: import re
266/4:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
266/5: login = Login(driver, data)
266/6: login.login()
266/7: fb = Facebook(driver)
266/8: fb.search_user('Mustafa Cagri Ardic')
266/9: fb.getFriends()
266/10: hakkinda_information = fb.getHakkinda()
266/11: hakkinda_information
266/12: fb.getFriends()
266/13: import requests
266/14: fb.search_user('Mustafa Cagri Ardic')
266/15: fb.getFriends()
266/16: url = driver.current_url
266/17:
url = driver.current_url
url
266/18:
import requests
from bs4 import BeautifulSoup
266/19: html_soup = BeautifulSoup(url.text, 'html.parser')
266/20:
url = driver.current_url
response = get(url)
266/21:
from requests import get
from bs4 import BeautifulSoup
266/22:
url = driver.current_url
response = get(url)
266/23: html_soup = BeautifulSoup(response.text, 'html.parser')
266/24: response.text
266/25: html_soup.find_all('div', class_ = '_s0 _4ooo _1x2_ _1ve7 _rv img')
266/26: html_soup.find_all('div', class_ = '_698')
266/27: html_soup.find_all('div')
266/28: html_soup.find_all('div', class_ = '_5h60 _30f')
266/29: html_soup.find_all('div', class_ = '_5h60 _30f').a
266/30: html_soup.find_all('div', class_ = '_5h60 _30f').li
266/31: html_soup.find_all('div', class_ = '_5h60 _30f')
266/32: movie_containers = html_soup.find_all('div', class_ = '_5h60 _30f')
266/33: len(movie_containers)
266/34: movie_containers
266/35: movie_containers = html_soup.find_all('div', class_ = 'uiList _262m _4kg')
266/36: movie_containers
266/37: movie_containers = html_soup.find_all('div', class_ = '_5h60 _30f')
266/38: movie_containers
266/39: movie_containers = html_soup.find_all('li', class_ = '_698')
266/40: movie_containers
266/41: movie_containers = html_soup.find_all('ul', class_ = '_698')
266/42: movie_containers
266/43: movie_containers = html_soup.find_all('ul', class_ = '_5h60 _30f')
266/44: movie_containers
266/45: movie_containers = html_soup.find_all('div?', class_ = '_5h60 _30f')
266/46: movie_containers = html_soup.find_all('div', class_ = '_5h60 _30f')
266/47: movie_containers
266/48: type(movie_containers)
266/49: movie_containers
266/50: movie_containers.div
266/51: movie_containers = html_soup.find('div', class_ = '_5h60 _30f')
266/52: movie_containers.div
266/53: movie_containers
266/54: movie_containers.div
266/55: movie_containers.div.ul
266/56: movie_containers.div.ul.a
266/57: movie_containers
266/58: movie_containers = html_soup.find('div', id = 'pagelet_timeline_app_collection_100006506431074:2356318349:2f')
266/59: movie_containers
266/60: movie_containers = html_soup.find('div', id_ = 'pagelet_timeline_app_collection_100006506431074:2356318349:2')
266/61: movie_containers
266/62: movie_containers = html_soup.find('div', class_ = '_5h60 _30f')
266/63: movie_containers
266/64: movie_containers.ul
266/65: movie_containers.ul.li
266/66: movie_containers.ul.li.div
266/67: movie_containers.ul.li.div.a
266/68: movie_containers.ul.li.li.div.a
266/69: movie_containers.ul.li.li
266/70: movie_containers.ul.li
266/71: movie_containers.ul.li.div.a
266/72: movie_containers.ul.li.div.a.img
266/73: movie_containers.ul.li.div.a.img.aria-label
266/74: movie_containers.ul.li.div.a.img.text
266/75: movie_containers.ul.li.div.a.img
266/76:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
266/77: import re
266/78:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
266/79: login = Login(driver, data)
266/80: login.login()
266/81: fb.search_user('Mustafa Cagri Ardic')
266/82: fb.search_user('Mustafa Cagri Ardic')
266/83: fb = Facebook(driver)
266/84: fb.search_user('Mustafa Cagri Ardic')
266/85: fb.getFriends()
266/86:
from requests import get
from bs4 import BeautifulSoup
266/87:
url = driver.current_url
response = get(url)
266/88: html_soup = BeautifulSoup(response.text, 'html.parser')
266/89: movie_containers = html_soup.find('div', class_ = '_5h60 _30f')
266/90: movie_containers.ul.li.div.a.img
266/91: movie_containers.ul
266/92: movie_containers.ul.li.div.a
266/93: movie_containers.ul.li.div.a.img
266/94: movie_containers.ul.li.div.a.img.alt
266/95: movie_containers.ul.li.div.a.img
266/96: movie_containers.ul.li.div.a.img.alt()
266/97: movie_containers.ul.li.div.a.img.find(attrs={"alt" : "stainfo"})
266/98: movie_containers.ul.li.div.a.img.find(attrs={"alt" : ""})
266/99: movie_containers.ul.li.div.a.img
266/100: movie_containers.ul.li.div.a.img.src
266/101: movie_containers.ul.li.div.a.img.find('src')
266/102: movie_containers.ul.li.div.a.img['src']
266/103: movie_containers.ul.li.div.div.duv['style']
266/104: movie_containers.ul.li.div.div.div['style']
266/105: movie_containers.ul.li.div.div
266/106: movie_containers.ul.li.div
266/107: movie_containers.ul.li.div.div
266/108: movie_containers.ul.li.div.div.div
266/109: movie_containers.ul.li.div.div.div.duv
266/110: movie_containers.ul.li.div.div.div
266/111: movie_containers.ul.li.div.div.div.a
266/112: movie_containers.ul.li.div.div.div.div
275/1:
class Deck(object):
    
    def __init__(self,suits,ranks):
        self.suit = suits
        self.rank = ranks
275/2:
suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
275/3: Cards(suits[0], ranks[0])
275/4:
class Cards(object):
    
    def __init__(self,suits,ranks):
        self.suit = suits
        self.rank = ranks
275/5:
suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
275/6: cards = Cards()
275/7: cards = Cards(suits[0], ranks[0])
275/8: cards
275/9: cards.suit
275/10:
for suit in suits:
    for rank in ranks:
        cards = Cards(suit,rank)
275/11: cards
275/12: cards.suit
275/13:
attrs = vars(cards)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/14:
class Cards(object):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
    def __init__(self,suits,ranks):
        for suit in suits:
            for rank in ranks:
                self.suit = suits
                self.rank = ranks
275/15:
class Cards(object):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
    def __init__(self):
        for suit in suits:
            for rank in ranks:
                self.suit = suits
                self.rank = ranks
275/16: cards = Cards()
275/17:
attrs = vars(cards)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/18: cards.suit
275/19:
class Cards(object):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
    def __init__(self):
        for suit in suits:
            for rank in ranks:
                self.suit = suit
                self.rank = rank
275/20: cards = Cards()
275/21:
attrs = vars(cards)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/22: cards.suit
275/23:
attrs = vars(cards)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/24: cards.suit
275/25:
class Cards(object):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
    def __init__(self):
        for suit in suits:
            for rank in ranks:
                self.suit = suit
                self.rank = rank
275/26: cards = Cards()
275/27:
attrs = vars(cards)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/28: cards.suit
275/29:
class Deck(Cards):
    
    def __init__():
        deck = []
        self.deck = deck.append(super().__init__())
275/30: cards = Cards()
275/31: Deck
275/32: deck = Deck()
275/33:
class Deck(Cards):
    
    def __init__(self):
        deck = []
        self.deck = deck.append(super().__init__())
275/34: cards = Cards()
275/35: deck = Deck()
275/36:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/37:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/38:
class Deck(Cards):
    
    def __init__(self):
        deck = []
        self.deck = deck.append(super().__init__(self))
275/39: cards = Cards()
275/40: deck = Deck()
275/41:
class Deck(Cards):
    
    def __init__(self):
        deck = []
        self.deck = deck.append(super().__init__())
275/42: cards = Cards()
275/43: deck = Deck()
275/44:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/45: cards.suit
275/46:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                deck.append(super().__init__(suit,rank))
275/47: cards = Cards()
275/48: deck = Deck()
275/49:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
275/50:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                deck.append(super().__init__(suit,rank))
275/51: cards = Cards()
275/52: deck = Deck()
275/53:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
275/54:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                deck.append(super().__init__(suit,rank))
275/55: deck = Deck()
275/56:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/57:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/58: deck = Deck()
275/59:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/60: Cards.suit
275/61: Cards(*)
275/62: Cards()
275/63:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        self.deck = deck
        for suit in suits:
            for rank in ranks:
                deck.append(super().__init__(suit,rank))
275/64: deck = Deck()
275/65:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/66:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(super().__init__(suit,rank))
275/67: deck = Deck()
275/68:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/69:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                deck.append(super().__init__(suit,rank))
                self.deck = deck
275/70: deck = Deck()
275/71:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/72:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                deck.append(super().__init__(suit,rank))
275/73: deck = Deck()
275/74:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/75:

deck.deck
275/76: deck.deck
275/77:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                deck.append(super().__init__(suit,rank))
275/78: deck = Deck()
275/79:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/80:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                deck.append(super().__init__(suit,rank))
                print(deck)
275/81: deck = Deck()
275/82:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/83:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        deck = []
        for suit in suits:
            for rank in ranks:
                print(suit,rank)
                deck.append(super().__init__(suit,rank))
275/84: deck = Deck()
275/85:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        self.deck = []
        for suit in suits:
            for rank in ranks:
                print(suit,rank)
                self.deck.append(super().__init__(suit,rank))
275/86: deck = Deck()
275/87:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/88: deck = Deck()
275/89:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        self.deck = []
        for suit in suits:
            for rank in ranks:
                #print(suit,rank)
                self.deck.append(Cards(suit,rank))
275/90: deck = Deck()
275/91:
attrs = vars(deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/92: deck.deck
275/93: deck.deck[0]
275/94: deck.deck
275/95: deck.deck[0]
275/96: next(deck.deck[0])
275/97: deck.deck[0]
275/98: deck.deck[0].suit
275/99: deck.deck
275/100:
attrs = vars(deck.deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/101:
attrs = vars(deck.deck)

print(', '.join("%s: %s" % item for item in attrs.items()))
275/102:
attrs = vars(deck.deck[0])

print(', '.join("%s: %s" % item for item in attrs.items()))
275/103:
attrs = [vars(cards) for cards in deck.deck]

print(', '.join("%s: %s" % item for item in attrs.items()))
275/104:
attrs = [vars(cards) for cards in deck.deck]
attrs
275/105:
attrs = [vars(cards) for cards in deck.deck]
attrs.items()
275/106:
attrs = [vars(cards) for cards in deck.deck]
attrs[0].items()
275/107:
attrs = [vars(cards) for cards in deck.deck]
"-".join(attrs[0].items())
275/108: print(', '.join("%s: %s" % item for item in attrs.items()))
275/109: attrs[0].items()
275/110: attrs[0]
275/111: attrs[0].values()
275/112:
attrs = [vars(cards) for cards in deck.deck]
"-".join(attrs[0].values())
275/113:
attrs = [vars(cards) for cards in deck.deck]
test = ["-".join(values.values()) for values in attrs]
275/114:
attrs = [vars(cards) for cards in deck.deck]
values = ["-".join(values.values()) for values in attrs]
275/115: values
276/1:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
276/2:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
276/3: deck = Deck()
276/4:
attrs = [vars(cards) for cards in deck.deck]
values = ["-".join(values.values()) for values in attrs]
276/5:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
276/6:
class Deck(Cards):
    
    suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
    ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
 
    def __init__(self):
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
276/7: deck = Deck()
276/8:
attrs = [vars(cards) for cards in deck.deck]
values = ["-".join(values.values()) for values in attrs]
276/9:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
276/10: deck = Deck()
276/11:
attrs = [vars(cards) for cards in deck.deck]
values = ["-".join(values.values()) for values in attrs]
276/12:
class Cards(object):
  
    def __init__(self,suit,rank):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        
        self.suit = suit
        self.rank = rank
276/13:
class Deck(Cards):
 
    def __init__(self):

    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
276/14: deck = Deck()
276/15:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
276/16:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
276/17: deck = Deck()
276/18:
attrs = [vars(cards) for cards in deck.deck]
values = ["-".join(values.values()) for values in attrs]
276/19: values
276/20: import random
276/21:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
276/22:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
276/23: from random import shuffle
276/24:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
276/25:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
276/26: test_list = [1,2,34]
276/27:
test_list = [1,2,3,4]
test_list
276/28: test_list.shuffle()
276/29: shuffle(test_list)
276/30: test = shuffle(test_list)
276/31:
test = shuffle(test_list)
test
276/32: shuffle(test_list)
276/33:
test_list = [[1],[2],[3],[4]]
test_list
276/34: shuffle(test_list)
276/35:
shuffle(test_list)
test_list
276/36:
test_list = shuffle(test_list)
test_list
276/37: deck = Deck()
276/38:
test_list = [1,2,3,4]
test_list
276/39: test_list = shuffle(test_list)
276/40: test_list = random.shuffle(test_list)
276/41:
test_list = [1,2,3,4]
test_list
276/42: test_list = random.shuffle(test_list)
276/43:
test_list = random.shuffle(test_list)
test_list
276/44:
test_list = [1,2,3,4]
test_list
276/45:
test_list = random.shuffle(test_list)
test_list
276/46: random.shuffle(test_list)
276/47:
test_list = [1,2,3,4]
test_list
276/48: random.shuffle(test_list)
276/49: import random
276/50:
test_list = [1,2,3,4]
test_list
276/51: random.shuffle(test_list)
276/52:
random.shuffle(test_list)
test_list
276/53: test_list
276/54:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        self.deck = shuffle(self.deck)
276/55: deck = Deck()
276/56:
attrs = [vars(cards) for cards in deck.deck]
values = ["-".join(values.values()) for values in attrs]
276/57: values
276/58:
deck = Deck()
deck.shuffle()
276/59:
attrs = [vars(cards) for cards in deck.deck]
values = ["-".join(values.values()) for values in attrs]
276/60: values
276/61: deck.deck
276/62:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
276/63:
deck = Deck()
deck.shuffle()
276/64: deck.deck
276/65:
attrs = [vars(cards) for cards in deck.deck]
values = ["-".join(values.values()) for values in attrs]
276/66: values
276/67:
class Player(object):
    
    def __init__(self,money):
        self.money = money
276/68: input("How much are you betting?")
276/69: bet = input("How much are you betting?")
276/70:
def askBet():
    
    bet = input("How much are you betting?")
    if type(bet) is not integer:
        raise "Please provide an integer"
276/71: askBet()
276/72:
def askBet():
    
    bet = input("How much are you betting?")
    if type(bet) is not int:
        raise "Please provide an integer"
276/73: askBet()
276/74:
def askBet():
    
    bet = input("How much are you betting?")
    if type(bet) is not int:
        raise Exception("Please provide an integer")
276/75: askBet()
276/76: player_1 = Player(500)
276/77:
def askBet(self, player):
    bet_control = False
    
    while bet_control False:
        bet = input("How much are you betting?")
        if type(bet) is int or bet>0:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease provide a valid value!")
276/78:
def askBet(self, player):
    bet_control = False
    
    while bet_control is False:
        bet = input("How much are you betting?")
        if type(bet) is int or bet>0:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease provide a valid value!")
276/79:
class BlackJack(Player):
    
    def __init__(self):
        super().__init__(500)
    
    def askBet(self, player):
    bet_control = False
    
    while bet_control is False:
        bet = input("How much are you betting?")
        if type(bet) is int or bet>0:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease provide a valid value!")
276/80:
class BlackJack(Player):
    
    def __init__(self):
        super().__init__(500)
    
    def askBet(self, player):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            if type(bet) is int or bet>0:
                self.money -= bet
                bet_control = True
            else:
                print("\nPlease provide a valid value!")
276/81:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        
    def getBet(self, bet):
        self.money -= bet
276/82:
class Player(object):
    
    def __init__(self,money):
        self.money = money
276/83:
class BlackJack(Player):
    
    def __init__(self):
        super().__init__(500)
    
    def getBet(self, player):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            if type(bet) is int or bet>0:
                self.money -= bet
                bet_control = True
            else:
                print("\nPlease provide a valid value!")
276/84:
class Player(object):
    
    def __init__(self,money):
        self.money = money
276/85: player = BlackJack()
276/86: player.getBet()
276/87:
class BlackJack(Player):
    
    def __init__(self):
        super().__init__(500)
    
    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            if type(bet) is int or bet>0:
                self.money -= bet
                bet_control = True
            else:
                print("\nPlease provide a valid value!")
276/88: player = BlackJack()
276/89: player.getBet()
277/1: import random
277/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
277/3:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
277/4:
class Player(object):
    
    def __init__(self,money):
        self.money = money
277/5:
class BlackJack(Player):
    
    def __init__(self):
        super().__init__(500)
    
    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                int(bet)
            if type(bet) is int or bet>0:
                self.money -= bet
                bet_control = True
            else:
                print("\nPlease provide a valid value!")
277/6:
class BlackJack(Player):
    
    def __init__(self):
        super().__init__(500)
    
    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = True
            except:
                print("\nPlease provide a valid value!")
277/7: player = BlackJack()
277/8: player.getBet()
280/1: import random
280/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
280/3:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
280/4:
class Player(object):
    
    def __init__(self,money):
        self.money = money
280/5:
class BlackJack(Player):
    
    def __init__(self):
        super().__init__(500)
    
    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = True
                else:
                    print("\nPlease provide a positive value!")
            except:
                print("\nPlease provide a valid value!")
280/6: player = BlackJack()
280/7: player.getBet()
281/1: import random
281/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
281/3:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
281/4:
class Player(object):
    
    def __init__(self,money):
        self.money = money
281/5:
class BlackJack(Player):
    
    def __init__(self):
        super().__init__(500)
    
    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = True
                else:
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
281/6: player = BlackJack()
281/7: player.getBet()
281/8:
%load_ext autoreload
%autoreload 0.1

from blackjack import *
281/9: player = BlackJack()
281/10: player.getBet()
281/11: player.getBet()
281/12: askBet()
281/13: player = BlackJack()
281/14: player.getBet()
281/15: askBet()
281/16: player.bet
281/17: player
281/18: player()
281/19: Player.bet
281/20: player.money
281/21:
%load_ext autoreload
%autoreload 0.1

from blackjack import *
281/22: player = BlackJack()
281/23: player.getBet()
281/24: player.money
281/25: player.money
281/26:
%load_ext autoreload
%autoreload 0.1

from blackjack import *
281/27: player = BlackJack()
281/28: player.getBet()
281/29: player.getBet()
281/30: player.money
281/31: player.money
281/32: player.money
281/33: player.money
281/34: player.money
281/35: player = BlackJack()
281/36: player.getBet()
281/37: player.money
281/38: player.money
281/39: player = BlackJack()
281/40: player.getBet()
281/41: player.money
283/1:
%load_ext autoreload
%autoreload 0.1

from blackjack import *
283/2: player = BlackJack()
283/3: player.getBet()
284/1:
%load_ext autoreload
%autoreload 0.1

from blackjack import *
284/2: import random
284/3:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
284/4:
class Player(object):
    
    def __init__(self,money):
        self.money = money
284/5:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    Player.money = Player.money - bet
                    print(Player.money)
                    bet_control = True
                else:
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
284/6: player = BlackJack()
284/7: player.getBet()
285/1: import random
285/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
285/3:
class Player(object):
    
    def __init__(self,money):
        self.money = money
285/4:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet*1 > 0:
                    Player.money = Player.money - bet
                    print(Player.money)
                    bet_control = True
                else:
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
285/5: player = BlackJack()
285/6: import random
285/7:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
285/8:
class Player(object):
    
    def __init__(self,money):
        self.money = money
285/9:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet*1 > 0:
                    Player.money = Player.money - bet
                    print(Player.money)
                    bet_control = True
                else:
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
285/10: player = BlackJack()
285/11: player.getBet()
286/1: import random
286/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
286/3:
class Player(object):
    
    def __init__(self,money):
        self.money = money
286/4:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet*1 > 0:
                    self.money -= bet
                    print(Player.money)
                    bet_control = True
                else:
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
286/5: import random
286/6:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
286/7:
class Player(object):
    
    def __init__(self,money):
        self.money = money
286/8:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet*1 > 0:
                    self.money -= bet
                    print(Player.money)
                    bet_control = True
                else:
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
286/9: player = BlackJack()
286/10: player.getBet()
287/1: import random
287/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
287/3:
class Player(object):
    
    def __init__(self,money):
        self.money = money
287/4:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
287/5:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    self.money -= bet
                    print(Player.money)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
287/6: player = BlackJack()
287/7: player.getBet()
288/1: import random
288/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
288/3:
class Player(object):
    
    def __init__(self,money):
        self.money = money
288/4:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
288/5:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    self.money -= bet
                    print(Player.money)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
288/6: player = BlackJack()
288/7: player.getBet()
289/1: import random
289/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
289/3:
class Player(object):
    
    def __init__(self,money):
        self.money = money
289/4:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
289/5:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            print(bet)
            try:
                bet = int(bet)
                if bet > 0:
                    self.money -= bet
                    print(Player.money)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
289/6: import random
289/7:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
289/8:
class Player(object):
    
    def __init__(self,money):
        self.money = money
289/9:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
289/10:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            print(bet)
            try:
                bet = int(bet)
                if bet > 0:
                    self.money -= bet
                    print(Player.money)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except:
                print("\nPlease provide a valid value!\n")
289/11: player = BlackJack()
289/12: player.getBet()
290/1: int("str")
290/2: int("str")
290/3: import random
290/4:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
290/5:
class Player(object):
    
    def __init__(self,money):
        self.money = money
290/6:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
290/7:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            print(bet)
            try:
                bet = int(bet)
                if bet > 0:
                    self.money -= bet
                    print(Player.money)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
290/8: player = BlackJack()
290/9: player.money
290/10: player.getBet()
290/11:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    self.money -= bet
                    print(self.money)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
290/12: player = BlackJack()
290/13: player.money
290/14: player.getBet()
290/15: player.money
290/16:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        
    def update_money(self,bet):
        if bet < self.money:
            self.money -= bet
        else:
            print("\nPlease bet less than what you currently have: %\n" % self.money)
            bet_control
290/17:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
290/18: ("\nPlease bet less than what you currently have: %\n" % player.money)
290/19: print("\nPlease bet less than what you currently have: %\n" % player.money)
290/20: print("\nPlease bet less than what you currently have: %s\n" % player.money)
290/21:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    Player.update_money(bet)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
290/22: player = BlackJack()
290/23: player.money
290/24: player.getBet()
290/25:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    update_money(bet)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
290/26: player = BlackJack()
290/27: player.money
290/28: player.getBet()
290/29:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    super(BlackJack, self).update_money()
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
290/30: player = BlackJack()
290/31: player.money
290/32: player.getBet()
290/33:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    super(BlackJack, self).update_money(bet)
                    bet_control = True
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
290/34: player = BlackJack()
290/35: player.money
290/36: player.getBet()
290/37: player.money
290/38:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        
    def update_money(self,bet):
        if bet < self.money:
            self.money -= bet
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            return bet_control = False
290/39:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        
    def update_money(self,bet):
        if bet < self.money:
            self.money -= bet
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            return (bet_control = False)
290/40:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
290/41:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        
    def update_money(self,bet):
        if bet < self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
290/42:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
290/43:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
290/44: player = BlackJack()
290/45: player.money
290/46: player.getBet()
290/47: player.money
290/48:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
290/49: player = BlackJack()
290/50: player.money
290/51: player.getBet()
291/1:
class BlackJack(Player):
    call_func = super(BlackJack, self)
    
    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/2:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/3: import random
291/4:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
291/5:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
291/6:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
291/7:
class BlackJack(Player):
    call_func = super(BlackJack, self)

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/8:
class BlackJack(Player):

    def __init__(self):
        call_func = super(BlackJack, self)
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/9: player = BlackJack()
291/10:
class BlackJack(Player):

    def __init__(self):
        call_func = super(BlackJack, self)
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = call_func.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/11: player = BlackJack()
291/12: player.money
291/13: player.getBet()
291/14:
class BlackJack(Player):

    def __init__(self):
        call_func = super(BlackJack, self)
        print(call_func)
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = call_func.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/15: player = BlackJack()
291/16: player.money
291/17: player.getBet()
291/18:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting?")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/19: player = BlackJack()
291/20: player.money
291/21: player.getBet()
291/22:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/23: player = BlackJack()
291/24: player.money
291/25: player.getBet()
291/26: player.money
291/27: askBet()
291/28:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/29: player = BlackJack()
291/30: player.money
291/31: player.getBet()
291/32: player.money
291/33:
class BlackJack(Player):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
291/34: player = BlackJack()
291/35: player.money
291/36: player.getBet()
292/1: import random
292/2:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
292/3:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
292/4:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
292/5:
class BlackJack(Player, Decks):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
292/6: import random
292/7:
class Cards(object):
  
    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
292/8:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
292/9:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
292/10:
class BlackJack(Player, Decks):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
292/11: player = BlackJack()
292/12:
class BlackJack(Player, Decks):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        pass
292/13:
class BlackJack(Player, Deck):

    def __init__(self):
        super().__init__(500)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        pass
292/14: player = BlackJack()
292/15: player.money
292/16: player.getBet()
292/17: player.money
292/18: #player.getBet()
292/19: player.money
292/20: player.deck
292/21:
class BlackJack(Player, Deck):

    def __init__(self):
        Player.__init__(500)
        Deck.__init__()

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        pass
292/22: player = BlackJack()
292/23:
class BlackJack(Player, Deck):

    def __init__(self):
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        pass
292/24: player = BlackJack()
292/25: player.money
292/26: #player.getBet()
292/27: player.money
292/28: player.deck
292/29: player.deck.deck
292/30: player.deck
292/31: player.deck[0]
292/32: vars(player.deck[0])
292/33: player.deck[0]
292/34:
class BlackJack(Player, Deck):

    def __init__(self):
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        pass
292/35: player = BlackJack()
292/36: player.money
292/37: player.getBet()
292/38: player.money
292/39: player.deck[0]
292/40:
class BlackJack(Player, Deck):

    def __init__(self):
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        print(self.deck)
292/41: player = BlackJack()
292/42: player.money
292/43: player.getBet()
292/44: player.money
292/45: player.dealCards()
292/46:
deck = Deck()
deck.shuffle()
292/47:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle(self):
        shuffle(self.deck)
292/48:
deck = Deck()
deck.shuffle()
292/49: import random
292/50:
deck = Deck()
deck.shuffle()
292/51:
deck = Deck()
deck.shuffle_cards()
292/52:
deck = Deck()
deck
292/53:
deck = Deck()
deck.deck
292/54:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle_cards(self):
        shuffle(self.deck)
292/55:
deck = Deck()
deck.shuffle_cards
292/56:
deck = Deck()
deck.shuffle_cards()
292/57: test = [1,2,3,4]
292/58: shuffle(test)
292/59: random.shuffle(test)
292/60: test
292/61:
import random
import numpy as np
292/62: np.random.shuffle(test)
292/63: test
292/64:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
292/65:
class BlackJack(Player, Deck):

    def __init__(self):
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        print(self.deck)
292/66: player = BlackJack()
292/67: player.money
292/68: player.getBet()
292/69: player.money
292/70: int("str")
292/71:
deck = Deck()
deck.shuffle_cards()
292/72: deck.decks
292/73: deck.deck
292/74: vars(deck.deck)
292/75:
cards = [vars(elements) for elements in deck.deck]
cards
292/76: deck = Deck()
292/77:
cards = [vars(elements) for elements in deck.deck]
cards
292/78: deck.shuffle_cards()
292/79: player = BlackJack()
292/80: player.money
292/81: player.getBet()
292/82: player.money
292/83: deck = Deck()
292/84: deck.deck
292/85:
cards = [vars(elements) for elements in deck.deck]
cards
292/86: deck.deck[0]
292/87: vars(deck.deck[0])
292/88:
class Dealer(object):
    
    def __init__(self):
        self.cards =
292/89:
class Dealer(object):
    
    def __init__(self):
        self.cards = None
292/90: test
292/91: random.shuffle(test)
292/92: test
292/93: test.pop()
292/94: test.pop(1)
292/95: test
292/96: test = [1,2,3,4]
292/97: random.shuffle(test)
292/98:
random.shuffle(test)
test
292/99: test = [1,2,3,4]
292/100:
random.shuffle(test)
test
292/101: test.pop(0)
292/102: test
292/103: test = [1,2,3,4]
292/104:
random.shuffle(test)
test
292/105: test.pop((0,1))
292/106: test.pop([0,1])
292/107:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards <= 2:
            self.pcards = self.deck.pop(0)
            self.dcards = self.deck.pop(0)
            cards += 1
292/108: player = BlackJack()
292/109: player.money
292/110: player.getBet()
292/111: player.money
292/112: player.dealCards
292/113: player.dealCards()
292/114: player.pcards
292/115: vars(player.pcards)
292/116:
class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
292/117:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []
292/118:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
    
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
292/119:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards <= 2:
            self.pcards = self.deck.pop(0)
            self.dcards = self.deck.pop(0)
            cards += 1
292/120:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards <= 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
292/121: player = BlackJack()
292/122: player.money
292/123: player.getBet()
292/124: player.money
292/125: player.dealCards()
292/126: vars(player.pcards)
292/127:
cards = [vars(elements) for elements in player.pcards]
cards
292/128:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
292/129: player = BlackJack()
292/130: player.money
292/131: player.getBet()
292/132: player.money
292/133: player.dealCards()
292/134: vars()
292/135:
cards = [vars(elements) for elements in player.pcards]
cards
292/136:
cards = [vars(elements) for elements in player.dcards]
cards
292/137: len(player.deck)
292/138:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        
        print(self.pcards)
292/139: player.showCards()
292/140:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        
        print(self.pcards)
292/141: player = BlackJack()
292/142: player.money
292/143: player.getBet()
292/144: player.money
292/145: player.dealCards()
292/146: deck = Deck()
292/147: player.showCards()
292/148:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        
        print(vars(self.pcards))
292/149: player = BlackJack()
292/150: player.money
292/151: player.getBet()
292/152: player.money
292/153: player.dealCards()
292/154: deck = Deck()
292/155: player.showCards()
292/156:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        
        print(vars.(self.pcards))
292/157:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        
        print(vars.__dict__(self.pcards))
292/158: player = BlackJack()
292/159: player.money
292/160: player.getBet()
292/161: player.money
292/162: player.dealCards()
292/163: deck = Deck()
292/164: player.showCards()
292/165: player.__dict__()
292/166: player.__dict__
292/167: player.dcards.__dict__
292/168: player.__dict__
292/169: player.__dict__(dcards)
292/170: player.__dict__(self.dcards)
292/171: player.__dict__()
292/172: player.__dict__
292/173: player.__dict__["dcards"]
292/174: player.__dict__["dcards"][0]
292/175: player.__dict__["dcards"][0].suit
292/176: vars(player.__dict__["dcards"][0])
292/177: player.__dict__["dcards"][0]
292/178:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
292/179: player = BlackJack()
292/180: player.money
292/181: player.getBet()
292/182: player.money
292/183: player.dealCards()
292/184: player.showCards
292/185: player.showCards()
292/186:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"]))
292/187: player.showCards()
292/188: player = BlackJack()
292/189: player.money
292/190: player.getBet()
292/191: player.money
292/192: player.dealCards()
292/193: deck = Deck()
292/194: player.showCards()
292/195:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
292/196: player = BlackJack()
292/197: player.money
292/198: player.getBet()
292/199: player.money
292/200: player.dealCards()
292/201: deck = Deck()
292/202: player.showCards()
292/203:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        return vars(player.__dict__["dcards"][0])
292/204: player = BlackJack()
292/205: player.money
292/206: player.getBet()
292/207: player.money
292/208: player.dealCards()
292/209: deck = Deck()
292/210: player.showCards()
292/211: print*()
292/212: print(player)
292/213:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        return str(vars(player.__dict__["dcards"][0]))
292/214: player = BlackJack()
292/215: player.money
292/216: player.getBet()
292/217: player.money
292/218: player.dealCards()
292/219: deck = Deck()
292/220: player.showCards()
292/221: print(player)
292/222:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [str(cards) for cards in vars(player.__dict__["dcards"])]
        return dealer_cards
292/223: player = BlackJack()
292/224: player.money
292/225: player.getBet()
292/226: player.money
292/227: player.dealCards()
292/228: deck = Deck()
292/229: player.showCards()
292/230: print(player)
292/231:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [str(vars(cards)) for cards in player.__dict__["dcards"]]
        return dealer_cards
292/232: player = BlackJack()
292/233: player.money
292/234: player.getBet()
292/235: player.money
292/236: player.dealCards()
292/237: deck = Deck()
292/238: player.showCards()
292/239: print(player)
292/240:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [str(vars(cards)) for cards in player.__dict__["dcards"]]
        return dealer_cards[0], dealer_cards[1]
292/241: player = BlackJack()
292/242: player.money
292/243: player.getBet()
292/244: player.money
292/245: player.dealCards()
292/246: deck = Deck()
292/247: player.showCards()
292/248: print(player)
292/249:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [str(vars(cards)) for cards in player.__dict__["dcards"]]
        return str(dealer_cards[0])+str(dealer_cards[1])
292/250: player = BlackJack()
292/251: player.money
292/252: player.getBet()
292/253: player.money
292/254: player.dealCards()
292/255: deck = Deck()
292/256: player.showCards()
292/257: print(player)
292/258:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [str(vars(cards)) for cards in player.__dict__["dcards"]]
        return dealer_cards[0]+dealer_cards[1]
292/259: player = BlackJack()
292/260: player.money
292/261: player.getBet()
292/262: player.money
292/263: player.dealCards()
292/264: deck = Deck()
292/265: player.showCards()
292/266: print(player)
292/267:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [str(vars(cards)) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return dealer_open_card[rank] + "of" + dealer_open_card["suit"]
292/268: player = BlackJack()
292/269: player.money
292/270: player.getBet()
292/271: player.money
292/272: player.dealCards()
292/273: deck = Deck()
292/274: player.showCards()
292/275: print(player)
292/276:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [str(vars(cards)) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return dealer_open_card["rank"] + "of" + dealer_open_card["suit"]
292/277: player = BlackJack()
292/278: player.money
292/279: player.getBet()
292/280: player.money
292/281: player.dealCards()
292/282: deck = Deck()
292/283: player.showCards()
292/284: print(player)
292/285:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [str(vars(cards)) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        print(type(dealer_open_card), dealer_open_card)
        #return dealer_open_card["rank"] + "of" + dealer_open_card["suit"]
292/286: player = BlackJack()
292/287: player.money
292/288: #player.getBet()
292/289: player.money
292/290: player.dealCards()
292/291: deck = Deck()
292/292: player.showCards()
292/293: print(player)
292/294:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        print(type(dealer_open_card), dealer_open_card)
        #return dealer_open_card["rank"] + "of" + dealer_open_card["suit"]
292/295: player = BlackJack()
292/296: player.money
292/297: #player.getBet()
292/298: player.money
292/299: player.dealCards()
292/300: deck = Deck()
292/301: player.showCards()
292/302: print(player)
292/303:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        print(type(dealer_open_card), dealer_open_card)
        return dealer_open_card["rank"] + "of" + dealer_open_card["suit"]
292/304: player = BlackJack()
292/305: player.money
292/306: #player.getBet()
292/307: player.money
292/308: player.dealCards()
292/309: deck = Deck()
292/310: player.showCards()
292/311: print(player)
292/312:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        print(type(dealer_open_card), dealer_open_card)
        return dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/313: player = BlackJack()
292/314: player.money
292/315: #player.getBet()
292/316: player.money
292/317: player.dealCards()
292/318: deck = Deck()
292/319: player.showCards()
292/320: print(player)
292/321:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "Dealers Cards:"dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/322: player = BlackJack()
292/323: player.money
292/324:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "Dealers Cards:" + dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/325: player = BlackJack()
292/326: player.money
292/327: #player.getBet()
292/328: player.money
292/329: player.dealCards()
292/330: deck = Deck()
292/331: player.showCards()
292/332: print(player)
292/333:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "Dealers Cards: " + dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/334: player = BlackJack()
292/335: player.money
292/336: #player.getBet()
292/337: player.money
292/338: player.dealCards()
292/339: deck = Deck()
292/340: player.showCards()
292/341: print(player)
292/342:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "\nDealers Cards " + dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/343: player = BlackJack()
292/344: player.money
292/345: #player.getBet()
292/346: player.money
292/347: player.dealCards()
292/348: deck = Deck()
292/349: player.showCards()
292/350: print(player)
292/351:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "Dealers Cards \n" + dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/352: player = BlackJack()
292/353: player.money
292/354: #player.getBet()
292/355: player.money
292/356: player.dealCards()
292/357: deck = Deck()
292/358: player.showCards()
292/359: print(player)
292/360:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "Dealers Cards \n-----------\n" + dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/361: player = BlackJack()
292/362: player.money
292/363: #player.getBet()
292/364: player.money
292/365: player.dealCards()
292/366: deck = Deck()
292/367: player.showCards()
292/368: print(player)
292/369:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "Dealers Cards \n--------------
    \n" + dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/370:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "Dealers Cards \n-----------\n" + dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/371: player = BlackJack()
292/372: player.money
292/373: #player.getBet()
292/374: player.money
292/375: player.dealCards()
292/376: deck = Deck()
292/377: player.showCards()
292/378: print(player)
292/379:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return "Dealers Cards \n---------------\n" + dealer_open_card["rank"] + " of " + dealer_open_card["suit"]
292/380: player = BlackJack()
292/381: player.money
292/382: #player.getBet()
292/383: player.money
292/384: player.dealCards()
292/385: deck = Deck()
292/386: player.showCards()
292/387: print(player)
292/388:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealers Cards \n---------------\n"
                "1-"+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] + "")
292/389: player = BlackJack()
292/390: player.money
292/391: #player.getBet()
292/392: player.money
292/393: player.dealCards()
292/394: deck = Deck()
292/395: player.showCards()
292/396: print(player)
292/397:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealers Cards \n---------------\n"
                "1-"+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "2-Hidden")
292/398: player = BlackJack()
292/399: player.money
292/400: #player.getBet()
292/401: player.money
292/402: player.dealCards()
292/403: deck = Deck()
292/404: player.showCards()
292/405: print(player)
292/406:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealers Cards \n---------------\n"
                "1-"+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2-Hidden")
292/407: player = BlackJack()
292/408: player.money
292/409: #player.getBet()
292/410: player.money
292/411: player.dealCards()
292/412: deck = Deck()
292/413: player.showCards()
292/414: print(player)
292/415:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealers Cards \n---------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden")
292/416: player = BlackJack()
292/417: player.money
292/418: #player.getBet()
292/419: player.money
292/420: player.dealCards()
292/421: deck = Deck()
292/422: player.showCards()
292/423: print(player)
292/424:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealers Cards \n-----------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden")
292/425: player = BlackJack()
292/426: player.money
292/427: #player.getBet()
292/428: player.money
292/429: player.dealCards()
292/430: deck = Deck()
292/431: player.showCards()
292/432: print(player)
292/433:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealers Cards \n-------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden")
292/434: player = BlackJack()
292/435: player.money
292/436: #player.getBet()
292/437: player.money
292/438: player.dealCards()
292/439: deck = Deck()
292/440: player.showCards()
292/441: print(player)
292/442: vars(player.dcards)
292/443: vars(player.dcards[0])
292/444: vars(player.dcards[1])
292/445:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealers Cards \n-------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n")
292/446: player = BlackJack()
292/447: player.money
292/448: #player.getBet()
292/449: player.money
292/450: player.dealCards()
292/451: deck = Deck()
292/452: player.showCards()
292/453: print(player)
292/454:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealer's Cards \n-------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "Player's Cards \n-------------------\n")
292/455: player = BlackJack()
292/456: player.money
292/457: #player.getBet()
292/458: player.money
292/459: player.dealCards()
292/460: deck = Deck()
292/461: player.showCards()
292/462: print(player)
292/463:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("Dealer's Cards \n----------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "Player's Cards \n----------------------\n")
292/464: player = BlackJack()
292/465: player.money
292/466: #player.getBet()
292/467: player.money
292/468: player.dealCards()
292/469: deck = Deck()
292/470: player.showCards()
292/471: print(player)
292/472:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("----------------------\nDealer's Cards \n----------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "----------------------\nPlayer's Cards \n----------------------\n")
292/473: player = BlackJack()
292/474: player.money
292/475: #player.getBet()
292/476: player.money
292/477: player.dealCards()
292/478: deck = Deck()
292/479: player.showCards()
292/480: print(player)
292/481:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("----------------------\n|Dealer's Cards|\n----------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "----------------------\n|Player's Cards|\n----------------------\n")
292/482: player = BlackJack()
292/483: player.money
292/484: #player.getBet()
292/485: player.money
292/486: player.dealCards()
292/487: deck = Deck()
292/488: player.showCards()
292/489: print(player)
292/490:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("----------------------\n| Dealer's Cards |\n----------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "----------------------\n| Player's Cards |\n----------------------\n")
292/491: player = BlackJack()
292/492: player.money
292/493: #player.getBet()
292/494: player.money
292/495: player.dealCards()
292/496: deck = Deck()
292/497: player.showCards()
292/498: print(player)
292/499:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("----------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "----------------------\n| Player's Cards |\n------------------\n")
292/500: player = BlackJack()
292/501: player.money
292/502: #player.getBet()
292/503: player.money
292/504: player.dealCards()
292/505: deck = Deck()
292/506: player.showCards()
292/507: print(player)
292/508:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n")
292/509: player = BlackJack()
292/510: player.money
292/511: #player.getBet()
292/512: player.money
292/513: player.dealCards()
292/514: deck = Deck()
292/515: player.showCards()
292/516: print(player)
292/517:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
               "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +)
292/518:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
               "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"])
292/519:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
292/520: player = BlackJack()
292/521: player.money
292/522: #player.getBet()
292/523: player.money
292/524: player.dealCards()
292/525: deck = Deck()
292/526: player.showCards()
292/527: print(player)
292/528:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        print(vars(player.__dict__["dcards"][0]))
        
        
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
292/529: player = BlackJack()
292/530: player.money
292/531: #player.getBet()
292/532: player.money
292/533: player.dealCards()
292/534: deck = Deck()
292/535: player.showCards()
292/536: print(player)
292/537:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("____________\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
292/538: player = BlackJack()
292/539: #player.getBet()
292/540: player.dealCards()
292/541:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("____________\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/542: player = BlackJack()
292/543: #player.getBet()
292/544: player.dealCards()
292/545: deck = Deck()
292/546: player.showCards()
292/547: print(player)
292/548:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("______________\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/549: player = BlackJack()
292/550: #player.getBet()
292/551: player.dealCards()
292/552: deck = Deck()
292/553: player.showCards()
292/554: print(player)
292/555:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("_________________\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/556: player = BlackJack()
292/557: #player.getBet()
292/558: player.dealCards()
292/559: deck = Deck()
292/560: player.showCards()
292/561: print(player)
292/562: vars(player.dcards[0])
292/563:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("________________\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/564: player = BlackJack()
292/565: #player.getBet()
292/566: player.dealCards()
292/567: deck = Deck()
292/568: player.showCards()
292/569: print(player)
292/570: vars(player.dcards[0])
292/571: vars(player.dcards[1])
292/572:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
292/573:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/574: player = BlackJack()
292/575: #player.getBet()
292/576: player.dealCards()
292/577: deck = Deck()
292/578: player.showCards()
292/579: print(player)
292/580: vars(player.dcards[0])
292/581: vars(player.dcards[1])
292/582: player.showCards()
292/583: print(player)
292/584: print(player)
292/585: print(player)
292/586: player.dealCards()
292/587: print(player)
292/588: player.dealCards()
292/589: print(player)
292/590: deck = Deck()
292/591: print(player)
292/592: player = BlackJack()
292/593: #player.getBet()
292/594: player.dealCards()
292/595: deck = Deck()
292/596: print(player)
292/597: player = BlackJack()
292/598: print(player)
292/599: player = BlackJack()
292/600: player.dealCards()
292/601: deck = Deck()
292/602: print(player)
292/603:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value[rank]
292/604:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
292/605:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,value))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
292/606:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/607: player = BlackJack()
292/608:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
292/609:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/610: player = BlackJack()
292/611: import numpy as np
292/612:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value[rank]
292/613:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
292/614:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
292/615:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/616: player = BlackJack()
292/617:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
292/618:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
292/619:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
292/620:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"])
    
    def round_1(self):
        pass
292/621: player = BlackJack()
292/622: #player.getBet()
292/623: player.dealCards()
292/624: deck = Deck()
292/625: print(player)
292/626: vars(player.dcards[0])
292/627: vars(player.dcards[1])
292/628:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\nValues: {}".format(player_card_1 + player_card_2[value]))
    
    def round_1(self):
        pass
292/629: player = BlackJack()
292/630: #player.getBet()
292/631: player.dealCards()
292/632: deck = Deck()
292/633: print(player)
292/634: vars(player.dcards[0])
292/635:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\nValues: {}".format(player_card_1["value"] + player_card_2["value"]))
    
    def round_1(self):
        pass
292/636: player = BlackJack()
292/637: #player.getBet()
292/638: player.dealCards()
292/639: deck = Deck()
292/640: print(player)
292/641: vars(player.dcards[0])
292/642:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\nTotal points: {}".format(player_card_1["value"] + player_card_2["value"]))
    
    def round_1(self):
        pass
292/643: player = BlackJack()
292/644: #player.getBet()
292/645: player.dealCards()
292/646: deck = Deck()
292/647: print(player)
292/648:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\n-Total points: {}".format(player_card_1["value"] + player_card_2["value"]))
    
    def round_1(self):
        pass
292/649: player = BlackJack()
292/650: #player.getBet()
292/651: player.dealCards()
292/652: deck = Deck()
292/653: print(player)
292/654:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\n--Total points: {}--".format(player_card_1["value"] + player_card_2["value"]))
    
    def round_1(self):
        pass
292/655: player = BlackJack()
292/656: #player.getBet()
292/657: player.dealCards()
292/658: deck = Deck()
292/659: print(player)
292/660: vars(player.dcards[0])
292/661:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\n<Total points: {}>".format(player_card_1["value"] + player_card_2["value"]))
    
    def round_1(self):
        pass
292/662: player = BlackJack()
292/663: #player.getBet()
292/664: player.dealCards()
292/665: deck = Deck()
292/666: print(player)
292/667: vars(player.dcards[0])
292/668:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\n<Total points: {}>".format(player_card_1["value"] + player_card_2["value"]))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check =! "y" or hit_check =! "y":
                print("\nPlease provide a valid value!\n")
            else:
                hit_control = True
292/669:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\n<Total points: {}>".format(player_card_1["value"] + player_card_2["value"]))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check =! "y") or (hit_check =! "n"):
                print("\nPlease provide a valid value!\n")
            else:
                hit_control = True
292/670: player = BlackJack()
292/671:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\n<Total points: {}>".format(player_card_1["value"] + player_card_2["value"]))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check != "y") or (hit_check != "n"):
                print("\nPlease provide a valid value!\n")
            else:
                hit_control = True
292/672: player = BlackJack()
292/673: #player.getBet()
292/674: player.dealCards()
292/675: deck = Deck()
292/676: print(player)
292/677: Player.play()
292/678: import numpy as np
292/679:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
292/680:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
292/681:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
292/682:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\n<Total points: {}>".format(player_card_1["value"] + player_card_2["value"]))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check != "y") or (hit_check != "n"):
                print("\nPlease provide a valid value!\n")
            else:
                hit_control = True
292/683: player = BlackJack()
292/684: #player.getBet()
292/685: player.dealCards()
292/686: deck = Deck()
292/687: print(player)
292/688: Player.play()
292/689: vars(player.dcards[0])
292/690: player.play()
293/1: import numpy as np
293/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
293/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
293/4:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
293/5:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def __str__(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        player_cards = [vars(cards) for cards in player.__dict__["pcards"]]
        player_card_1, player_card_2 = player_cards[0], player_cards[1]
        return ("------------------\n| Dealer's Cards |\n------------------\n"
                "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                "\n2- Hidden\n\n" +
                "------------------\n| Player's Cards |\n------------------\n"+
                "1- "+ player_card_1["rank"] + " of " + player_card_1["suit"] + 
                "\n2- "+ player_card_2["rank"] + " of " + player_card_2["suit"] +
                "\n<Total points: {}>".format(player_card_1["value"] + player_card_2["value"]))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/6: player = BlackJack()
293/7: #player.getBet()
293/8: player.dealCards()
293/9: deck = Deck()
293/10: print(player)
293/11: player.play()
293/12: player.__dict__["pcards"]
293/13: player.__dict__["pcards"][0]
293/14: vars(player.__dict__["pcards"][0])
293/15: vars(elements) for elements in player.__dict__["pcards"]
293/16:
for elements in player.__dict__["pcards"]:
    vars(elements)
293/17:
for elements in player.__dict__["pcards"]:
    print(vars(elements))
293/18:
for element in player.__dict__["pcards"]:
    vars(element)[""]
293/19:
for element in player.__dict__["pcards"]:
    vars(element)["rank"]
293/20:
for element in player.__dict__["pcards"]:
    print(vars(element)
293/21:
for element in player.__dict__["pcards"]:
    print(vars(element))
293/22:
for element in player.__dict__["pcards"]:
    vars(element)["rank"] + " of " + vars(element)["suit"]
293/23:
for element in player.__dict__["pcards"]:
    print(vars(element)["rank"] + " of " + vars(element)["suit"])
293/24:
for no, element in enumerate(player.__dict__["pcards"]):
    print(no + "- " + vars(element)["rank"] + " of " + vars(element)["suit"])
293/25:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"])
293/26:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"])
293/27:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"])
293/28:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] +
         "\n<Total points: {}>".format(player_card_1["value"] + player_card_2["value"])
293/29:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] +
         "\n<Total points: {}>".format(player_card_1["value"] + player_card_2["value"]))
293/30:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] +
         "\n<Total points: {}>".format(element["value"].smu()))
293/31:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] +
         "\n<Total points: {}>".format(element["value"].sum()))
293/32:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] +
         "\n<Total points: {}>".format(element["value"]))
293/33:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] +
         "\n<Total points: {}>".format(vars(element["value"])))
293/34:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] +
         "\n<Total points: {}>".format(vars(element)["value"]))
293/35:
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] +

print("\n<Total points: {}>".format(vars(element)["value"])))
293/36: player.__dict__["pcards"]
293/37: player.__dict__["pcards"][0]
293/38: vars(player.__dict__["pcards"][0])
293/39: vars(player.__dict__["pcards"][0])["value"]
293/40: int(vars(player.__dict__["pcards"][0])["value"])
293/41:
total_rank = []
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"])
    total_rank.append(vars(element)["value"])
293/42: total_rank
293/43:
total_rank = []
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"])
    total_rank.append(vars(element)["value"])

print("\n<Total points: {}>".format(total_rank.sum))
293/44:
total_rank = []
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"])
    total_rank.append(vars(element)["value"])

print("\n<Total points: {}>".format(total_rank.sum()))
293/45: total_rank
293/46:
total_rank = []
for no, element in enumerate(player.__dict__["pcards"]):
    print(str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"])
    total_rank.append(vars(element)["value"])

print("\n<Total points: {}>".format(sum(total_rank)))
293/47:
total_rank = []

test = [str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] total_rank.append(vars(element)["value"] for no, element in enumerate(player.__dict__["pcards"]]
293/48:
total_rank = []

test = [str(no+1) + "- " + vars(element)["rank"] + " of " + vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"]]
293/49:
total_rank = []

test = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
293/50: test
293/51:
test = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
293/52: card for card in test
293/53:
for card in test:
    print(card)
293/54: test
293/55: len(test)
293/56: len(test) is 2
293/57:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------\n")
        
        print(dealer_expression)
        for card in cards:
            print(card)
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/58: player = BlackJack()
293/59: #player.getBet()
293/60: player.dealCards()
293/61: deck = Deck()
293/62: print(player)
293/63: player.showCards()
293/64:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/65: player = BlackJack()
293/66: #player.getBet()
293/67: player.dealCards()
293/68: deck = Deck()
293/69: print(player)
293/70: player.showCards()
293/71:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print(sum(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/72: player = BlackJack()
293/73: #player.getBet()
293/74: player.dealCards()
293/75: deck = Deck()
293/76: print(player)
293/77: player.showCards()
293/78:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("\n<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/79: player = BlackJack()
293/80: #player.getBet()
293/81: player.dealCards()
293/82: deck = Deck()
293/83: print(player)
293/84: player.showCards()
293/85:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/86: player = BlackJack()
293/87: #player.getBet()
293/88: player.dealCards()
293/89: deck = Deck()
293/90: print(player)
293/91: player.showCards()
293/92:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/93: player = BlackJack()
293/94: #player.getBet()
293/95: player.dealCards()
293/96: deck = Deck()
293/97: print(player)
293/98: player.showCards()
293/99: player.play()
293/100: player.showCards()
293/101: player.__dict__["pcards"]
293/102: test = [vars(element["value"]) player.__dict__["pcards"]]
293/103: test = [vars(element["value"]) for element in player.__dict__["pcards"]]
293/104: test = [vars(element|) for element in player.__dict__["pcards"]]
293/105: test = [vars(element) for element in player.__dict__["pcards"]]
293/106: test
293/107:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        global total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/108:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
                   
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        global total_value
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/109: player = BlackJack()
293/110:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    total_value = []
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
293/111:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    total_value = []
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
293/112: player = BlackJack()
293/113: #player.getBet()
293/114: player.dealCards()
293/115: deck = Deck()
293/116: print(player)
293/117: player.showCards()
293/118:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    total_value = []
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
293/119:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        total_value = []

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
293/120: player = BlackJack()
293/121: #player.getBet()
293/122: player.dealCards()
293/123: deck = Deck()
293/124: print(player)
293/125: player.showCards()
293/126: player = BlackJack()
293/127: import numpy as np
293/128:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
293/129:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
293/130:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
293/131:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        total_value = []

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
293/132: player = BlackJack()
293/133: #player.getBet()
293/134: player.dealCards()
293/135: deck = Deck()
293/136: import numpy as np
293/137:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
293/138:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
293/139:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
293/140:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        total_value = []

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
293/141: player = BlackJack()
293/142: #player.getBet()
293/143: player.dealCards()
293/144: deck = Deck()
293/145: print(player)
293/146: player.showCards()
293/147:
class BlackJack(Player, Deck):
    total_value = []

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
293/148: player = BlackJack()
293/149: #player.getBet()
293/150: player.dealCards()
293/151: deck = Deck()
293/152: print(player)
293/153: player.showCards()
293/154: player.play()
293/155:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
        self.total_value = sum(total_value)
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
293/156: player = BlackJack()
293/157: #player.getBet()
293/158: player.dealCards()
293/159: deck = Deck()
293/160: print(player)
293/161: player.showCards()
293/162: player.play()
293/163:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def getBet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def dealCards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def showCards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
        self.total_value = sum(total_value)
            
        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/164: player = BlackJack()
293/165: #player.getBet()
293/166: player.dealCards()
293/167: deck = Deck()
293/168: print(player)
293/169: player.showCards()
293/170: player.play()
293/171: player.showCards()
293/172:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]


        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/173: player = BlackJack()
293/174: #player.getBet()
293/175: player.deal_cards()
293/176: deck = Deck()
293/177: print(player)
293/178: player.show_ cards()
293/179: player.show_cards()
293/180:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(sum(total_value)))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/181:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/182: player = BlackJack()
293/183: #player.getBet()
293/184: player.deal_cards()
293/185: deck = Deck()
293/186: print(player)
293/187: player.show_cards()
293/188:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
293/189: import numpy as np
293/190:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
293/191:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        self.total_value = None
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
293/192:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
293/193:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/194: player = BlackJack()
293/195: #player.getBet()
293/196: player.deal_cards()
293/197: deck = Deck()
293/198:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/199: player = BlackJack()
293/200: #player.getBet()
293/201: player.deal_cards()
293/202: deck = Deck()
293/203: print(player)
293/204: player.show_cards()
293/205:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = []
        for no, element in enumerate(player.__dict__["pcards"]):
            total_value.append(vars(element)["value"])
            
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/206: player = BlackJack()
293/207: #player.getBet()
293/208: player.deal_cards()
293/209: deck = Deck()
293/210: print(player)
293/211: player.show_cards()
293/212:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/213:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
293/214: import numpy as np
293/215:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
293/216:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
293/217:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
293/218:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return total_value
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
293/219: player = BlackJack()
293/220: #player.getBet()
293/221: player.deal_cards()
293/222: deck = Deck()
293/223: print(player)
293/224: player.show_cards()
294/1: import numpy as np
294/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
294/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
294/4:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
294/5:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return total_value
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
294/6: player_ = BlackJack()
294/7: #player.getBet()
294/8: player.deal_cards()
294/9: player_.deal_cards()
294/10: player_.show_cards()
294/11:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in Player.__dict__["pcards"]]
        return total_value
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
294/12: player_ = BlackJack()
294/13: #player.getBet()
294/14: player_.deal_cards()
294/15: player_.show_cards()
294/16:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in Player.__dict__["pcards"]]
        return total_value
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in Player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(Player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
294/17: player_ = BlackJack()
294/18: #player.getBet()
294/19: player_.deal_cards()
294/20: player_.show_cards()
294/21: player_.play()
295/1: import numpy as np
295/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
295/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
295/4:
class Deck(Cards):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
295/5:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return total_value
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/6: player = BlackJack()
295/7: #player.getBet()
295/8: player.deal_cards()
295/9: player.show_cards()
295/10:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return total_value
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value(self)
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/11: player = BlackJack()
295/12: #player.getBet()
295/13: player.deal_cards()
295/14: player.show_cards()
295/15: total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
295/16: total_value
295/17:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value(self)
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/18: player = BlackJack()
295/19: #player.getBet()
295/20: player.deal_cards()
295/21: player.show_cards()
295/22:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(cls):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = get_total_value(self)
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/23: player = BlackJack()
295/24: #player.getBet()
295/25: player.deal_cards()
295/26: player.show_cards()
295/27: player_.play()
295/28:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(cls):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        get_total_value(self)
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/29: player = BlackJack()
295/30: #player.getBet()
295/31: player.deal_cards()
295/32: player.show_cards()
295/33: player.get_total_value()
295/34:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(cls):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        self.get_total_value(self)
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/35: player = BlackJack()
295/36: #player.getBet()
295/37: player.deal_cards()
295/38: player.show_cards()
295/39:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value():
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        self.get_total_value(self)
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/40: player = BlackJack()
295/41: #player.getBet()
295/42: player.deal_cards()
295/43: player.show_cards()
295/44:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value():
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/45: player = BlackJack()
295/46: #player.getBet()
295/47: player.deal_cards()
295/48: player.show_cards()
295/49:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/50: player = BlackJack()
295/51: #player.getBet()
295/52: player.deal_cards()
295/53: player.show_cards()
295/54: player.get_total_value()
295/55:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in player.__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(self.total_value)
295/56: player = BlackJack()
295/57: #player.getBet()
295/58: player.deal_cards()
295/59: player.show_cards()
295/60: player.get_total_value()
295/61: player.play()
295/62: dir(player)
295/63:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in super(BlackJack, self).__dict__["pcards"]]
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(total_value)
295/64: player = BlackJack()
295/65: #player.getBet()
295/66: player.deal_cards()
295/67: player.show_cards()
295/68: player.play()
295/69:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in super(BlackJack, self).__dict__["pcards"]]
        print(type(total_value), total_value)
        return sum(total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in player.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(player.__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(total_value)
295/70: player = BlackJack()
295/71: #player.getBet()
295/72: player.deal_cards()
295/73: player.show_cards()
295/74: player.play()
295/75:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in super(BlackJack, self).__dict__["pcards"]]
        print(type(total_value), total_value)
            
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in super(BlackJack, self).__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(super(BlackJack, self).__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(total_value)
295/76: player = BlackJack()
295/77: #player.getBet()
295/78: player.deal_cards()
295/79: player.show_cards()
295/80:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in super(BlackJack, self).__dict__["pcards"]]
        return sum(total_value)
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in super(BlackJack, self).__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(super(BlackJack, self).__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(total_value)
295/81: player = BlackJack()
295/82: #player.getBet()
295/83: player.deal_cards()
295/84: player.show_cards()
295/85: player.play()
295/86:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in super(BlackJack, self).__dict__["pcards"]]
        return sum(total_value)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in super(BlackJack, self).__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(super(BlackJack, self).__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
295/87: player = BlackJack()
295/88: #player.getBet()
295/89: player.deal_cards()
295/90: player.show_cards()
295/91: player.play()
295/92:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in super(BlackJack, self).__dict__["pcards"]]
        return sum(total_value)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in super(BlackJack, self).__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(super(BlackJack, self).__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
295/93: player_ = BlackJack()
295/94: #player.getBet()
295/95: player_.deal_cards()
295/96: player_.show_cards()
295/97: player_.play()
295/98:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = super(BlackJack, self).update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in super(BlackJack, self).__dict__["pcards"]]
        print(self.__dict__["pcards"])
        return sum(total_value)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in super(BlackJack, self).__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(super(BlackJack, self).__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
295/99: player = BlackJack()
295/100: #player.getBet()
295/101: player.deal_cards()
295/102: player.show_cards()
295/103:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in self.__dict__["pcards"]]
        return sum(total_value)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def play(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if (hit_check == "y") or (hit_check == "n"):
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
295/104: player = BlackJack()
295/105: #player.getBet()
295/106: player.deal_cards()
295/107: player.show_cards()
295/108: player_.play()
295/109:
class BlackJack(Player, Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
                
    def deal_cards(self):
        super(BlackJack, self).shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in self.__dict__["pcards"]]
        return sum(total_value)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def hit(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
295/110: player = BlackJack()
295/111: #player.getBet()
295/112: player.deal_cards()
295/113: player.show_cards()
295/114: player_.play()
295/115: player.show_cards()
295/116: import numpy as np
295/117:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
295/118:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
295/119:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
295/120:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in self.__dict__["pcards"]]
        return sum(total_value)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def hit(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
295/121: player = BlackJack()
295/122: #player.getBet()
295/123: player.deal_cards()
295/124: player.show_cards()
295/125: player_.play()
295/126: player.show_cards()
295/127: import numpy as np
295/128:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
295/129:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
295/130:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
295/131:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in self.__dict__["pcards"]]
        return sum(total_value)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def hit(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
295/132: player = BlackJack()
295/133: #player.getBet()
295/134: player.deal_cards()
295/135: player.show_cards()
295/136: player.play()
295/137: player.hit()
295/138: player.hit()
295/139: player.hit()
295/140: player.show_cards()
295/141: import numpy as np
295/142:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
295/143:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
295/144:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
295/145:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value = [vars(element)["value"] for element in self.__dict__["pcards"]]
        return sum(total_value)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value))
    
    def hit(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        print(sum(total_value))
295/146: player = BlackJack()
295/147: #player.getBet()
295/148: player.deal_cards()
295/149: player.show_cards()
295/150: player.hit()
295/151: player.show_cards()
295/152: test = [6,3]
295/153: test.any() >2
295/154: any(test) >2
295/155: any(test) > 4
295/156: any(test) > 5
295/157: any(test) > 7
295/158: any(elements) for elements in test > 7
295/159: any(test) > 7
295/160: test > 7
295/161:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
295/162: import numpy as np
295/163:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
295/164:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
295/165:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
295/166:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
295/167: player = BlackJack()
295/168: #player.getBet()
295/169: player.deal_cards()
295/170: player.show_cards()
295/171: player.hit_or_stand()
295/172: player.check_total_points
295/173: player.check_total_points()
295/174:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
295/175: player = BlackJack()
295/176: #player.getBet()
295/177: player.deal_cards()
295/178: player.show_cards()
295/179: player.hit_or_stand()
295/180: player.check_total_points()
295/181:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
295/182: player = BlackJack()
295/183: #player.getBet()
295/184: player.deal_cards()
295/185: player.show_cards()
295/186: player = BlackJack()
295/187: #player.getBet()
295/188: player.deal_cards()
295/189: player.show_cards()
295/190: player.hit_or_stand()
295/191: import numpy as np
295/192:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
295/193:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
295/194:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
295/195:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
295/196: player = BlackJack()
295/197: #player.getBet()
295/198: player.deal_cards()
295/199: import numpy as np
295/200:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
295/201:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
295/202:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
296/1: import numpy as np
296/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
296/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
296/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
296/5:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
296/6: player = BlackJack()
296/7: #player.getBet()
296/8: player.deal_cards()
296/9: player.show_cards()
296/10:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
296/11: player = BlackJack()
296/12: #player.getBet()
296/13: player.deal_cards()
296/14: player.show_cards()
296/15: player.hit_or_stand()
296/16: player.check_total_points()
296/17: import numpy as np
296/18:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
296/19:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
296/20:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
296/21:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
296/22: player = BlackJack()
296/23: #player.getBet()
296/24: player.deal_cards()
296/25: player.show_cards()
296/26: player.hit_or_stand()
296/27: player.check_total_points()
296/28: player.__dict__["pcards"]
296/29: vars(player.__dict__["pcards"])
296/30:
test = [vars(elements) for elements in player.__dict__["pcards"]]
test
296/31:
test = [vars(elements) for elements in player.__dict__["pcards"]]
test
296/32:
test = [vars(elements) for elements in player.__dict__["pcards"]]
test_alt = [card.values() for card in test]
test_alt
296/33: if "Jack" in test_alt
296/34: "Jack" in test_alt
296/35:
test = [vars(elements) for elements in player.__dict__["pcards"]]
test_alt = card.values() for card in test
test_alt
296/36:
test = [vars(elements) for elements in player.__dict__["pcards"]]
test_alt = [card.values() for card in test]
test_alt
296/37:
test_1 = ["Jack" dict_values for dict_values in test_alt]
test_1
296/38:
test_1 = ["Jack" in dict_values for dict_values in test_alt]
test_1
296/39:
test = [vars(elements) for elements in player.__dict__["pcards"]]
test
296/40:
cards = [vars(elements) for elements in player.__dict__["pcards"]]
cards
296/41:
test_alt = [card.values() for card in test]
test_alt
296/42:
card_values = [card.values() for card in test]
card_values
296/43:
card_values = ["Jack" in dict_values for dict_values in test_alt]
card_values
296/44:
cards = [vars(elements) for elements in player.__dict__["pcards"]]
cards
296/45:
card_values = [card.values() for card in cards]
card_values
296/46:
ace_mask = ["Jack" in dict_values for dict_values in card_values]
ace_mask
296/47: any(ace_mask)
296/48:
if any(ace_mask):
    ace_value = input("Would you like your Ace to be count 1 or 11? - ")
296/49: player.pcards
296/50: vars(player.pcards[0])
296/51: vars(player.pcards[0]['rank'])
296/52: vars(player.pcards[0])['rank']
296/53: test = vars(player.pcards[0])['rank']
296/54: vars(player.pcards[0])['rank']
296/55: vars(player.pcards.rank
296/56: player.pcards.rank
296/57: player.pcards[0].rank
296/58: ace_mask[True]
296/59: ace_mask.index(True)
296/60: card_no_ace = ace_mask.index(True)
296/61: player.pcards[card_no_ace].rank
296/62: player.pcards[card_no_ace].rank = "Ace-1"
296/63: player.pcards[card_no_ace].rank
296/64: player.pcards[card_no_ace].value
296/65:
cards = [vars(elements) for elements in player.__dict__["pcards"]]
cards
296/66:
card_values = [card.values() for card in cards]
card_values
296/67:
ace_mask = ["Jack" in dict_values for dict_values in card_values]
ace_mask
296/68: import numpy as np
296/69:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
296/70:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
296/71:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace','Ace-1']
        values = {'Ace-1':1,'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
296/72:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        cards = [vars(elements) for elements in player.__dict__["pcards"]]
        card_values = [card.values() for card in cards]
        ace_mask = ["Jack" in dict_values for dict_values in card_values]
296/73: player = BlackJack()
296/74: #player.getBet()
296/75: player.deal_cards()
296/76: player.show_cards()
296/77: player.hit_or_stand()
296/78: player.hit_or_stand()
296/79: player.check_total_points()
296/80: player.show_cards()
297/1: import numpy as np
297/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
297/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
297/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace','Ace-1']
        values = {'Ace-1':1,'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
297/5:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        cards = [vars(elements) for elements in player.__dict__["pcards"]]
        card_values = [card.values() for card in cards]
        ace_mask = ["Jack" in dict_values for dict_values in card_values]
297/6: player = BlackJack()
297/7: #player.getBet()
297/8: player.deal_cards()
297/9: player.show_cards()
297/10: player = BlackJack()
297/11: #player.getBet()
297/12: player.deal_cards()
297/13: player.show_cards()
297/14: player = BlackJack()
297/15: #player.getBet()
297/16: player.deal_cards()
297/17: player.show_cards()
297/18: player = BlackJack()
297/19: #player.getBet()
297/20: player.deal_cards()
297/21: player.show_cards()
297/22: player.deal_cards()
297/23: player.show_cards()
297/24: player.deal_cards()
297/25: player.show_cards()
297/26: player.deal_cards()
297/27: player.show_cards()
297/28: import numpy as np
297/29:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
297/30:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
297/31:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace','Ace-1']
        values = {'Ace-1':1,'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
297/32:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        cards = [vars(elements) for elements in player.__dict__["pcards"]]
        card_values = [card.values() for card in cards]
        ace_mask = ["Jack" in dict_values for dict_values in card_values]
297/33: player = BlackJack()
297/34: #player.getBet()
297/35: player.deal_cards()
297/36: player.show_cards()
297/37: player = BlackJack()
297/38: #player.getBet()
297/39: player.deal_cards()
297/40: player.show_cards()
297/41: player = BlackJack()
297/42: #player.getBet()
297/43: player.deal_cards()
297/44: player.show_cards()
297/45: player = BlackJack()
297/46: #player.getBet()
297/47: player.deal_cards()
297/48: player.show_cards()
297/49: player = BlackJack()
297/50: #player.getBet()
297/51: player.deal_cards()
297/52: player.show_cards()
297/53:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
297/54:
cards = [vars(elements) for elements in player.__dict__["pcards"]]
cards
297/55:
card_values = [card.values() for card in cards]
card_values
297/56: import numpy as np
297/57:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
297/58:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
297/59:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
297/60:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        cards = [vars(elements) for elements in player.__dict__["pcards"]]
        card_values = [card.values() for card in cards]
        ace_mask = ["Jack" in dict_values for dict_values in card_values]
297/61: player = BlackJack()
297/62: #player.getBet()
297/63: player.deal_cards()
297/64: player.show_cards()
297/65: player = BlackJack()
297/66: #player.getBet()
297/67: player.deal_cards()
297/68: player.show_cards()
297/69: player = BlackJack()
297/70: #player.getBet()
297/71: player.deal_cards()
297/72: player.show_cards()
297/73: player = BlackJack()
297/74: #player.getBet()
297/75: player.deal_cards()
297/76: player.show_cards()
297/77: player = BlackJack()
297/78: #player.getBet()
297/79: player.deal_cards()
297/80: player.show_cards()
297/81:
cards = [vars(elements) for elements in player.__dict__["pcards"]]
cards
297/82:
card_values = [card.values() for card in cards]
card_values
297/83:
ace_mask = ["Ace" in dict_values for dict_values in card_values]
ace_mask
297/84:
ace_control = False

while ace_control is False:
    if any(ace_mask):
        ace_value = input("Would you like your Ace to be count 1 or 11? - ")
        card_no_ace = ace_mask.index(True)
        try:
            ace_value = int(ace_value)
            if ace_value == 1:
                player.pcards[card_no_ace].rank = "Ace-1"
                player.pcards[card_no_ace].value = 1
                ace_control = True
            elif ace_value == 11:
                ace_control = True
            else:
                print("\nPlease provide either 1 or 11!\n")
        except ValueError:
            print("\nPlease provide a valid value!\n")
297/85: card_no_ace = ace_mask.index(True)
297/86:
card_no_ace= ace_mask.index(True)
card_no_ace
297/87: player.pcards[card_no_ace].value
297/88: player.pcards[card_no_ace].rank
297/89:
cards = [vars(elements) for elements in player.__dict__["pcards"]]
cards
297/90:
card_values = [card.values() for card in cards]
card_values
297/91:
ace_mask = ["Ace" in dict_values for dict_values in card_values]
ace_mask
297/92: player = BlackJack()
297/93: #player.getBet()
297/94: player.deal_cards()
297/95: player.show_cards()
297/96: player = BlackJack()
297/97: #player.getBet()
297/98: player.deal_cards()
297/99: player.show_cards()
297/100: player = BlackJack()
297/101: #player.getBet()
297/102: player.deal_cards()
297/103: player.show_cards()
297/104: player = BlackJack()
297/105: #player.getBet()
297/106: player.deal_cards()
297/107: player.show_cards()
297/108: player = BlackJack()
297/109: #player.getBet()
297/110: player.deal_cards()
297/111: player.show_cards()
297/112: player = BlackJack()
297/113: #player.getBet()
297/114: player.deal_cards()
297/115: player.show_cards()
297/116: player = BlackJack()
297/117: #player.getBet()
297/118: player.deal_cards()
297/119: player.show_cards()
297/120: player = BlackJack()
297/121: #player.getBet()
297/122: player.deal_cards()
297/123: player.show_cards()
297/124: player = BlackJack()
297/125: #player.getBet()
297/126: player.deal_cards()
297/127: player.show_cards()
297/128: player = BlackJack()
297/129: #player.getBet()
297/130: player.deal_cards()
297/131: player.show_cards()
297/132: player = BlackJack()
297/133: #player.getBet()
297/134: player.deal_cards()
297/135: player.show_cards()
297/136: player = BlackJack()
297/137: #player.getBet()
297/138: player.deal_cards()
297/139: player.show_cards()
297/140: player = BlackJack()
297/141: #player.getBet()
297/142: player.deal_cards()
297/143: player.show_cards()
297/144: player = BlackJack()
297/145: #player.getBet()
297/146: player.deal_cards()
297/147: player.show_cards()
297/148: player = BlackJack()
297/149: #player.getBet()
297/150: player.deal_cards()
297/151: player.show_cards()
297/152: player = BlackJack()
297/153: #player.getBet()
297/154: player.deal_cards()
297/155: player.show_cards()
297/156: player = BlackJack()
297/157: #player.getBet()
297/158: player.deal_cards()
297/159: player.show_cards()
297/160: player = BlackJack()
297/161: #player.getBet()
297/162: player.deal_cards()
297/163: player.show_cards()
297/164: player = BlackJack()
297/165: #player.getBet()
297/166: player.deal_cards()
297/167: player.show_cards()
297/168: player = BlackJack()
297/169: #player.getBet()
297/170: player.deal_cards()
297/171: player.show_cards()
297/172: player = BlackJack()
297/173: #player.getBet()
297/174: player.deal_cards()
297/175: player.show_cards()
297/176: player = BlackJack()
297/177: #player.getBet()
297/178: player.deal_cards()
297/179: player.show_cards()
297/180: player = BlackJack()
297/181: #player.getBet()
297/182: player.deal_cards()
297/183: player.show_cards()
297/184: player = BlackJack()
297/185: #player.getBet()
297/186: player.deal_cards()
297/187: player.show_cards()
297/188: player = BlackJack()
297/189: #player.getBet()
297/190: player.deal_cards()
297/191: player.show_cards()
297/192: player = BlackJack()
297/193: #player.getBet()
297/194: player.deal_cards()
297/195: player.show_cards()
297/196: player = BlackJack()
297/197: #player.getBet()
297/198: player.deal_cards()
297/199: player.show_cards()
297/200: player = BlackJack()
297/201: #player.getBet()
297/202: player.deal_cards()
297/203: player.show_cards()
297/204:
cards = [vars(elements) for elements in player.__dict__["pcards"]]
cards
297/205:
card_values = [card.values() for card in cards]
card_values
297/206:
ace_mask = ["Ace" in dict_values for dict_values in card_values]
ace_mask
297/207:
ace_control = False

while ace_control is False:
    if any(ace_mask):
        ace_value = input("Would you like your Ace to be count 1 or 11? - ")
        card_no_ace = ace_mask.index(True)
        try:
            ace_value = int(ace_value)
            if ace_value == 1:
                player.pcards[card_no_ace].value = 1
                ace_control = True
            elif ace_value == 11:
                ace_control = True
            else:
                print("\nPlease provide either 1 or 11!\n")
        except ValueError:
            print("\nPlease provide a valid value!\n")
297/208:
ace_control = False

while ace_control is False:
    if any(ace_mask):
        ace_value = input("Would you like your Ace to be count 1 or 11? - ")
        card_no_ace = ace_mask.index(True)
        try:
            ace_value = int(ace_value)
            if ace_value == 1:
                player.pcards[card_no_ace].value = 1
                ace_control = True
            elif ace_value == 11:
                ace_control = True
            else:
                print("\nPlease provide either 1 or 11!\n")
        except ValueError:
            print("\nPlease provide a valid value!\n")
297/209:
card_no_ace= ace_mask.index(True)
card_no_ace
297/210: player.pcards[card_no_ace].rank
297/211: player.pcards[card_no_ace].value
297/212: player.show_cards()
298/1: import numpy as np
298/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
298/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
298/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
298/5:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("How much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("Do you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("Would you like your Ace to be count 1 or 11? - ")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/6: player = BlackJack()
298/7: #player.getBet()
298/8: player.deal_cards()
298/9: player.show_cards()
298/10: player.hit_or_stand()
298/11: player.check_total_points()
298/12: player.show_cards()
298/13:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    
    player.show_cards()
    player.hit_or_stand()
    player.check_total_points()
298/14: start_game
298/15: start_game()
298/16: import numpy as np
298/17:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
298/18:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
298/19:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
298/20:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        dealer_cards = [vars(cards) for cards in self.__dict__["dcards"]]
        dealer_open_card = dealer_cards[0]

        cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        dealer_expression = ("------------------\n| Dealer's Cards |\n------------------\n"
                             "1- "+ dealer_open_card["rank"] + " of " + dealer_open_card["suit"] +
                             "\n2- Hidden\n\n" +
                           "------------------\n| Player's Cards |\n------------------")
        
        print(dealer_expression)
        for card in cards:
            print(card)
            if cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
    
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/21: player = BlackJack()
298/22: #player.getBet()
298/23: player.deal_cards()
298/24: player.show_cards()
298/25: player.hit_or_stand()
298/26: player.hit_or_stand()
298/27: player.check_total_points()
298/28: player.show_cards()
298/29:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    
    player.show_cards()
    player.hit_or_stand()
    player.check_total_points()
298/30: start_game()
298/31: start_game()
298/32:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------\n")
        for card in dealer_cards:
            if card = dealer_cards[0]:
                print(card)
            else:
                print("\n2- Hidden\n\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/33:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------\n")
        for card in dealer_cards:
            if card == dealer_cards[0]:
                print(card)
            else:
                print("\n2- Hidden\n\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/34: player = BlackJack()
298/35: #player.getBet()
298/36: player.deal_cards()
298/37: player.show_cards()
298/38:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for card in dealer_cards:
            if card == dealer_cards[0]:
                print(card)
            else:
                print("\n2- Hidden\n\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/39: player = BlackJack()
298/40: #player.getBet()
298/41: player.deal_cards()
298/42: player.show_cards()
298/43:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for card in dealer_cards:
            if card == dealer_cards[0]:
                print(card)
            else:
                print("2- Hidden\n\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/44: player = BlackJack()
298/45: #player.getBet()
298/46: player.deal_cards()
298/47: player.show_cards()
298/48:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for card in dealer_cards:
            if card == dealer_cards[0]:
                print(card)
            else:
                print("2- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/49: player = BlackJack()
298/50: #player.getBet()
298/51: player.deal_cards()
298/52: player.show_cards()
298/53: player.hit_or_stand()
298/54: player.check_total_points()
298/55: player.show_cards()
298/56:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/57: player = BlackJack()
298/58: #player.getBet()
298/59: player.deal_cards()
298/60: player.show_cards()
298/61: player.hit_or_stand()
298/62: player.check_total_points()
298/63: player.show_cards()
298/64: player.check_total_points()
298/65:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/66: player = BlackJack()
298/67: #player.getBet()
298/68: player.deal_cards()
298/69: player.show_cards()
298/70: player.hit_or_stand()
298/71: player.check_total_points()
298/72:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    
    player.show_cards()
    player.hit_or_stand()
    player.check_total_points()
298/73: start_game()
298/74:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/75: player = BlackJack()
298/76: #player.getBet()
298/77: player.deal_cards()
298/78: player.show_cards()
298/79: player.hit_or_stand()
298/80: player.check_total_points()
298/81: player.show_cards()
298/82:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    
    player.show_cards()
    player.hit_or_stand()
    player.check_total_points()
298/83: start_game()
298/84: start_game()
298/85: start_game()
298/86: start_game()
298/87:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_cards(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
298/88: player = BlackJack()
298/89: #player.getBet()
298/90: player.deal_cards()
298/91: player.show_cards()
298/92: player.hit_or_stand()
298/93: player.check_total_points()
298/94: player.show_cards()
298/95:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    
    player.show_cards()
    player.hit_or_stand()
    player.check_total_points()
298/96: player = BlackJack()
298/97: #player.getBet()
298/98: player.deal_cards()
298/99: player.show_partial()
298/100: player.hit_or_stand()
299/1: import numpy as np
299/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
299/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
299/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
299/5:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
299/6: player = BlackJack()
299/7: #player.getBet()
299/8: player.deal_cards()
299/9: player.show_partial()
299/10: player.hit_or_stand()
299/11: player.check_total_points()
299/12: import numpy as np
299/13:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
299/14:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
299/15:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
299/16:
class BlackJack(Deck):

    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
299/17: player = BlackJack()
299/18: #player.getBet()
299/19: player.deal_cards()
299/20: player.show_partial()
299/21: player.hit_or_stand()
299/22: player.check_total_points()
299/23: player.show_partial()
299/24:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    
    player.show_partial()
    player.hit_or_stand()
    player.check_total_points()
299/25: start_game()
299/26: start_game()
299/27: start_game()
299/28:
class BlackJack(Deck):

    def __init__(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
299/29: player = BlackJack()
299/30: #player.getBet()
299/31:
class BlackJack(Deck):

    def __init__(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
299/32: player = BlackJack()
299/33: #player.getBet()
299/34: player.deal_cards()
299/35: import numpy as np
299/36:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
299/37:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
299/38:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
299/39:
class BlackJack(Deck):

    def __init__(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
299/40: player = BlackJack()
299/41:
class BlackJack(Deck):

    def __init__(self):
        
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
299/42: player = BlackJack()
299/43:
class BlackJack(Deck):
    
    dealer_cards, player_cards = self.dealer_and_player_card()

    def __init__(self):
        
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
299/44:
class BlackJack(Deck):
    
    def __init__(self):
        
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
    
    dealer_cards, player_cards = self.dealer_and_player_card()

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
299/45:
class BlackJack(Deck):
    
    def __init__(self):
        
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
    
    dealer_cards, player_cards = self.get_dealer_and_player_card()

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
300/1: import numpy as np
300/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
300/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
300/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
300/5:
class BlackJack(Deck):
    
    def __init__(self):
        
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
    
    dealer_cards, player_cards = self.get_dealer_and_player_card()

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
300/6:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
    
    dealer_cards, player_cards = get_dealer_and_player_card()

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
300/7:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
    
    dealer_cards, player_cards = self.get_dealer_and_player_card()

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
300/8: player = BlackJack()
300/9:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
    
    dealer_cards, player_cards = get_dealer_and_player_card(self)

    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
300/10:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
300/11: player = BlackJack()
300/12: #player.getBet()
300/13: player.deal_cards()
300/14: player.show_partial()
300/15:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
            
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        pass
    
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
300/16: player = BlackJack()
300/17: #player.getBet()
300/18: player.deal_cards()
300/19: player.show_partial()
300/20:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.check_if_ace_in_hand()
    
    player.show_partial()
    player.hit_or_stand()
    player.check_if_ace_in_hand()
    player.check_total_points()
300/21: start_game()
301/1:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
301/2:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
301/3: import numpy as np
301/4:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
301/5:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
301/6:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
301/7:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
    self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
301/8: player = BlackJack()
301/9:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
301/10: player = BlackJack()
301/11: #player.getBet()
301/12: player.deal_cards()
301/13: player.show_partial()
301/14: player.hit_or_stand()
301/15: player.check_total_points()
301/16:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
301/17: player = BlackJack()
301/18: #player.getBet()
301/19: player.deal_cards()
301/20: player.show_partial()
301/21: player.hit_or_stand()
301/22: player.check_total_points()
301/23:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
301/24: player = BlackJack()
301/25: #player.getBet()
301/26: player.deal_cards()
301/27: player.show_partial()
301/28: player.hit_or_stand()
301/29: player.check_total_points()
301/30:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
301/31: player = BlackJack()
301/32: #player.getBet()
301/33: player.deal_cards()
301/34: player.show_partial()
301/35: player.hit_or_stand()
301/36: player.check_total_points()
301/37: player.show_partial()
301/38:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.check_if_ace_in_hand()
    
    player.show_partial()
    player.hit_or_stand()
    player.check_if_ace_in_hand()
    player.check_total_points()
301/39: start_game()
302/1: import numpy as np
302/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
302/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
302/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
302/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
302/6: player = BlackJack()
302/7: #player.getBet()
302/8: player.deal_cards()
302/9: player.show_partial()
302/10: import numpy as np
302/11:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
302/12:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
302/13:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
302/14:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
302/15: player = BlackJack()
302/16: #player.getBet()
302/17:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.check_if_ace_in_hand()
    player.check_total_points()
302/18: start_game()
303/1: import numpy as np
303/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
303/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
303/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
303/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
303/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.check_if_ace_in_hand()
    player.check_total_points()
303/7: start_game()
304/1: import numpy as np
304/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
304/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
304/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
304/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
        
    def check_total_points(self):
        player_game_control = False
        dealer_game_control = False
        
        total_value_player, total_value_dealer  = self.get_total_value()
        print(total_value_player, total_value_dealer)
        
        if total_value_player > 21 and total_value_dealer > 21:
            print("Tie!")
        elif total_value_player > 21:
            player_game_control = False
            print("Dealer wins! Player goes bust!")
        elif total_value_dealer > 21:
            dealer_game_control = False
            print("Player wins! Dealer goes bust!")
        elif total_value_player == 21:
            if total_value_dealer == 21:
                print("Tie!")
            else:
                player_game_control = True
                print("Player wins!")
        elif total_value_dealer == 21:
            if total_value_player == 21:
                print("Tie!")
            else:
                dealer_game_control = True
                print("Dealer wins!")
        elif total_value_player > total_value_dealer:
            player_game_control = True
            print("Player wins!")
        elif total_value_player < total_value_dealer:
            dealer_game_control = True
            print("Dealer wins!")
        elif total_value_player == total_value_dealer:
            print("Tie!")
            
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
304/6: player = BlackJack()
304/7: #player.getBet()
304/8:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.check_if_ace_in_hand()
    player.check_total_points()
304/9: start_game()
304/10:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.check_total_points()
304/11: start_game()
304/12:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    
    player_hit = player.hit_or_stand()
    if player_hit is False:
        player.check_total_points()
        
    player.show_partial()
304/13: start_game()
304/14: start_game()
304/15: start_game()
304/16:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    game_control = False
    while game_control is False:
        total_value_player, total_value_dealer = player.check_total_points()
        game_control = player.run_rules(total_value_player,total_value_dealer)
        player.hit_or_stand()
304/17: start_game()
304/18:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    game_control = False
    while game_control is False:
        total_value_player, total_value_dealer = player.get_total_value()
        game_control = player.run_rules(total_value_player,total_value_dealer)
        player.hit_or_stand()
304/19: start_game()
305/1: import numpy as np
305/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
305/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
305/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
305/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
        
    def run_rules(self,total_value_player,total_value_dealer):
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
305/6: player = BlackJack()
305/7:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    game_control = False
    while game_control is False:
        total_value_player, total_value_dealer = player.get_total_value()
        game_control = player.run_rules(total_value_player,total_value_dealer)
        player.hit_or_stand()
305/8: start_game()
305/9:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    game_control = False
    while game_control is False:
        total_value_player, total_value_dealer = player.get_total_value()
        player.hit_or_stand()
        game_control = player.run_rules(total_value_player,total_value_dealer)
305/10: start_game()
305/11: start_game()
305/12:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    game_control = False
    while game_control is False:
        total_value_player, total_value_dealer = player.get_total_value()
        game_control = player.run_rules(total_value_player,total_value_dealer)
        player.hit_or_stand()
305/13: start_game()
306/1: import numpy as np
306/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
306/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
306/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
306/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
        
    def run_rules(self,total_value_player,total_value_dealer):
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
306/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    game_control = False
    while game_control is False:
        total_value_player, total_value_dealer = player.get_total_value()
        game_control = player.run_rules(total_value_player,total_value_dealer)
        if game_control is False:
            player.hit_or_stand()
306/7: start_game()
306/8:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    game_control = False
    while game_control is False:
        total_value_player, total_value_dealer = player.get_total_value()
        game_control = player.run_rules(total_value_player,total_value_dealer)
        if game_control is False:
            player.hit_or_stand()
306/9: start_game()
306/10:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    while total_value_player < 21 and total_value_player <21:
        total_value_player, total_value_dealer = player.get_total_value()
        player.run_rules(total_value_player,total_value_dealer)
        player.hit_or_stand()
306/11: start_game()
306/12:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    total_value_player, total_value_dealer = player.get_total_value()

    while total_value_player < 21 and total_value_player <21:
        player.run_rules(total_value_player,total_value_dealer)
        player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
306/13: start_game()
306/14:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    total_value_player, total_value_dealer = player.get_total_value()
    player.run_rules(total_value_player,total_value_dealer)

    while total_value_player < 21 and total_value_player <21:
        player.run_rules(total_value_player,total_value_dealer)
        player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
306/15: start_game()
306/16:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    total_value_player, total_value_dealer = player.get_total_value()
    player.run_rules(total_value_player,total_value_dealer)

    while total_value_player < 21 and total_value_player <21:
        player.hit_or_stand()
        player.run_rules(total_value_player,total_value_dealer)
        total_value_player, total_value_dealer = player.get_total_value()
306/17: start_game()
306/18:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    total_value_player, total_value_dealer = player.get_total_value()
    player.run_rules(total_value_player,total_value_dealer)

    while total_value_player < 21 and total_value_player <21:
        player.hit_or_stand()
        player.run_rules(total_value_player,total_value_dealer)
        total_value_player, total_value_dealer = player.get_total_value()
306/19: start_game()
306/20:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    total_value_player, total_value_dealer = player.get_total_value()
    player.run_rules(total_value_player,total_value_dealer)

    while total_value_player < 21 and total_value_player <21:
        player.hit_or_stand()
        player.run_rules(total_value_player,total_value_dealer)
        total_value_player, total_value_dealer = player.get_total_value()
306/21: start_game()
306/22:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    total_value_player, total_value_dealer = player.get_total_value()
    if total_value_player < 21 and total_value_dealer < 21:
        while total_value_player < 21 and total_value_player <21:
            player.hit_or_stand()
            player.run_rules(total_value_player,total_value_dealer)
            total_value_l_value_player, total_value_dealer = player.get_total_value()
    else:
        player.run_rules(total_value_player,total_value_dealer)
306/23: start_game()
307/1: import numpy as np
307/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
307/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
307/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
307/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self,total_value_player,total_value_dealer):
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
307/6: player = BlackJack()
307/7: import numpy as np
307/8:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
307/9:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
307/10:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
307/11:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self,total_value_player,total_value_dealer):
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
307/12:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    total_value_player, total_value_dealer = player.get_total_value()
    if total_value_player < 21 and total_value_dealer < 21:
        while total_value_player < 21 and total_value_player <21:
            total_value_l_value_player, total_value_dealer = player.get_total_value()
            player.hit_or_stand()
            player.run_rules(total_value_player,total_value_dealer)

    else:
        player.run_rules(total_value_player,total_value_dealer)
307/13: start_game()
308/1: import numpy as np
308/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
308/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
308/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
308/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self,total_value_player,total_value_dealer):
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
308/7: start_game()
308/8:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand
308/9:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
308/10: start_game()
308/11:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/12: start_game()
308/13:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self,total_value_player,total_value_dealer):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/14: player = BlackJack()
308/15: #player.getBet()
308/16:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/17: start_game()
308/18: import numpy as np
308/19:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
308/20:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
308/21:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
308/22:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self,total_value_player,total_value_dealer):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/23:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/24: start_game()
308/25:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/26:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/27: start_game()
308/28:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/29: player = BlackJack()
308/30: #player.getBet()
308/31:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/32: start_game()
308/33:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/34:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/35: start_game()
308/36:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            print(""============================================================\n")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/37:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            print("============================================================\n")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/38:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/39: start_game()
308/40:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/41: start_game()
308/42:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
                
    def run_rules(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
308/43: player = BlackJack()
308/44:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    player.run_rules()
308/45: start_game()
308/46: start_game()
308/47:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.hit_or_stand()
    total_value_player, total_value_dealer = player.get_total_value()
    print(total_value_player, total_value_dealer)
    player.run_rules()
308/48: start_game()
308/49:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    total_value_player, total_value_dealer = player.get_total_value()
    print(total_value_player, total_value_dealer)
    player.hit_or_stand()
    total_value_player, total_value_dealer = player.get_total_value()
    print(total_value_player, total_value_dealer)
    player.run_rules()
308/50: start_game()
308/51:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
        player.run_rules()
    player.hit_or_stand()
    total_value_player, total_value_dealer = player.get_total_value()
    print(total_value_player, total_value_dealer)
    player.run_rules()
308/52:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.run_rules()
    player.hit_or_stand()
    total_value_player, total_value_dealer = player.get_total_value()
    print(total_value_player, total_value_dealer)
    player.run_rules()
308/53: start_game()
308/54:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.run_rules()
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
308/55: start_game()
308/56:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.run_rules()
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
308/57: start_game()
308/58:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.run_rules()
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
308/59: start_game()
309/1: import numpy as np
309/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
309/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
309/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
309/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
    return player_hit
                
    def run_rules(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
309/6:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_control = False
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        return game_control

#         else:
#             elif total_value_player > total_value_dealer:
#                 player_game_control = True
#                 print("Player wins!")
#             elif total_value_player < total_value_dealer:
#                 dealer_game_control = True
#                 print("Dealer wins!")
#             elif total_value_player == total_value_dealer:
#                 print("Tie!")
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
309/7:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.run_rules()
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
        if player_hit is False:
            player.show_all()
            break
309/8: start_game()
309/9:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.run_rules()
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
        if player_hit is False:
            player.show_all()
            break
309/10: start_game()
309/11:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 or\
           total_value_dealer < 21 and player_hit = False:
            
            elif total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
309/12:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 or\
           total_value_dealer < 21 and player_hit == False:
            
            elif total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
309/13:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 or total_value_dealer < 21 and player_hit == False:

            elif total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
309/14:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 or total_value_dealer < 21 and player_hit == False:

            elif total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
309/15:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 or total_value_dealer < 21 and player_hit is False:

            elif total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
310/1: import numpy as np
310/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
310/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
310/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
310/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 or total_value_dealer < 21 and player_hit is False:

            elif total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
310/6:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            elif total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
310/7:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
310/8:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
        if player_hit is False:
            player.show_all()
            break
310/9: start_game()
311/1: import numpy as np
311/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
311/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
311/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
311/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
        self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
311/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
        if player_hit is False:
            player.show_all()
            break
311/7: start_game()
311/8:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
        if player_hit is False:
            player.show_all()
            break
311/9: start_game()
311/10: import numpy as np
311/11:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
311/12:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
311/13:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
311/14:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
311/15:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules()
        if player_hit is False:
            player.show_all()
            break
311/16: start_game()
311/17:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules(player_hit)
        if player_hit is False:
            player.show_all()
            break
311/18: start_game()
311/19:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        player.run_rules(player_hit)
        if player_hit is False:
            player.show_all()
            break
311/20: start_game()
311/21:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/22: start_game()
311/23:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/24: start_game()
311/25:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/26: start_game()
311/27:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/28: start_game()
311/29:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/30: start_game()
311/31:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/32: start_game()
311/33:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21:
            self.show_all()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
311/34:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        print(total_value_player, total_value_dealer)
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/35: start_game()
311/36: start_game()
311/37: start_game()
311/38: start_game()
311/39:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21:
            self.partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
311/40: start_game()
311/41:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21:
            self.partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
311/42:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/43: start_game()
311/44:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
311/45:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = True
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
311/46: start_game()
312/1: import numpy as np
312/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
312/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
312/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
312/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:

            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
312/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
312/7: start_game()
312/8: start_game()
312/9: start_game()
312/10: start_game()
312/11: start_game()
312/12: start_game()
312/13: start_game()
312/14: start_game()
312/15: start_game()
312/16: start_game()
312/17: start_game()
312/18: start_game()|
312/19: start_game()
312/20:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - \n").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
312/21:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
312/22: start_game()
312/23: start_game()
312/24:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
312/25: start_game()
312/26:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
312/27:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
312/28: start_game()
312/29:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
312/30: start_game()
312/31:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
312/32:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
312/33: start_game()
312/34:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
312/35: start_game()
312/36:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
312/37: start_game()
313/1: import numpy as np
313/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
313/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
313/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
313/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "- Hidden\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
313/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
313/7: start_game()
313/8: start_game()
313/9:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
313/10: start_game()
313/11: start_game()
313/12: start_game()
313/13: start_game()
313/14:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
313/15: start_game()
315/1: import numpy as np
315/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
315/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
315/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
315/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "<Card hidden>\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
315/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
315/7: start_game()
315/8:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + " <Card hidden>\n")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
315/9:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
315/10: start_game()
315/11:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
315/12:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
315/13: start_game()
315/14:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            game_control = True
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
315/15:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
315/16: start_game()
315/17: start_game()
315/18: start_game()
316/1: import numpy as np
316/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
316/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
316/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
316/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
316/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
316/7: start_game()
316/8: start_game()
316/9: start_game()
316/10: start_game()
316/11: start_game()
316/12:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
            
    return player
316/13: player = start_game()
316/14: player.deck
316/15: deck = [vars(cards) for cards in player.deck]
316/16: deck
316/17: len(deck)
316/18: deck
316/19: deck.shuffle_cards()
316/20: player.deck.shuffle_cards()
316/21: player.shuffle_cards()
316/22:
deck = [vars(cards) for cards in player.deck]
deck
316/23: player = start_game()
316/24: player = start_game()
316/25: player = start_game()
316/26: player = start_game()
316/27: player = start_game()
316/28: player = start_game()
316/29: player = start_game()
316/30: player = start_game()
317/1: import numpy as np
317/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
317/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
317/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
317/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        ace_control = False

        while ace_control is False:
            if any(ace_mask):
                ace_value = input("\nWould you like your Ace to be count 1 or 11? - \n")
                card_no_ace = ace_mask.index(True)
                try:
                    ace_value = int(ace_value)
                    if ace_value == 1:
                        self.pcards[card_no_ace].value = 1
                        ace_control = True
                    elif ace_value == 11:
                        ace_control = True
                    else:
                        print("\nPlease provide either 1 or 11!\n")
                except ValueError:
                    print("\nPlease provide a valid value!\n")
            else:
                ace_control = True
317/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
            
    return player
317/7: player = start_game()
317/8:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
318/1: import numpy as np
318/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
318/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
318/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
318/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
318/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
            
    return player
318/7: player = start_game()
318/8: player = start_game()
318/9: player = start_game()
318/10: player = start_game()
318/11: player = start_game()
318/12: player = start_game()
318/13: player = start_game()
318/14: player = start_game()
318/15: player = start_game()
318/16: player = start_game()
318/17: player = start_game()
318/18: player = start_game()
318/19: player = start_game()
318/20: player = start_game()
319/1: import numpy as np
319/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
319/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
319/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
319/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n Player's point exceeds 21 - Ace counts as 1 points!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
319/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
            
    return player
319/7: player = start_game()
319/8: player = start_game()
319/9: player = start_game()
319/10: player = start_game()
319/11: player = start_game()
319/12: player = start_game()
319/13: player = start_game()
319/14: player = start_game()
319/15: player = start_game()
319/16: player = start_game()
319/17: player = start_game()
319/18: player = start_game()
319/19: player = start_game()
319/20: player = start_game()
319/21: player = start_game()
320/1: import numpy as np
320/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
320/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
320/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
320/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                player_game_control = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                dealer_game_control = True
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
320/6:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    
    player_hit = None
    player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            player.run_rules(player_hit)
            break
        else:
            player.run_rules(player_hit)
            
    return player
320/7: player = start_game()
320/8:
player = start_game()
print(game_win)
320/9:
player, game_win= start_game()
print(game_win)
320/10:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print(game_win)
    return player
320/11: player= start_game()
320/12: player= start_game()
320/13: player= start_game()
320/14:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print(game_win)
    return player
320/15: player= start_game()
320/16: player= start_game()
320/17:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("Game win= %s" % game_win)
    return player
320/18: player= start_game()
320/19:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!\n")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = False
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                game_win = None
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    game_win = None
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    game_win = None
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                game_win = None
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            game_win = None
            self.show_partial()
            
        return game_win
320/20:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("Game win= %s" % game_win)
    return player
320/21: player= start_game()
320/22: player= start_game()
320/23: player= start_game()
320/24:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!\n")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        return game_win
320/25:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("Game win= %s" % game_win)
    return player
320/26: player= start_game()
320/27: player= start_game()
320/28: player= start_game()
320/29: player= start_game()
320/30:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
320/31: player= start_game()
320/32:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        return game_win
320/33:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
320/34: player= start_game()
320/35:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        return game_win
320/36:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        pass
    def lose(self):
        pass
    def draw(self):
        pass
320/37: import numpy as np
320/38:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
320/39:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        print("WINNNNNNNNNNNNNNNNNNNNNN")
        pass
    def lose(self):
        print("LOSEEEEEEEEEEEEEEEEEEEEE")
        pass
    def draw(self):
        print("DRAWWWWWWWWWWWWWWWWWWWWW")
        pass
320/40:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
320/41:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        self.check_result(game_win)
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
320/42:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
320/43: player= start_game()
320/44: player= start_game()
320/45: player= start_game()
320/46: player= start_game()
320/47: player= start_game()
320/48:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        if player_hit is not None:    
            self.check_result(game_win)
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
320/49:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
320/50: player= start_game()
320/51:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
320/52: player= start_game()
320/53:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        if player_hit is not None or player_hit is False:    
            self.check_result(game_win)
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
320/54:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
320/55: player= start_game()
320/56: player= start_game()
320/57: player= start_game()
320/58: player= start_game()
320/59: player= start_game()
320/60: player= start_game()
320/61: player= start_game()
320/62:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        if player_hit is not None:
            if player_hit is False:
            self.check_result(game_win)
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
320/63: player= start_game()
320/64: player= start_game()
320/65: player= start_game()
320/66: player= start_game()
320/67: player= start_game()
320/68: player= start_game()
321/1: import numpy as np
321/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
321/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        print("WINNNNNNNNNNNNNNNNNNNNNN")
        pass
    def lose(self):
        print("LOSEEEEEEEEEEEEEEEEEEEEE")
        pass
    def draw(self):
        print("DRAWWWWWWWWWWWWWWWWWWWWW")
        pass
321/4: import numpy as np
321/5:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
321/6:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        print("WINNNNNNNNNNNNNNNNNNNNNN")
        pass
    def lose(self):
        print("LOSEEEEEEEEEEEEEEEEEEEEE")
        pass
    def draw(self):
        print("DRAWWWWWWWWWWWWWWWWWWWWW")
        pass
321/7:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
321/8:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        if player_hit is not None:
            if player_hit is False:
                self.check_result(game_win)
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
321/9:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/10: player= start_game()
321/11: player= start_game()
321/12: player= start_game()
321/13: player= start_game()
321/14:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            self.show_partial()
            
        if player_hit is not None:
            self.check_result(game_win)
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
321/15:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/16: player= start_game()
321/17: player= start_game()
321/18:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        if player_hit is not None and continue_check is not False:
            self.check_result(game_win)
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
321/19:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/20: player= start_game()
321/21: player= start_game()
321/22:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/23: player= start_game()
321/24: player= start_game()
321/25: player= start_game()
321/26:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
321/27:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    #player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/28: player= start_game()
321/29: player= start_game()
321/30: player= start_game()
321/31: player= start_game()
321/32: player= start_game()
321/33: player= start_game()
321/34: player= start_game()
321/35: player= start_game()
321/36: player= start_game()
321/37: player= start_game()
321/38: player= start_game()
321/39: player= start_game()
321/40: player= start_game()
321/41: player= start_game()
321/42: player= start_game()
321/43: player= start_game()
321/44: import numpy as np
321/45:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
321/46:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += bet*2
        
    def lose(self):
        self.money -= bet*2
        
    def draw(self):
        self.money = self.money
321/47:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
321/48:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\n Your current outstanding stands at: %s \n" % self.money)
321/49:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/50: import numpy as np
321/51:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
321/52:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.pcards = []
        
    def update_money(self,bet):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += bet*2
        
    def lose(self):
        self.money -= bet*2
        
    def draw(self):
        self.money = self.money
321/53:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
321/54:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\n Your current outstanding stands at: %s \n" % self.money)
321/55:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/56: player= start_game()
321/57: import numpy as np
321/58:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
321/59:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if bet <= self.money:
            self.money -= bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += bet*2
        
    def lose(self):
        self.money -= bet*2
        
    def draw(self):
        self.money = self.money
321/60:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
321/61:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money(bet)
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\n Your current outstanding stands at: %s \n" % self.money)
321/62:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/63: player= start_game()
321/64: import numpy as np
321/65:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
321/66:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
321/67:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
321/68:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - \n")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\n Your current outstanding stands at: %s \n" % self.money)
321/69:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    print("\nGame win= %s\n" % game_win)
    return player
321/70: player= start_game()
321/71:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    #print("\nGame win= %s\n" % game_win)
    return player
321/72: player= start_game()
321/73: import numpy as np
321/74:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
321/75:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
321/76:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
321/77:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
321/78:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)
            break
        else:
            game_win = player.run_rules(player_hit)
            
    #print("\nGame win= %s\n" % game_win)
    return player
321/79: player= start_game()
321/80: player= start_game()
321/81:
def start_game():
    
    player = BlackJack()
    player.deal_cards()
    player.show_partial()
    player.check_if_ace_in_hand()
    player.get_bet()
    
    player_hit = None
    game_win = player.run_rules(player_hit)
    total_value_player, total_value_dealer = player.get_total_value()
    
    while total_value_player < 21 and total_value_dealer < 21:
        player_hit = player.hit_or_stand()
        total_value_player, total_value_dealer = player.get_total_value()
        if player_hit is False:
            game_win = player.run_rules(player_hit)

            break
        else:
            game_win = player.run_rules(player_hit)
            
    continue_playing = input("Would you like to continue playing?")
            
    #print("\nGame win= %s\n" % game_win)
    return player
321/82: player= start_game()
321/83:
def start_game():
    
    player = BlackJack()
    continue_playing = True
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()
    
        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y'
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
321/84: player= start_game()
321/85:
def start_game():
    
    player = BlackJack()
    continue_playing = True
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()
    
        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
321/86: player= start_game()
322/1:
def start_game():
    
    while continue_playing is True:
        player = BlackJack()
        continue_playing = True

        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
322/2: player= start_game()
322/3:
def start_game():
    continue_playing = True
    
    while continue_playing is True:
        player = BlackJack()
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
322/4: player= start_game()
322/5: import numpy as np
322/6:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
322/7:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
322/8:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
322/9:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
322/10:
def start_game():
    continue_playing = True
    
    while continue_playing is True:
        player = BlackJack()
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
322/11: player= start_game()
322/12:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
322/13: player= start_game()
323/1: import numpy as np
323/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
323/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
323/4: import numpy as np
323/5:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
323/6:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
323/7:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = None
        self.dcards = None
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
323/8:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
323/9:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
323/10: player= start_game()
323/11:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = []
        self.dcards = []
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
323/12: import numpy as np
323/13:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
323/14:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money += self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
323/15:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = []
        self.dcards = []
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
323/16:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
323/17:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
323/18: player= start_game()
324/1: import numpy as np
324/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
324/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money =self.money + self.bet*2
        
    def lose(self):
        self.money = self.money - self.bet*2
        
    def draw(self):
        self.money = self.money
324/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = []
        self.dcards = []
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
324/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
324/6:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)

                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
324/7: player= start_game()
325/1: import numpy as np
325/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
325/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money =self.money + self.bet*3
        
    def lose(self):
        self.money = self.money - self.bet*3
        
    def draw(self):
        self.money = self.money + self.bet
325/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = []
        self.dcards = []
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
325/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
325/6:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)
                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
325/7: player= start_game()
326/1: import numpy as np
326/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
326/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money =self.money + self.bet*3
        
    def lose(self):
        self.money = self.money - self.bet*3
        
    def draw(self):
        self.money = self.money + self.bet
326/4: import numpy as np
326/5:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
326/6:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def update_money(self):
        if self.bet <= self.money:
            self.money -= self.bet
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money =self.money + self.bet*3
        
    def lose(self):
        self.money = self.money - self.bet*3
        
    def draw(self):
        self.money = self.money + self.bet
326/7:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = []
        self.dcards = []
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
326/8:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.update_money()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
326/9:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)
                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
326/10: player= start_game()
327/1: import numpy as np
327/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
327/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def check_bet_amount(self):
        if self.bet <= self.money:
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money +=self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
327/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = []
        self.dcards = []
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
327/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.check_bet_amount()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
327/6:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)
                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
327/7: player= start_game()
327/8:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)
                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
327/9: player= start_game()
327/10: player= start_game()
327/11: player= start_game()
327/12: from blackjack import *
327/13: player = start_game
327/14: player = start_game()
333/1: from blackjack import *
333/2: player = start_game()
334/1: from blackjack import *
334/2: player = start_game()
335/1: import pandas as pd
335/2:
path = r"C:\Users\Cagri\Google Drive\A_Uni of Southampton Lessons\SEMESTER II\Visual Basic\ALL_MATERIAL\Assignments\Assignment 3\Assignment3TrialData.csv"
df = pd.read_csv(path)
335/3: df
335/4:
dict_of_elements = {}

for rows in df.iterrows():
    print(rows)
335/5: df
335/6:
dict_of_elements = {}

for rows in df.iterrows():
    print(rows["Stock ID"])
335/7:
dict_of_elements = {}
test = []

for rows in df.iterrows():
    test.append(rows)
335/8: test
335/9: test[0]
335/10: type(test[0])
335/11: test[0]
335/12: test[0][0]
335/13: test[0]
335/14:
def get_first_column_as_key(rows):
    
    dict_of_elements.key = rows["Stock Name"]
335/15: dict_of_elements.key
335/16: dict_of_elements.keys
335/17: dict_of_elements.keys()
335/18:
def get_first_column_as_key(rows):
    dict_of_elements[rows["Stock Name"]] = None
335/19: df.apply(get_first_column_as_key~)
335/20: df.apply(get_first_column_as_key)
335/21: df.apply(get_first_column_as_key, axis = 0)
335/22: df.apply(get_first_column_as_key, axis = 1)
335/23: dict_of_elements
335/24:
def get_first_column_as_key(rows):
    dict_of_elements[rows["Stock Name"]] = None
335/25:
def get_values(rows):
    dict_of_elements[rows["Stock Name"]] = {"Stock ID": rows["Stock ID"],
                                           "Expected Return": rows["Expected Return"]
                                           "Standard Derivation": rows["Standard Derivation"]}
335/26:
def get_values(rows):
    dict_of_elements[rows["Stock Name"]] = {"Stock ID": rows["Stock ID"],
                                           "Expected Return": rows["Expected Return"],
                                           "Standard Derivation": rows["Standard Derivation"]}
335/27: df.apply(get_values, axis = 1)
335/28: import pandas as pd
335/29:
path = r"C:\Users\Cagri\Google Drive\A_Uni of Southampton Lessons\SEMESTER II\Visual Basic\ALL_MATERIAL\Assignments\Assignment 3\Assignment3TrialData.csv"
df = pd.read_csv(path)
335/30: df
335/31:
dict_of_elements = {}
test = []

for rows in df.iterrows():
    test.append(rows)
335/32:
def get_values(rows):
    dict_of_elements[rows["Stock Name"]] = {"Stock ID": rows["Stock ID"],
                                           "Expected Return": rows["Expected Return"],
                                           "Standard Derivation": rows["Standard Derivation"]}
335/33: df.apply(get_first_column_as_key, axis = 1)
335/34: df.apply(get_values, axis = 1)
336/1: import pandas as pd
336/2:
path = r"C:\Users\Cagri\Google Drive\A_Uni of Southampton Lessons\SEMESTER II\Visual Basic\ALL_MATERIAL\Assignments\Assignment 3\Assignment3TrialData.csv"
df = pd.read_csv(path)
336/3: df
336/4:
dict_of_elements = {}
test = []

for rows in df.iterrows():
    test.append(rows)
336/5:
def get_values(rows):
    dict_of_elements[rows["Stock Name"]] = {"Stock ID": rows["Stock ID"],
                                           "Expected Return": rows["Expected Return"],
                                           "Standard Derivation": rows["Standard Derivation"]}
336/6: df.apply(get_first_column_as_key, axis = 1)
336/7: df.apply(get_values, axis = 1)
336/8: dict_of_elements
336/9: dict_of_elements
336/10: dict_of_elements["Microsoft"]
336/11: dict_of_elements["Microsoft"]["Stock ID"]
337/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
337/2: import re
337/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
337/4: login = Login(driver, data)
337/5: login.login()
337/6: fb = Facebook(driver)
337/7: fb.search_user('Mustafa Cagri Ardic')
337/8: fb.search_user('Nursel Ardic')
337/9: fb.getFriends()
337/10: hakkinda_information = fb.getHakkinda()
337/11: fb.search_user('Mustafa Cagri Ardic')
337/12: fb.getFriends()
337/13: hakkinda_information = fb.getHakkinda()
338/1: from blackjack import *
338/2: player = start_game()
338/3: player = start_game()
339/1: import ps5.py
339/2: import ps5
339/3: import ps5_test
339/4: test_NewsStory = ps5_test.ProblemSet5NewsStory()
339/5: test_NewsStory.testNewsStoryConstructor
339/6: testNewsStoryConstructor.()
339/7: testNewsStoryConstructor()
339/8: testNews.StoryConstructor()
339/9: test_NewsStory.testNewsStoryConstructor()
339/10: test_NewsStory = ps5_test.ProblemSet5NewsStory()
339/11: test_NewsStory.testNewsStoryConstructor()
339/12: test_NewsStory
339/13: type(test_NewsStory)
339/14:  ps5_test.ProblemSet5NewsStory.testNewsStoryConstructor()
339/15: ns_object = NewsStory(0)
339/16: ns_object = NewsStory()
339/17: ns_object = ps5.NewsStory()
339/18: import ps5
339/19: ns_object = ps5.NewsStory()
340/1: import ps5
340/2: import ps5
340/3:
match_list = ['PURPLE COW',
'The purple cow is soft and cuddly.',
'The farmer owns a really PURPLE cow.',
'Purple!!! Cow!!!',
'purple@#$%cow',
'Did you see a purple cow?']
340/4:
not_match_list = ['Purple cows are cool!',
'The purple blob over there is a cow.',
'How now brown cow.',
'Cow!!! Purple!!!',
'purplecowpurplecowpurplecow']
340/5: string_phrase = "purple cow"
340/6: match_list.lower()
340/7: map(str.lower,match_list)
340/8: match_list = list(map(str.lower,match_list))
340/9: match_list
340/10: strings_to_replace = ["!","@","#","$","%"]
340/11:
for text in match_list:
    for symbols in strings_to_replace:
340/12:
for text in match_list:
    for symbols in strings_to_replace:
        text.replace(symbols, "")
340/13:
for text in match_list:
    for symbols in strings_to_replace:
        text.replace(symbols, "")
        print(text)
340/14:
for text in match_list:
    for symbols in strings_to_replace:
        print(text.replace(symbols, ""))
340/15: "purple cow!".replace("!", "")
340/16:
for text in match_list:
    for symbols in strings_to_replace:
        print(symbols)
        print(text.replace(symbols, ""))
340/17:
for text in match_list:
    for symbols in strings_to_replace:
        print(text.replace(symbols, ""))
340/18:
for index, text in enumerate(match_list):
    for symbols in strings_to_replace:
        match_list[index] = text.replace(symbols, "")
340/19: match_list
340/20:
for text in match_list:
    for symbols in strings_to_replace:
        text.replace(symbols, "")
340/21: match_list
340/22:
for index, text in enumerate(match_list):
    print(index, text)
340/23: match_list[0]
340/24: match_list[0] = "purple cow!"
340/25: match_list
340/26:
for index, text in enumerate(match_list):
    for symbols in symbols_to_replace:
        match_list[index] = text.replace(symbols, "")
        print(match_list)
340/27: symbols_to_replace = ["!","@","#","$","%"]
340/28:
for index, text in enumerate(match_list):
    for symbols in symbols_to_replace:
        match_list[index] = text.replace(symbols, "")
        print(match_list)
340/29:
for index, text in enumerate(match_list):
    for symbols in symbols_to_replace:
        match_list[index] = text.replace(symbols, "")
        print(match_list[index])
340/30:
match_list = ['purple cow',
 'the purple cow is soft and cuddly.',
 'the farmer owns a really purple cow.',
 'purple!!! cow!!!',
 'purple@#$%cow',
 'did you see a purple cow?']
340/31:
symbols_to_replace = ["!","@","#","$","%"]

for index, text in enumerate(match_list):
    for symbols in symbols_to_replace:
        match_list[index] = text.replace(symbols, "")
        print(match_list[index])
340/32:
symbols_to_replace = ["!","@","#","$","%"]

for index, text in enumerate(match_list):
    for symbols in symbols_to_replace:
        text = text.replace(symbols, "")
        match_list[index] = text
        print(match_list[index])
340/33:
symbols_to_replace = ["!","@","#","$","%"]

for index, text in enumerate(match_list):
    for symbols in symbols_to_replace:
        text = text.replace(symbols, "")
        match_list[index] = text
340/34: text
340/35: match_list
340/36:
match_list = ['PURPLE COW',
'The purple cow is soft and cuddly.',
'The farmer owns a really PURPLE cow.',
'Purple!!! Cow!!!',
'purple@#$%cow',
'Did you see a purple     cow?']
340/37:
not_match_list = ['Purple cows are cool!',
'The purple blob over there is a cow.',
'How now brown cow.',
'Cow!!! Purple!!!',
'purplecowpurplecowpurplecow']
340/38: string_phrase = "purple cow"
340/39: match_list = list(map(str.lower,match_list))
340/40: match_list
340/41:
match_list = ['purple cow',
 'the purple cow is soft and cuddly.',
 'the farmer owns a really purple cow.',
 'purple!!! cow!!!',
 'purple@#$%cow',
 'did you see a purple cow?']
340/42:
symbols_to_replace = ["!","@","#","$","%"]

for index, text in enumerate(match_list):
    for symbols in symbols_to_replace:
        text = text.replace(symbols, "")
        match_list[index] = text
340/43: match_list
340/44: match_list
340/45:
match_list = ['purple cow',
 'the purple cow is soft and cuddly.',
 'the farmer owns a really purple cow.',
 'purple!!! cow!!!',
 'purple@#$%cow',
 'did you see a purple cow?']
340/46:
symbols_to_replace = ["!","@","#","$","%"]

for index, text in enumerate(match_list):
    for symbols in symbols_to_replace:
        text = text.replace(symbols, "")
        match_list[index] = text
340/47: match_list
340/48: test = ["purple cow" element for element in match_list]
340/49: test = ["purple cow" in element for element in match_list]
340/50: test
340/51: cuddly    = NewsStory('', 'The purple cow is soft and cuddly.', '', '', datetime.now())
340/52: import ps5
340/53: cuddly    = NewsStory('', 'The purple cow is soft and cuddly.', '', '', datetime.now())
340/54: cuddly = ps5.NewsStory('', 'The purple cow is soft and cuddly.', '', '', datetime.now())
340/55: cuddly = ps5.NewsStory('', 'The purple cow is soft and cuddly.', '', '', datetime.now())
340/56: from ps5 import *
340/57: cuddly = ps5.NewsStory('', 'The purple cow is soft and cuddly.', '', '', datetime.now())
340/58: cuddly = ps5.NewsStory('', 'The purple cow is soft and cuddly.', '', '', datetime.now())
340/59: cuddly
340/60: vars(cuddly)
340/61: s1 = TitleTrigger('PURPLE COW')
340/62: s1 = PhraseTrigger('PURPLE COW')
340/63: s1 = ps5.TitleTrigger('PURPLE COW')
340/64: s1 = ps5.TitleTrigger('PURPLE COW')
340/65: s1 = TitleTrigger('PURPLE COW')
340/66: s1 = Trigger('PURPLE COW')
340/67: s1 = PhraseTrigger('PURPLE COW')
340/68: s1 = Trigger.PhraseTrigger('PURPLE COW')
340/69: s1 = PhraseTrigger('PURPLE COW')
340/70: s1 = PhraseTrigger('PURPLE COW')
340/71: s1 = PhraseTrigger('PURPLE COW')
340/72: s1 = PhraseTrigger('PURPLE COW')
340/73: s1 = PhraseTrigger
340/74: ps5.dir
340/75: ps5
340/76:
import sys
current_module = sys.modules[__name__]
340/77: current_module
340/78:
import sys
current_module = sys.modules[ps5]
340/79:
import sys
current_module = sys.modules[__ps5__]
340/80:
import sys
current_module = sys.modules[ps5]
341/1: from Tkinter import *
341/2:
import sys
!{sys.executable} -m pip install Tkinter
341/3:
import sys
!{sys.executable} -m pip install tkinter
341/4: import tkinter
341/5: m=tkinter.Tk() where m is the name of the main window object
341/6: m=tkinter.Tk()
341/7: m.mainloop()
341/8: w=Button(master, option=value)
341/9:
button = tk.Button(r, text='Stop', width=25, command=r.destroy) 
button.pack() 
m.mainloop()
341/10: m=tkinter.tk()
341/11: import tkinter as tk
341/12: m=tkinter.tk()
341/13: m=tkinter.Tk()
341/14:
button = Tk.Button(r, text='Stop', width=25, command=r.destroy) 
button.pack() 
m.mainloop()
341/15:
button = m.Button(r, text='Stop', width=25, command=r.destroy) 
button.pack() 
m.mainloop()
341/16:
import tkinter as tk 
r = tk.Tk() 
r.title('Counting Seconds') 
button = tk.Button(r, text='Stop', width=25, command=r.destroy) 
button.pack() 
r.mainloop()
341/17:
import tkinter as tk 
r = tk.Tk() 
r.title('Counting Seconds') 
button = tk.Button(r, text='Stop', width=25, command=r.destroy) 
button.pack() 
r.mainloop()
341/18:
import tkinter as tk 
r = tk.Tk() 
r.title('Counting Seconds') 
button = tk.Button(r, text='Stop', width=25, command=r.destroy) 
button.pack() 
r.mainloop()
341/19: w = Canvas(master, option=value)
341/20:
from tkinter import *
master = Tk() 
w = Canvas(master, width=40, height=60) 
w.pack() 
canvas_height=20
canvas_width=200
y = int(canvas_height / 2) 
w.create_line(0, y, canvas_width, y ) 
mainloop()
341/21:
from tkinter import *
master = Tk() 
var1 = IntVar() 
Checkbutton(master, text='male', variable=var1).grid(row=0, sticky=W) 
var2 = IntVar() 
Checkbutton(master, text='female', variable=var2).grid(row=1, sticky=W) 
mainloop()
341/22:
from tkinter import *
master = Tk() 
Label(master, text='First Name').grid(row=0) 
Label(master, text='Last Name').grid(row=1) 
e1 = Entry(master) 
e2 = Entry(master) 
e1.grid(row=0, column=1) 
e2.grid(row=1, column=1) 
mainloop()
341/23:
from tkinter import *
  
root = Tk() 
frame = Frame(root) 
frame.pack() 
bottomframe = Frame(root) 
bottomframe.pack( side = BOTTOM ) 
redbutton = Button(frame, text = 'Red', fg ='red') 
redbutton.pack( side = LEFT) 
greenbutton = Button(frame, text = 'Brown', fg='brown') 
greenbutton.pack( side = LEFT ) 
bluebutton = Button(frame, text ='Blue', fg ='blue') 
bluebutton.pack( side = LEFT ) 
blackbutton = Button(bottomframe, text ='Black', fg ='black') 
blackbutton.pack( side = BOTTOM) 
root.mainloop()
341/24:
from tkinter import *
  
root = Tk() 
frame = Frame(root) 
# frame.pack()
bottomframe = Frame(root) 
bottomframe.pack( side = BOTTOM ) 
redbutton = Button(frame, text = 'Red', fg ='red') 
redbutton.pack( side = LEFT) 
greenbutton = Button(frame, text = 'Brown', fg='brown') 
greenbutton.pack( side = LEFT ) 
bluebutton = Button(frame, text ='Blue', fg ='blue') 
bluebutton.pack( side = LEFT ) 
blackbutton = Button(bottomframe, text ='Black', fg ='black') 
blackbutton.pack( side = BOTTOM) 
root.mainloop()
341/25:
from tkinter import *
  
root = Tk() 
frame = Frame(root) 
frame.pack()
bottomframe = Frame(root) 
bottomframe.pack( side = BOTTOM ) 
redbutton = Button(frame, text = 'Red', fg ='red') 
redbutton.pack( side = LEFT) 
greenbutton = Button(frame, text = 'Brown', fg='brown') 
greenbutton.pack( side = LEFT ) 
bluebutton = Button(frame, text ='Blue', fg ='blue') 
bluebutton.pack( side = LEFT ) 
blackbutton = Button(bottomframe, text ='Black', fg ='black') 
blackbutton.pack( side = BOTTOM) 
root.mainloop()
341/26: window = tkinter.Tk()
341/27:
window = tkinter.Tk()
window.title("My first GUI")
341/28: label = tkinter.Label(window, text = "Hello World!").pack()
341/29: window.mainloop()
341/30:
window = tkinter.Tk()
window.title("My first GUI")
341/31: label = tkinter.Label(window, text = "Hello World!").pack()
341/32: window.mainloop()
341/33: window.mainloop()
341/34:
window = tkinter.Tk()
window.title("My first GUI")
341/35: label = tkinter.Label(window, text = "Hello World!").pack()
341/36: window.mainloop()
341/37:
window = tkinter.Tk()
window.title("My first GUI")
341/38:
top_frame = tkinter.Frame(window).pack()
bottom_frame = tkinter.Frame(window).pack(side = "bottom")
341/39: window.mainloop()
341/40:
window = tkinter.Tk()
window.title("My first GUI")
341/41:
top_frame = tkinter.Frame(window).pack()
bottom_frame = tkinter.Frame(window).pack(side = "bottom")
341/42:
btn1 = tkinter.Button(top_frame, text = "Button1", fg = "red").pack()# 'fg - foreground' is used to color the contents
btn2 = tkinter.Button(top_frame, text = "Button2", fg = "green").pack()# 'text' is used to write the text on the Button
btn3 = tkinter.Button(bottom_frame, text = "Button2", fg = "purple").pack(side = "left")# 'side' is used to align the widgets
btn4 = tkinter.Button(bottom_frame, text = "Button2", fg = "orange").pack(side = "left")
341/43: window.mainloop()
341/44:
window = tkinter.Tk()
window.title("My first GUI")
341/45:
top_frame = tkinter.Frame(window).pack()
bottom_frame = tkinter.Frame(window).pack(side = "bottom")
341/46: button_1 = tkinter.Button(top_frame, text = "Hello").pack()
341/47: window.mainloop()
341/48:
import tkinter

window = tkinter.Tk()
window.title("GUI")

# creating 3 simple Labels containing any text

# sufficient width
tkinter.Label(window, text = "Suf. width", fg = "white", bg = "purple").pack()

# width of X
tkinter.Label(window, text = "Taking all available X width", fg = "white", bg = "green").pack(fill = "x")

# height of Y
tkinter.Label(window, text = "Taking all available Y height", fg = "white", bg = "black").pack(side = "left", fill = "y")

window.mainloop()
342/1: from hangman_my_solution import *
342/2: hangman_my_solution.setup_game()
342/3: hangman_my_solution.setup_game()
342/4: hangman_my_solution.init_game()
342/5: import hangman_my_solution
342/6: hangman_my_solution.setup_game()
342/7: hangman_my_solution.init_game()
343/1: import hangman_my_solution
343/2: hangman_my_solution.setup_game()
343/3: hangman_my_solution.init_game()
344/1: import hangman_my_solution
344/2: # hangman_my_solution.setup_game()
344/3: hangman_my_solution.init_game()
345/1: import hangman_my_solution
346/1: import hangman_my_solution
346/2: # hangman_my_solution.setup_game()
346/3: hangman_my_solution.init_game()
347/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
347/2: # hangman_my_solution.setup_game()
347/3: hangman_my_solution.init_game()
349/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
349/2: # hangman_my_solution.setup_game()
349/3: hangman_my_solution.init_game()
349/4:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
349/5: # hangman_my_solution.setup_game()
349/6: hangman_my_solution.init_game()
350/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
350/2: # hangman_my_solution.setup_game()
350/3: hangman_my_solution.init_game()
351/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/2: # hangman_my_solution.setupGame()
351/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/4: # hangman_my_solution.setupGame()
351/5:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/6: # hangman_my_solution.setupGame()
351/7:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/8:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/9:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/10:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/11:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/12:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/13:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/14:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/15:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/16:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
351/17: import hangman_my_solution
352/1: import hangman_my_solution
352/2: # hangman_my_solution.setupGame()
352/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
352/4: # hangman_my_solution.setupGame()
352/5: hangman_my_solution.initGame()
352/6:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
352/7: # hangman_my_solution.setupGame()
352/8: hangman_my_solution.initGame()
352/9:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
352/10: # hangman_my_solution.setupGame()
352/11: hangman_my_solution.initGame()
353/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
353/2: # hangman_my_solution.setupGame()
353/3: hangman_my_solution.initGame()
353/4: hangman_my_solution.initGame()
353/5:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
353/6: # hangman_my_solution.setupGame()
354/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
354/2: # hangman_my_solution.setupGame()
354/3: hangman_my_solution.initGame()
354/4:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
354/5: # hangman_my_solution.setupGame()
354/6: hangman_my_solution.initGame()
355/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
355/2: # hangman_my_solution.setupGame()
355/3: hangman_my_solution.initGame()
356/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
356/2: # hangman_my_solution.setupGame()
356/3: hangman_my_solution.initGame()
357/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
357/2: # hangman_my_solution.setupGame()
357/3: selected_word = hangman_my_solution.initGame()
357/4: selected_word
357/5: type(selected_word)
357/6:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
357/7: # hangman_my_solution.setupGame()
357/8: selected_word = hangman_my_solution.initGame()
358/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
358/2: # hangman_my_solution.setupGame()
358/3: selected_word = hangman_my_solution.initGame()
358/4: selected_word
358/5:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
358/6: # hangman_my_solution.setupGame()
358/7: hangman_my_solution.initGame()
359/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
359/2: # hangman_my_solution.setupGame()
359/3: hangman_my_solution.initGame()
359/4: selected_word
359/5: select_word
359/6:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
360/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
360/2: # hangman_my_solution.setupGame()
360/3: hangman_my_solution.initGame()
360/4: select_word
360/5: no_of_guesses
361/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
361/2: # hangman_my_solution.setupGame()
361/3: hangman_my_solution.initGame()
361/4: no_of_guesses
361/5: select_word
362/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
362/2: # hangman_my_solution.setupGame()
363/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
363/2: # hangman_my_solution.setupGame()
363/3: secret_word= hangman_my_solution.initGame()
363/4: select_word
363/5: secret_word
363/6: secret_word.split("")
363/7: secret_word.split()
363/8: "q" in "quantified"
363/9: guesses = ['a', 'b', 'c', 'd', 'e', 'f']
363/10: guesses = ['a', 'b', 'c', 'd', 'e', 'f']
363/11:
for letter in "quantified":
    if letter not in guesses:
        print(letter)
363/12:
output = []

for letter in "quantified":
    if letter not in guesses:
        output.append(_)
    else:
        output.append(letter)
        
output
363/13:
output = []

for letter in "quantified":
    if letter not in guesses:
        output.append("_")
    else:
        output.append(letter)
        
output
363/14:
output = []

for letter in "quantified":
    if letter not in guesses:
        output.append("_")
    else:
        output.append(letter)
        
"".join(output)
364/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
364/2: # hangman_my_solution.setupGame()
364/3: secret_word= hangman_my_solution.initGame()
364/4: secret_word
364/5: secret_word
365/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
365/2: # hangman_my_solution.setupGame()
365/3: secret_word= hangman_my_solution.initGame()
366/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
366/2: # hangman_my_solution.setupGame()
366/3: secret_word= hangman_my_solution.initGame()
367/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
367/2: # hangman_my_solution.setupGame()
367/3: secret_word= hangman_my_solution.initGame()
368/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
368/2: # hangman_my_solution.setupGame()
368/3: secret_word= hangman_my_solution.initGame()
369/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
369/2: # hangman_my_solution.setupGame()
369/3: secret_word= hangman_my_solution.initGame()
370/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
370/2: # hangman_my_solution.setupGame()
370/3: secret_word= hangman_my_solution.initGame()
371/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
371/2: # hangman_my_solution.setupGame()
371/3: secret_word= hangman_my_solution.initGame()
372/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
372/2: # hangman_my_solution.setupGame()
372/3: secret_word= hangman_my_solution.initGame()
373/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
373/2: # hangman_my_solution.setupGame()
373/3: secret_word= hangman_my_solution.initGame()
374/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
374/2: # hangman_my_solution.setupGame()
374/3: secret_word= hangman_my_solution.initGame()
375/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
375/2: # hangman_my_solution.setupGame()
375/3: secret_word= hangman_my_solution.initGame()
376/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
376/2: # hangman_my_solution.setupGame()
376/3: secret_word= hangman_my_solution.initGame()
377/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
377/2: # hangman_my_solution.setupGame()
377/3: secret_word= hangman_my_solution.initGame()
379/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
379/2:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
379/3: # hangman_my_solution.setupGame()
380/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
380/2: # hangman_my_solution.setupGame()
380/3: secret_word= hangman_my_solution.initGame()
381/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
381/2: # hangman_my_solution.setupGame()
381/3: secret_word= hangman_my_solution.initGame()
382/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
382/2: # hangman_my_solution.setupGame()
383/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
383/2: # hangman_my_solution.setupGame()
383/3: secret_word= hangman_my_solution.initGame()
383/4: secret_word= hangman_my_solution.initGame()
385/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
385/2: # hangman_my_solution.setupGame()
385/3: secret_word= hangman_my_solution.initGame()
386/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
386/2: # hangman_my_solution.setupGame()
386/3: secret_word= hangman_my_solution.initGame()
387/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
387/2: # hangman_my_solution.setupGame()
387/3: secret_word= hangman_my_solution.initGame()
389/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
389/2: # hangman_my_solution.setupGame()
389/3: secret_word= hangman_my_solution.initGame()
390/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
390/2: secret_word= hangman_my_solution.initGame()
391/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
391/2: secret_word= hangman_my_solution.initGame()
393/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
393/2: secret_word= hangman_my_solution.initGame()
394/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
394/2: secret_word= hangman_my_solution.initGame()
395/1: print("Kayahan yarrak yedi %s" %10)
395/2: print("Kayahan %s yarrak yedi " %10)
395/3: print("Kayahan 10 yarrak yedi ")
395/4: print("Kayahan %s yarrak yedi " %100.23)
395/5: print("Kayahan %.2f yarrak yedi " %100.2364)
395/6: print("Kayahan %.0f yarrak yedi " %100.2364)
395/7: print("Kayahan %.1f yarrak yedi " %100.2364)
395/8: print("Kayahan %.2f yarrak yedi " %100.2364)
395/9: print("Kayahan %i yarrak yedi " %100.2364)
395/10: print("Kayahan %.0f yarrak yedi " %100.2364)
395/11:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
395/12: secret_word= hangman_my_solution.initGame()
396/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
396/2:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
397/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
398/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
398/2: secret_word= hangman_my_solution.initGame()
399/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
399/2: secret_word= hangman_my_solution.initGame()
400/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
400/2: secret_word= hangman_my_solution.initGame()
401/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
401/2: secret_word= hangman_my_solution.initGame()
402/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
402/2: secret_word= hangman_my_solution.initGame()
403/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
403/2: secret_word= hangman_my_solution.initGame()
404/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
404/2: secret_word= hangman_my_solution.initGame()
405/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
405/2: secret_word= hangman_my_solution.initGame()
406/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
406/2: secret_word= hangman_my_solution.initGame()
407/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
407/2: secret_word= hangman_my_solution.initGame()
409/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
409/2: secret_word= hangman_my_solution.initGame()
410/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
410/2: secret_word= hangman_my_solution.initGame()
411/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
411/2: secret_word= hangman_my_solution.initGame()
412/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
412/2: secret_word= hangman_my_solution.initGame()
413/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
413/2: secret_word= hangman_my_solution.initGame()
414/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
414/2: secret_word= hangman_my_solution.initGame()
415/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
415/2: secret_word= hangman_my_solution.initGame()
416/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
416/2: secret_word= hangman_my_solution.initGame()
417/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
417/2: secret_word= hangman_my_solution.initGame()
418/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
418/2: secret_word= hangman_my_solution.initGame()
419/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
419/2: secret_word= hangman_my_solution.initGame()
420/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
420/2: secret_word= hangman_my_solution.initGame()
420/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
420/4: secret_word= hangman_my_solution.initGame()
421/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
421/2: secret_word= hangman_my_solution.initGame()
422/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
422/2: secret_word= hangman_my_solution.initGame()
422/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
422/4: secret_word= hangman_my_solution.initGame()
424/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
424/2: secret_word= hangman_my_solution.initGame()
424/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
424/4: secret_word= hangman_my_solution.initGame()
425/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
425/2: secret_word= hangman_my_solution.initGame()
426/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
426/2: secret_word= hangman_my_solution.initGame()
426/3: secret_word
427/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
427/2: hangman_my_solution.initGame()
428/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
428/2: hangman_my_solution.initGame()
429/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
429/2: hangman_my_solution.initGame()
430/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
430/2: hangman_my_solution.initGame()
431/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
431/2: hangman_my_solution.initGame()
432/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
432/2: hangman_my_solution.initGame()
432/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
432/4: hangman_my_solution.initGame()
433/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
433/2: hangman_my_solution.initGame()
434/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
434/2: hangman_my_solution.initGame()
434/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
434/4: hangman_my_solution.initGame()
434/5:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
434/6: hangman_my_solution.initGame()
435/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
435/2: hangman_my_solution.initGame()
435/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
435/4: hangman_my_solution.initGame()
435/5:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
435/6: hangman_my_solution.initGame()
436/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
436/2: hangman_my_solution.initGame()
437/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
437/2: hangman_my_solution.initGame()
437/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
437/4: hangman_my_solution.initGame()
438/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
438/2: hangman_my_solution.initGame()
439/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
439/2: hangman_my_solution.initGame()
440/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
440/2: hangman_my_solution.initGame()
441/1: secret_word = "tarantula"
441/2: secret_word.split("")
441/3: secret_word = "tarantula"
441/4:
secret_word_letters = []

for letter in secret_word:
    secret_word_letters.append(letter)
441/5: secret_word_letters
441/6:
guesses = ["a","r"]
display = "_ara____a"
441/7:
    my_file = open(words, "r")

    #split the words in the text file by whitespace
    for words in my_file:
        word_list = words.split(" ")
441/8:
my_file = open(words, "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
441/9:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
441/10: word_list
441/11: len(secret_word)
441/12: len(secret_word)
441/13:
len(secret_word)

def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words
441/14: getSameLengthWords(secret_word)
441/15: same_length_words = getSameLengthWords(secret_word)
441/16:

for word in same_length_words:
    for letter_word, letter_secret_word in word, secret_word:
        i = 0
        
        print(letter_word, letter_secret)
        if i == 2:
            break
        
        i +=1
441/17:

for word in same_length_words:
    for letter_word, letter_secret_word in zip(word, secret_word):
        i = 0
        
        print(letter_word, letter_secret)
        if i == 2:
            break
        
        i +=1
441/18:

for word in same_length_words:
    for letter_word, letter_secret_word in zip(word, secret_word):
        i = 0
        
        print(letter_word, letter_secret_word)
        if i == 2:
            break
        
        i +=1
441/19:

for word in same_length_words:
    for letter_word, letter_secret_word in zip(word, secret_word):
        i = 0
        
        print(letter_word, letter_secret_word)
        if i == 2:
            break
441/20:
same_length_words = getSameLengthWords(secret_word)
same_length_words
441/21: display
441/22:
letter_index = {}

for i, letter in enumerate(display):
    letter_index[i] = display
441/23: letter_index
441/24:
for letter in display:
    print(letter)
441/25:
letter_index = {}

for i, letter in enumerate(display):
    letter_index[i] = letter
441/26: letter_index
441/27:
letter_index = {}

for i, letter in enumerate(display):
    if letter != "_"
        letter_index[i] = letter
441/28:
letter_index = {}

for i, letter in enumerate(display):
    if letter != "_":
        letter_index[i] = letter
441/29: letter_index
441/30:
letter_index_obj = {}

for i, letter in enumerate(secret_word):
    letter_index_obj[i] = letter
441/31: letter_index_obj
441/32: letter_index in letter_index_obj
441/33: letter_index.values in letter_index_obj.values
441/34: letter_index.values() in letter_index_obj.values()
441/35: letter_index.keys() in letter_index_obj.keys()
441/36: all(item in letter_index_obj.items() for item in letter_index.items())
441/37:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
441/38:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter
441/39:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter
441/40:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
441/41: matching_words
442/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
442/2: hangman_my_solution.initGame()
443/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
443/2: hangman_my_solution.initGame()
444/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
444/2: hangman_my_solution.initGame()
445/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
445/2: hangman_my_solution.initGame()
446/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
446/2: hangman_my_solution.initGame()
447/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
447/2: hangman_my_solution.initGame()
448/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
448/2: hangman_my_solution.initGame()
449/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
449/2: hangman_my_solution.initGame()
450/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
450/2: hangman_my_solution.initGame()
451/1: secret_word = "tarantula"
451/2:
secret_word_letters = []

for letter in secret_word:
    secret_word_letters.append(letter)
451/3: secret_word_letters
451/4:
guesses = ["a","r"]
display = "_ara____a"
451/5:
    for letter in secret_word:
        if letter not in letters_guessed:
            word_to_display.append("_")
        else:
            word_to_display.append(letter)
451/6:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
451/7: word_list
451/8: len(secret_word)
451/9: len(secret_word)
451/10:
same_length_words = getSameLengthWords(secret_word)
same_length_words
451/11:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
451/12:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter
451/13:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
word_to_display_dict
451/14:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
451/15:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
451/16: matching_words
452/1: secret_word = "tarantula"
452/2:
guesses = ["a","r"]
display = "_ara____a"
452/3:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
452/4:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
452/5:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
452/6:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
452/7: matching_words
453/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
453/2: hangman_my_solution.initGame()
454/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
454/2: hangman_my_solution.initGame()
455/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
455/2: hangman_my_solution.initGame()
455/3: secret_word = "cordial"
455/4:
guesses = ["a","r"]
display = "____i__"
455/5:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
455/6:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
455/7:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
455/8:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
455/9: matching_words
456/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
456/2: hangman_my_solution.initGame()
457/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
457/2: hangman_my_solution.initGame()
459/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
459/2: hangman_my_solution.initGame()
460/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
460/2: hangman_my_solution.initGame()
461/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
461/2: hangman_my_solution.initGame()
462/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
462/2: hangman_my_solution.initGame()
463/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
463/2: hangman_my_solution.initGame()
463/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
463/4: hangman_my_solution.initGame()
464/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
464/2: hangman_my_solution.initGame()
465/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
465/2: hangman_my_solution.initGame()
466/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
466/2: hangman_my_solution.initGame()
467/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
467/2: hangman_my_solution.initGame()
468/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
468/2: hangman_my_solution.initGame()
469/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
469/2: hangman_my_solution.initGame()
469/3: secret_word = "cahoots"
469/4:
guesses = ["a","r"]
display = "ca___t_"
469/5:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
469/6:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
469/7:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
469/8:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
469/9: matching_words
470/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
470/2: hangman_my_solution.initGame()
471/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
471/2: hangman_my_solution.initGame()
473/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
473/2: hangman_my_solution.initGame()
474/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
474/2: hangman_my_solution.initGame()
475/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
475/2: hangman_my_solution.initGame()
477/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
477/2: hangman_my_solution.initGame()
478/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
478/2: hangman_my_solution.initGame()
479/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
479/2: hangman_my_solution.initGame()
480/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
480/2: hangman_my_solution.initGame()
481/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
481/2: hangman_my_solution.initGame()
482/1: secret_word = "cahoots"
482/2:
guesses = ["a","r"]
display = "ca___t_"
482/3:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
482/4:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
482/5:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
482/6:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
482/7: matching_words
482/8:
guesses = ["a","r", ]
display = "ca___t_"
482/9: word_to_display_dict
482/10: word_to_display_dict.values()
482/11: list(word_to_display_dict.values())
482/12: matching_guesses = list(word_to_display_dict.values())
482/13: list(guesses - matching_guesses)
482/14: list(set(matching_guesses) - set(guesses))
482/15: matching_guesses = list(word_to_display_dict.values())
482/16: guesses = ["c","a", "t", r"]
482/17: list(set(matching_guesses) - set(guesses))
482/18: matching_guesses = list(word_to_display_dict.values())
482/19: guesses = ["c","a", "t", "r"]
482/20: list(set(matching_guesses) - set(guesses))
482/21: matching_guesses = list(word_to_display_dict.values())
482/22: guesses = ["c","a", "t", "r"]
482/23: list(set(guesses) - set(matching_guesses))
482/24:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()) and diff not in word:
        matching_words.append(word)
482/25: diff = list(set(guesses) - set(matching_guesses))
482/26:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()) and diff not in word:
        matching_words.append(word)
482/27: matching_words
482/28:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
482/29: matching_words
482/30: matching_guesses = list(word_to_display_dict.values())
482/31: guesses = ["c","a", "t", "r"]
482/32: diff = list(set(guesses) - set(matching_guesses))
482/33:
diff = list(set(guesses) - set(matching_guesses))
diff
482/34: diff in "cahoots"
482/35: check_list = [guess in "cahoots" for guess in guesses]
482/36: check_list
482/37: check_list = [guess in "cahoots" for guess in diff]
482/38: check_list
482/39: check_list = [guess in "carrots" for guess in diff]
482/40: check_list
482/41: guesses = ["c","a", "t", "r", "g"]
482/42:
diff = list(set(guesses) - set(matching_guesses))
diff
482/43: check_list = [guess in "carrots" for guess in diff]
482/44: check_list
482/45: sum(check_list)
483/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
483/2: hangman_my_solution.initGame()
484/1: secret_word = "cahoots"
484/2:
guesses = ["a","r", "z"]
display = "ca___t_"
484/3:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
484/4:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
484/5:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
484/6:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
484/7: matching_words
484/8: secret_word = "cahoots"
484/9:
guesses = ["a","r", "z"]
display = "ca___t_"
484/10:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
484/11:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
484/12:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
484/13:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
484/14: matching_words
484/15: matching_guesses = list(word_to_display_dict.values())
484/16: guesses = ["c","a", "t", "r", "g"]
484/17:
diff = list(set(guesses) - set(matching_guesses))
diff
484/18: check_list = [guess in "carrots" for guess in diff]
484/19: sum(check_list)
484/20:
matching_guesses = list(word_to_display_dict.values())
matching_guesses
484/21:
matching_guesses = list(word_to_display_dict.values())
matching_guesses
484/22: guesses = ["c","a", "t", "r", "g"]
484/23:
diff = list(set(guesses) - set(matching_guesses))
diff
484/24: check_list
485/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
485/2: hangman_my_solution.initGame()
486/1: secret_word = "teared"
486/2:
guesses = ["a","r", "z"]
display = "t_ar__"
486/3:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
486/4:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
486/5:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
486/6:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
486/7:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
486/8: matching_words
486/9:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
486/10: hangman_my_solution.initGame()
487/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
487/2: hangman_my_solution.initGame()
488/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
488/2: hangman_my_solution.initGame()
489/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
489/2: hangman_my_solution.initGame()
489/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
489/4: hangman_my_solution.initGame()
490/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
490/2: hangman_my_solution.initGame()
490/3: secret_word = "disbelieve"
490/4:
guesses = ["a","r", "z"]
display = "____e__e_e"
490/5:
my_file = open("words.txt", "r")

#split the words in the text file by whitespace
for words in my_file:
    word_list = words.split(" ")
490/6:
def getSameLengthWords(secret_word):
    
    same_length_words = []
    for word in word_list:
        if len(word) == len(secret_word):
            same_length_words.append(word)
            
    return same_length_words

same_length_words = getSameLengthWords(secret_word)
same_length_words
490/7:
word_to_display_dict = {}

for i, letter in enumerate(display):
    if letter != "_":
        word_to_display_dict[i] = letter 
        
word_to_display_dict
490/8:
matching_words = []
possible_words_dict = {}

for word in same_length_words:
    for i, letter in enumerate(word):
        possible_words_dict[i] = letter
    
    if all(item in possible_words_dict.items() for item in word_to_display_dict.items()):
        matching_words.append(word)
490/9: matching_words
490/10:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
490/11: hangman_my_solution.initGame()
491/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
491/2: hangman_my_solution.initGame()
493/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
493/2: hangman_my_solution.initGame()
493/3: hangman_my_solution.initGame()
494/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
494/2: hangman_my_solution.initGame()
494/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
494/4: hangman_my_solution.initGame()
495/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
495/2: hangman_my_solution.initGame()
496/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
496/2: hangman_my_solution.initGame()
496/3: hangman_my_solution.initGame()
497/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
497/2: hangman_my_solution.initGame()
502/1: from blackjack import *
502/2: player = start_game()
503/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
503/2: import re
503/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
498/1: import requests
503/4:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
503/5:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
503/6:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
503/7: login = Login(driver, data)
503/8: login.login()
503/9: fb = Facebook(driver)
503/10: fb.search_user('Mustafa Cagri Ardic')
503/11: fb.search_user('Mustafa Cagri Ardic')
503/12: hakkinda_information = fb.getHakkinda()
503/13: hakkinda_information
503/14: fb = Facebook(driver)
503/15: fb.search_user('Matteo L. Serafino')
503/16: fb.search_user('Matteo L. Serafino')
503/17: hakkinda_information = fb.getHakkinda()
503/18: hakkinda_information
504/1: import requests
504/2:
url = r"https://www.proactiveinvestors.co.uk/finance"

requests.get(url)
504/3:
url = r"https://www.proactiveinvestors.co.uk/finance"

requests.get(url).content
504/4:
url = r"https://www.proactiveinvestors.co.uk/finance"

page  =requests.get(url).text
504/5:
url = r"https://www.proactiveinvestors.co.uk/finance"

page = requests.get(url).text
soup_expatistan = BeautifulSoup(page)
504/6:
import requests
from bs4 import BeautifulSoup
504/7:
url = r"https://www.proactiveinvestors.co.uk/finance"

page = requests.get(url).text
soup_expatistan = BeautifulSoup(page)
504/8: soup_expatistan
504/9:
url = r"https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194"

page = requests.get(url).text
soup_expatistan = BeautifulSoup(page)
504/10: soup_expatistan
504/11: soup_expatistan("ul", class_ ="pagination")
504/12: page_numbers_container = soup_expatistan("ul", class_ ="pagination")
504/13: page_numbers_container
504/14: page_numbers_container.find_all("li", class_ = prev disabled )
504/15: page_numbers_container.find_all("li", class_ = "prev disabled")
504/16: page_numbers_container = soup_expatistan("li", class_ ="prev disabled")
504/17: page_numbers_container
504/18: page_numbers_container = soup_expatistan.find_all("li", class_ ="pagination")
504/19: page_numbers_container
504/20: page_numbers_container = soup_expatistan.find("li", class_ ="pagination")
504/21: page_numbers_container = soup_expatistan.find("ul", class_ ="pagination")
504/22: page_numbers_container
504/23: page_numbers_container.find
504/24: page_numbers_container.find("li")
504/25: page_numbers_container
504/26: page_numbers_container.find_all("li")
504/27: page_numbers_container.find_all("li").find_all("a")
504/28: page_numbers_container.find_all("li")
504/29: tyoe(page_numbers_container.find_all("li"))
504/30: type(page_numbers_container.find_all("li"))
504/31: page_numbers_container.find_all("li")
504/32: page_numbers_container.find_all("li")[0]
504/33: page_numbers_container.find_all("li")
504/34: page_numbers_container.find_all("li").find("a")
504/35: page_numbers_container.find_all("li")
504/36: page_number_list = page_numbers_container.find_all("li")
504/37: page_number_list
504/38:
def filter_page(page_number_list):
    
    page_to_append = []
    for elements in page_number_list:
        if "page" in elements:
            page_to_append.append(elements)
            
    return page_to_append
504/39: filter_page(page_number_list)
504/40:
def filter_page(page_number_list):
    
    page_to_append = []
    for elements in page_number_list:
        print(elements)
        if "page" in elements:
            page_to_append.append(elements)
            
    return page_to_append
504/41: filter_page(page_number_list)
504/42: elements
504/43: page_number_list[3]
504/44: "page" in page_number_list[3]
504/45: page_number_list[3]
504/46: str(page_number_list[3])
504/47: "page" in str(page_number_list[3])
504/48:
def filter_page(page_number_list):
    
    page_to_append = []
    for elements in page_number_list:
        print(elements)
        if "page" in str(elements):
            page_to_append.append(elements)
            
    return page_to_append
504/49: filter_page(page_number_list)
504/50: "page" in str(page_number_list[3])
504/51:
def filter_page(page_number_list):
    
    page_to_append = []
    for elements in page_number_list:
#         print(elements)
        if "page" in str(elements):
            page_to_append.append(elements)
            
    return page_to_append
504/52: filter_page(page_number_list)
504/53: for element in page_number_list:
504/54:
for element in page_number_list:
    element.text()
504/55:
for element in page_number_list:
    element.text
504/56:
for element in page_number_list:
    print(element.text)
504/57:
for pages in page_number_list:
    print(pages.text)
504/58:
pages_list = []

for pages in page_number_list:
    pages
504/59:
pages_list = []

for pages in page_number_list:
    pages_list.append(pages)
504/60: pages_list
504/61: pages_list
504/62:
pages_list = []

for pages in page_number_list:
    pages_list.append(pages.text)
504/63: pages_list
504/64: pages_list.remove("")
504/65:
pages_list.remove("")
pages_list
504/66:
pages_list = []

for pages in page_number_list:
    pages_list.append(pages.text)
    print("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:{}".format(pages.text))
504/67:
pages_list = []

for pages in page_number_list:
    pages_list.append(pages.text)
504/68:
pages_list = []

for pages in page_number_list:
    pages_list.append(pages.text)
    
pages_list.remove("")
pages_list
504/69:
for page_numbers in pages_list:
        print("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:{}".format(page_numbers.text))
504/70:
for page_numbers in pages_list:
        print("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:{}".format(page_numbers))
504/71:
pages_list = []

for pages in page_number_list:
    pages_list.append(pages.text)
504/72:
while '' in pages_list:
    pages_list.remove('')
504/73:
while '' in pages_list:
    pages_list.remove('')
    
pages_list
504/74:
for page_numbers in pages_list:
        print("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:{}".format(page_numbers))
504/75: requests.get("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:2")
504/76:
page_2 = requests.get("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:2")
soup_expatistan_2 = BeautifulSoup(page_2)
504/77:
page_2 = requests.get("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:2")
# soup_expatistan_2 = BeautifulSoup(page_2)
504/78: page_2
504/79:
page_2 = requests.get("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:2").text
# soup_expatistan_2 = BeautifulSoup(page_2)
504/80:
page_2 = requests.get("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:2").text
soup_expatistan_2 = BeautifulSoup(page_2)
504/81: soup_expatistan_2
504/82: soup_expatistan_2.find("div", class_ = "col-md-9 col-lg-10")
504/83: soup_expatistan_2.find("div", class_ = "col-md-9 col-lg-10").div
504/84: soup_expatistan_2.find("div", class_ = "col-md-9 col-lg-10").div.div
504/85: soup_expatistan_2.find("div", class_ = "col-md-9 col-lg-10").div
504/86: list_news = soup_expatistan_2.find("div", class_ = "col-md-9 col-lg-10").div
504/87: list_news
504/88: list_news.find("a", class_ = "col-md-7")
504/89: list_news.find("div", class_ = "col-md-7")
504/90: list_news.find("div", class_ = "col-md-7").a
504/91: list_news.find("div", class_ = "col-md-7").a("href")
504/92: list_news.find("div", class_ = "col-md-7").a
504/93: list_news.find("div", class_ = "col-md-7").a
504/94: list_news.find("div", class_ = "col-md-7")
504/95: list_news_1 = list_news.find("div", class_ = "col-md-7")
504/96: list_news_1attrs={"name" : "stainfo"}
504/97: list_news_1
504/98: list_news_1.a
504/99: list_news_1.a["href"]
504/100:
page_2 = requests.get("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:5").text
soup_expatistan_2 = BeautifulSoup(page_2)
504/101: list_news = soup_expatistan_2.find("div", class_ = "col-md-9 col-lg-10").div
504/102: list_news_1 = list_news.find("div", class_ = "col-md-7")
504/103: list_news_1.a["href"]
504/104:
page_2 = requests.get("https://www.proactiveinvestors.co.uk/archives/niche/sectors/Finance/194/page:2").text
soup_expatistan_2 = BeautifulSoup(page_2)
504/105: list_news = soup_expatistan_2.find("div", class_ = "col-md-9 col-lg-10").div
504/106: list_news_1 = list_news.find("div", class_ = "col-md-7")
504/107: list_news_1.a["href"]
505/1: from job_application_interface import *
505/2: import Tkinter
505/3: import Tkinter as tk
505/4: import tkinter as tk
505/5: top = Tkinter.Tk()
505/6: top = tkinter.Tk()
505/7: top = tk.Tk()
505/8: top
505/9: top.mainloop()
505/10:
top = tk.Tk()
txt = Entry(window,width=10)
505/11: top
505/12:
top = tk.Tk()
txt = entry(window,width=10)
505/13:
top = tk.Tk()
txt = top.entry(window,width=10)
505/14: top
505/15:
window = Tk()
window.title("Welcome to LikeGeeks app")
window.geometry('350x200')
lbl = Label(window, text="Hello")
lbl.grid(column=0, row=0)
txt = Entry(window,width=10)
txt.grid(column=1, row=0)
505/16: from tkinter import *
505/17:
window = Tk()
window.title("Welcome to LikeGeeks app")
window.geometry('350x200')
lbl = Label(window, text="Hello")
lbl.grid(column=0, row=0)
txt = Entry(window,width=10)
txt.grid(column=1, row=0)
506/1: from job_application_interface import *
508/1: from job_application_interface import *
509/1: from job_application_interface import *
509/2: from job_application_interface import *
510/1: from job_application_interface import *
510/2: from job_application_interface import *
511/1: from job_application_interface import *
512/1: from job_application_interface import *
513/1: from job_application_interface import *
514/1: from job_application_interface import *
515/1: from job_application_interface import JobApplicationApp
515/2: app = JobApplicationApp()
516/1: from job_application_interface import JobApplicationApp
516/2: app = JobApplicationApp()
517/1: from job_application_interface import JobApplicationApp
517/2: app = JobApplicationApp()
517/3: app.mainloop()
518/1: from job_application_interface import JobApplicationApp
518/2: app = JobApplicationApp()
519/1: from job_application_interface import JobApplicationApp
519/2: app = JobApplicationApp()
519/3: app.mainloop()
519/4: app.window.mainloop()
520/1: from job_application_interface import JobApplicationApp
521/1: from job_application_interface import JobApplicationApp
521/2: app = JobApplicationApp()
522/1: from job_application_interface import JobApplicationApp
523/1: from job_application_interface import JobApplicationApp
523/2: app = JobApplicationApp()
523/3: app.getWindowName()
524/1: from job_application_interface import JobApplicationApp
524/2: app = JobApplicationApp()
524/3: app.runApp()
525/1: from job_application_interface import JobApplicationApp
525/2: app = JobApplicationApp()
525/3: app.runApp()
526/1: from job_application_interface import JobApplicationApp
526/2: app = JobApplicationApp()
526/3: app.runApp()
527/1: from job_application_interface import JobApplicationApp
527/2: app = JobApplicationApp()
527/3: app.runApp()
527/4: app.runApp()
528/1: from job_application_interface import JobApplicationApp
528/2: app = JobApplicationApp()
528/3: app.runApp()
529/1: from job_application_interface import JobApplicationApp
529/2: app = JobApplicationApp()
529/3: app.runApp()
530/1: from job_application_interface import JobApplicationApp
530/2: app = JobApplicationApp()
530/3: app.runApp()
531/1: from job_application_interface import JobApplicationApp
531/2: app = JobApplicationApp()
531/3: app.runApp()
532/1: from job_application_interface import JobApplicationApp
532/2: app = JobApplicationApp()
532/3: app.runApp()
533/1: from job_application_interface import JobApplicationApp
533/2: app = JobApplicationApp()
533/3: app.runApp()
534/1: from job_application_interface import JobApplicationApp
534/2: app = JobApplicationApp()
534/3: app.runApp()
534/4: from job_application_interface import JobApplicationApp
534/5: app = JobApplicationApp()
534/6: app.runApp()
535/1: from job_application_interface import JobApplicationApp
535/2: app = JobApplicationApp()
535/3: app.runApp()
536/1: from job_application_interface import JobApplicationApp
536/2: app = JobApplicationApp()
536/3: app.runApp()
537/1: from job_application_interface import JobApplicationApp
537/2: app = JobApplicationApp()
537/3: app.runApp()
538/1: from job_application_interface import JobApplicationApp
538/2: app = JobApplicationApp()
538/3: app.runApp()
539/1: from job_application_interface import JobApplicationApp
539/2: app = JobApplicationApp()
539/3: app.runApp()
540/1: from job_application_interface import JobApplicationApp
540/2: app = JobApplicationApp()
540/3: app.runApp()
541/1: from job_application_interface import JobApplicationApp
541/2: app = JobApplicationApp()
541/3: app.runApp()
542/1: from job_application_interface import JobApplicationApp
542/2: app = JobApplicationApp()
542/3: app.runApp()
543/1: from job_application_interface import JobApplicationApp
543/2: app = JobApplicationApp()
543/3: from job_application_interface import JobApplicationApp
543/4: app = JobApplicationApp()
543/5: app.runApp()
544/1: from job_application_interface import JobApplicationApp
544/2: app = JobApplicationApp()
544/3: app.runApp()
545/1: from job_application_interface import JobApplicationApp
545/2: app = JobApplicationApp()
545/3: app.runApp()
546/1: from job_application_interface import JobApplicationApp
546/2: app = JobApplicationApp()
546/3: app.runApp()
547/1: from job_application_interface import JobApplicationApp
547/2: app = JobApplicationApp()
547/3: app.runApp()
548/1: from job_application_interface import JobApplicationApp
548/2: app = JobApplicationApp()
548/3: app.runApp()
549/1: from job_application_interface import JobApplicationApp
549/2: app = JobApplicationApp()
549/3: app.runApp()
550/1: from job_application_interface import JobApplicationApp
550/2: app = JobApplicationApp()
550/3: app.runApp()
551/1: from job_application_interface import JobApplicationApp
551/2: app = JobApplicationApp()
551/3: app.runApp()
552/1: from job_application_interface import JobApplicationApp
552/2: app = JobApplicationApp()
552/3: app.runApp()
553/1: from job_application_interface import JobApplicationApp
553/2: app = JobApplicationApp()
553/3: app.runApp()
554/1: from job_application_interface import JobApplicationApp
554/2: app = JobApplicationApp()
554/3: app.runApp()
555/1: from job_application_interface import JobApplicationApp
555/2: app = JobApplicationApp()
555/3: app.runApp()
556/1: from job_application_interface import JobApplicationApp
556/2: app = JobApplicationApp()
556/3: app.runApp()
557/1: from job_application_interface import JobApplicationApp
557/2: app = JobApplicationApp()
557/3: app.runApp()
558/1: from job_application_interface import JobApplicationApp
558/2: app = JobApplicationApp()
558/3: app.runApp()
559/1: from job_application_interface import JobApplicationApp
559/2: app = JobApplicationApp()
559/3: app.runApp()
560/1: from job_application_interface import JobApplicationApp
560/2: app = JobApplicationApp()
560/3: app.runApp()
561/1: from job_application_interface import JobApplicationApp
561/2: app = JobApplicationApp()
561/3: app.runApp()
562/1: from job_application_interface import JobApplicationApp
562/2: app = JobApplicationApp()
562/3: app.runApp()
563/1: from job_application_interface import JobApplicationApp
563/2: app = JobApplicationApp()
563/3: from job_application_interface import JobApplicationApp
563/4: app = JobApplicationApp()
563/5: app.runApp()
564/1: from job_application_interface import JobApplicationApp
564/2: app = JobApplicationApp()
564/3: app.runApp()
565/1: from job_application_interface import JobApplicationApp
565/2: app = JobApplicationApp()
565/3: app.runApp()
566/1: from job_application_interface import JobApplicationApp
566/2: app = JobApplicationApp()
566/3: app.runApp()
567/1: from job_application_interface import JobApplicationApp
567/2: app = JobApplicationApp()
567/3: app.runApp()
568/1: from job_application_interface import JobApplicationApp
568/2: app = JobApplicationApp()
568/3: app.runApp()
569/1: from job_application_interface import JobApplicationApp
569/2: app = JobApplicationApp()
569/3: app.runApp()
570/1: from job_application_interface import JobApplicationApp
570/2: app = JobApplicationApp()
570/3: app.runApp()
571/1: from job_application_interface import JobApplicationApp
571/2: app = JobApplicationApp()
571/3: app.runApp()
572/1: from job_application_interface import JobApplicationApp
572/2: app = JobApplicationApp()
572/3: app.runApp()
573/1: from job_application_interface import JobApplicationApp
573/2: app = JobApplicationApp()
573/3: app.runApp()
574/1: from job_application_interface import JobApplicationApp
574/2: app = JobApplicationApp()
574/3: app.runApp()
575/1: from job_application_interface import JobApplicationApp
575/2: app = JobApplicationApp()
575/3: app.runApp()
577/1: from job_application_interface import JobApplicationApp
577/2: app = JobApplicationApp()
577/3: app.runApp()
579/1: from job_application_interface import JobApplicationApp
579/2: app = JobApplicationApp()
579/3: app.runApp()
580/1: from job_application_interface import JobApplicationApp
580/2: app = JobApplicationApp()
580/3: app.runApp()
581/1: from job_application_interface import JobApplicationApp
581/2: app = JobApplicationApp()
581/3: app.runApp()
582/1: from job_application_interface import JobApplicationApp
582/2: app = JobApplicationApp()
582/3: app.runApp()
583/1:
from tkinter import *

#***********************************
#Creates an instance of the class tkinter.Tk.
#This creates what is called the "root" window. By conventon,
#the root window in Tkinter is usually called "root",
#but you are free to call it by any other name.

root = Tk()
root.title('how to get text from textbox')


#**********************************
mystring = StringVar()

####define the function that the signup button will do
def getvalue():
    print(mystring.get())
#*************************************

Label(root, text="Text to get").grid(row=0, sticky=W)  #label
Entry(root, textvariable = mystring).grid(row=0, column=1, sticky=E) #entry textbox

WSignUp = Button(root, text="print text", command=getvalue).grid(row=3, column=0, sticky=W) #button
583/2: root.mainloop()
584/1: from job_application_interface import JobApplicationApp
584/2: app = JobApplicationApp()
584/3: app.runApp()
585/1: from job_application_interface import JobApplicationApp
585/2: app = JobApplicationApp()
586/1: from job_application_interface import JobApplicationApp
586/2: app = JobApplicationApp()
586/3: app.runApp()
587/1: from job_application_interface import JobApplicationApp
587/2: app = JobApplicationApp()
587/3: app.runApp()
588/1: from job_application_interface import JobApplicationApp
588/2: app = JobApplicationApp()
588/3: app.runApp()
589/1: from job_application_interface import JobApplicationApp
589/2: app = JobApplicationApp()
589/3: app.runApp()
590/1: from job_application_interface import JobApplicationApp
590/2: app = JobApplicationApp()
590/3: app.runApp()
591/1: from job_application_interface import JobApplicationApp
591/2: app = JobApplicationApp()
591/3: app.runApp()
591/4:
from pathlib import Path

my_file = "C:\Users\Cagri\Google Drive\applications_.csv"
my_file = Path(my_file)
591/5:
from pathlib import Path

my_file = r"C:\Users\Cagri\Google Drive\applications_.csv"
my_file = Path(my_file)
591/6:
from pathlib import Path

my_file = r"C:\Users\Cagri\Google Drive\applications_.csv"
my_file = Path(r"C:\Users\Cagri\Google Drive")
591/7:
from pathlib import Path

file_path = r"C:\Users\Cagri\Google Drive\applications_.csv"
my_file = Path(file_path)
591/8:
if my_file.is_file():
    print("YES")
591/9:
from pathlib import Path

file_path = r"C:\Users\Cagri\Google Drive\applications_.csv"
my_file = Path(file_path)
591/10:
if my_file.is_file():
    print("YES")
592/1: from job_application_interface import JobApplicationApp
592/2: app = JobApplicationApp()
592/3: app.runApp()
593/1: from job_application_interface import JobApplicationApp
593/2: app = JobApplicationApp()
593/3: app.runApp()
594/1: from job_application_interface import JobApplicationApp
594/2: app = JobApplicationApp()
594/3: app.runApp()
595/1: from job_application_interface import JobApplicationApp
595/2: app = JobApplicationApp()
595/3: app.runApp()
596/1: from job_application_interface import JobApplicationApp
596/2: app = JobApplicationApp()
596/3: app.runApp()
597/1: from job_application_interface import JobApplicationApp
597/2: app = JobApplicationApp()
597/3: app.runApp()
598/1: from job_application_interface import JobApplicationApp
598/2: app = JobApplicationApp()
598/3: app.runApp()
599/1: from job_application_interface import JobApplicationApp
599/2: app = JobApplicationApp()
599/3: app.runApp()
600/1: from job_application_interface import JobApplicationApp
600/2: app = JobApplicationApp()
600/3: app.runApp()
601/1: from job_application_interface import JobApplicationApp
601/2: app = JobApplicationApp()
601/3: app.runApp()
602/1: from job_application_interface import JobApplicationApp
602/2: app = JobApplicationApp()
602/3: app.runApp()
603/1: from job_application_interface import JobApplicationApp
603/2: app = JobApplicationApp()
603/3: app.runApp()
604/1: from job_application_interface import JobApplicationApp
604/2: app = JobApplicationApp()
604/3: app.runApp()
605/1: from job_application_interface import JobApplicationApp
605/2: app = JobApplicationApp()
605/3: app.runApp()
606/1: from job_application_interface import JobApplicationApp
606/2: app = JobApplicationApp()
606/3: app.runApp()
607/1: from job_application_interface import JobApplicationApp
607/2: app = JobApplicationApp()
608/1: from job_application_interface import JobApplicationApp
608/2: app = JobApplicationApp()
608/3: app.runApp()
609/1: from job_application_interface import JobApplicationApp
609/2: app = JobApplicationApp()
609/3: app.runApp()
610/1: from job_application_interface import JobApplicationApp
610/2: app = JobApplicationApp()
610/3: app.runApp()
612/1: from job_application_interface import JobApplicationApp
612/2: app = JobApplicationApp()
612/3: app.runApp()
613/1: from job_application_interface import JobApplicationApp
613/2: app = JobApplicationApp()
613/3: app.runApp()
614/1: from job_application_interface import JobApplicationApp
614/2: app = JobApplicationApp()
614/3: app.runApp()
615/1: from job_application_interface import JobApplicationApp
615/2: app = JobApplicationApp()
615/3: app.runApp()
616/1: from job_application_interface import JobApplicationApp
616/2: app = JobApplicationApp()
616/3: app.runApp()
617/1: from job_application_interface import JobApplicationApp
617/2: app = JobApplicationApp()
617/3: app.runApp()
618/1: from job_application_interface import JobApplicationApp
618/2: app = JobApplicationApp()
618/3: app.runApp()
619/1: from job_application_interface import JobApplicationApp
619/2: app = JobApplicationApp()
619/3: app.runApp()
620/1: from job_application_interface import JobApplicationApp
620/2: app = JobApplicationApp()
620/3: app.runApp()
621/1: from job_application_interface import JobApplicationApp
621/2: app = JobApplicationApp()
621/3: app.runApp()
622/1: from job_application_interface import JobApplicationApp
622/2: app = JobApplicationApp()
622/3: app.runApp()
623/1: from job_application_interface import JobApplicationApp
623/2: app = JobApplicationApp()
623/3: app.runApp()
624/1: from job_application_interface import JobApplicationApp
624/2: app = JobApplicationApp()
624/3: app.runApp()
625/1: from job_application_interface import JobApplicationApp
625/2: app = JobApplicationApp()
625/3: app.runApp()
626/1: from job_application_interface import JobApplicationApp
626/2: app = JobApplicationApp()
626/3: app.runApp()
626/4: from job_application_interface import JobApplicationApp
626/5: app = JobApplicationApp()
626/6: app.runApp()
627/1: from job_application_interface import JobApplicationApp
627/2: app = JobApplicationApp()
627/3: app.runApp()
630/1: from job_application_interface import JobApplicationApp
630/2: app = JobApplicationApp()
630/3: app.runApp()
630/4:
from tkinter import *

#***********************************
#Creates an instance of the class tkinter.Tk.
#This creates what is called the "root" window. By conventon,
#the root window in Tkinter is usually called "root",
#but you are free to call it by any other name.

root = Tk()
root.title('how to get text from textbox')


#**********************************
mystring = StringVar()

####define the function that the signup button will do
def getvalue():
    print(mystring.get())
#*************************************

Label(root, text="Text to get").grid(row=0, sticky=W)  #label
Entry(root, textvariable = mystring).grid(row=0, column=1, sticky=E) #entry textbox

WSignUp = Button(root, text="print text", command=getvalue).grid(row=3, column=0, sticky=W) #button
630/5: root.mainloop()
630/6:
from pathlib import Path

file_path = r"C:\Users\Cagri\Google Drive\applications_.csv"
my_file = Path(file_path)
630/7:
if my_file.is_file():
    print("YES")
631/1: from job_application_interface import JobApplicationApp
631/2: app = JobApplicationApp()
632/1: from job_application_interface import JobApplicationApp
633/1: from job_application_interface import JobApplicationApp
633/2: app = JobApplicationApp()
634/1: from job_application_interface import JobApplicationApp
634/2: app = JobApplicationApp()
634/3: app.runApp()
634/4:
from datetime import date
dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
print(dt_string)
634/5:
from datetime import date
now = datetime.now()
dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
print(dt_string)
634/6:
from datetime import datetime
now = datetime.now()
dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
print(dt_string)
635/1: from job_application_interface import JobApplicationApp
635/2: app = JobApplicationApp()
635/3: app.runApp()
636/1: from job_application_interface import JobApplicationApp
636/2: app = JobApplicationApp()
636/3: app.runApp()
637/1: from job_application_interface import JobApplicationApp
637/2: app = JobApplicationApp()
637/3: app.runApp()
638/1: from job_application_interface import JobApplicationApp
638/2: app = JobApplicationApp()
638/3: app.runApp()
639/1: from job_application_interface import JobApplicationApp
639/2: app = JobApplicationApp()
639/3: app.runApp()
640/1: from job_application_interface import JobApplicationApp
640/2: app = JobApplicationApp()
640/3: app.runApp()
641/1: from job_application_interface import JobApplicationApp
641/2: app = JobApplicationApp()
641/3: app.runApp()
642/1: from job_application_interface import JobApplicationApp
642/2: app = JobApplicationApp()
642/3: app.runApp()
643/1: from job_application_interface import JobApplicationApp
643/2: app = JobApplicationApp()
643/3: app.runApp()
644/1: from job_application_interface import JobApplicationApp
644/2: app = JobApplicationApp()
644/3: app.runApp()
645/1: from job_application_interface import JobApplicationApp
645/2: app = JobApplicationApp()
645/3: app.runApp()
646/1: from job_application_interface import JobApplicationApp
646/2: app = JobApplicationApp()
646/3: app.runApp()
647/1: app = JobApplicationApp()
647/2: from job_application_interface import JobApplicationApp
647/3: app = JobApplicationApp()
647/4: app.runApp()
648/1: from job_application_interface import JobApplicationApp
648/2: app = JobApplicationApp()
648/3: app.runApp()
649/1: from job_application_interface import JobApplicationApp
649/2: app = JobApplicationApp()
649/3: app.runApp()
650/1: from job_application_interface import JobApplicationApp
650/2: app = JobApplicationApp()
650/3: app.runApp()
652/1: from job_application_interface import JobApplicationApp
652/2: app = JobApplicationApp()
652/3: app.runApp()
653/1: from job_application_interface import JobApplicationApp
653/2: app = JobApplicationApp()
653/3: app.runApp()
654/1: from job_application_interface import JobApplicationApp
654/2: app = JobApplicationApp()
654/3: app.runApp()
655/1: from job_application_interface import JobApplicationApp
655/2: app = JobApplicationApp()
655/3: app.runApp()
656/1: from job_application_interface import JobApplicationApp
656/2: app = JobApplicationApp()
656/3: app.runApp()
657/1: from job_application_interface import JobApplicationApp
657/2: app = JobApplicationApp()
657/3: app.runApp()
658/1: from job_application_interface import JobApplicationApp
658/2: app = JobApplicationApp()
658/3: app.runApp()
659/1: from job_application_interface import JobApplicationApp
659/2: app = JobApplicationApp()
659/3: app.runApp()
660/1: from job_application_interface import JobApplicationApp
660/2: app = JobApplicationApp()
661/1: from job_application_interface import JobApplicationApp
661/2: app = JobApplicationApp()
661/3: app.runApp()
662/1: from job_application_interface import JobApplicationApp
662/2: app = JobApplicationApp()
662/3: app.runApp()
663/1: from job_application_interface import JobApplicationApp
663/2: app = JobApplicationApp()
663/3: app.runApp()
664/1: from job_application_interface import JobApplicationApp
664/2: app = JobApplicationApp()
664/3: app.runApp()
665/1: from job_application_interface import JobApplicationApp
665/2: app = JobApplicationApp()
665/3: app.runApp()
666/1: from job_application_interface import JobApplicationApp
666/2: app = JobApplicationApp()
666/3: app.runApp()
667/1: from job_application_interface import JobApplicationApp
667/2: app = JobApplicationApp()
667/3: app.runApp()
668/1: from job_application_interface import JobApplicationApp
668/2: app = JobApplicationApp()
668/3: app.runApp()
669/1: from job_application_interface import JobApplicationApp
669/2: app = JobApplicationApp()
669/3: app.runApp()
670/1: from job_application_interface import JobApplicationApp
670/2: app = JobApplicationApp()
670/3: app.runApp()
671/1: from job_application_interface import JobApplicationApp
671/2: app = JobApplicationApp()
671/3: app.runApp()
672/1: from job_application_interface import JobApplicationApp
672/2: app = JobApplicationApp()
672/3: app.runApp()
673/1: from job_application_interface import JobApplicationApp
673/2: app = JobApplicationApp()
673/3: app.runApp()
674/1: from job_application_interface import JobApplicationApp
674/2: app = JobApplicationApp()
674/3: app.runApp()
675/1: from job_application_interface import JobApplicationApp
675/2: app = JobApplicationApp()
675/3: app.runApp()
676/1: from job_application_interface import JobApplicationApp
676/2: app = JobApplicationApp()
676/3: app.runApp()
677/1: from job_application_interface import JobApplicationApp
677/2: app = JobApplicationApp()
677/3: app.runApp()
678/1: from job_application_interface import JobApplicationApp
678/2: app = JobApplicationApp()
678/3: app.runApp()
679/1: from job_application_interface import JobApplicationApp
679/2: app = JobApplicationApp()
679/3: app.runApp()
680/1: from job_application_interface import JobApplicationApp
680/2: app = JobApplicationApp()
680/3: app.runApp()
681/1: from job_application_interface import JobApplicationApp
681/2: app = JobApplicationApp()
681/3: app.runApp()
682/1: from job_application_interface import JobApplicationApp
682/2: app = JobApplicationApp()
682/3: app.runApp()
683/1: from job_application_interface import JobApplicationApp
683/2: app = JobApplicationApp()
683/3: app.runApp()
684/1: from job_application_interface import JobApplicationApp
684/2: app = JobApplicationApp()
684/3: app.runApp()
685/1: from job_application_interface import JobApplicationApp
685/2: app = JobApplicationApp()
685/3: app.runApp()
686/1: from job_application_interface import JobApplicationApp
686/2: app = JobApplicationApp()
686/3: app.runApp()
687/1: from job_application_interface import JobApplicationApp
687/2: app = JobApplicationApp()
687/3: app.runApp()
688/1: from job_application_interface import JobApplicationApp
688/2: app = JobApplicationApp()
688/3: app.runApp()
689/1: from job_application_interface import JobApplicationApp
689/2: app = JobApplicationApp()
689/3: app.runApp()
690/1: from job_application_interface import JobApplicationApp
690/2: app = JobApplicationApp()
690/3: app.runApp()
692/1: from job_application_interface import JobApplicationApp
692/2: app = JobApplicationApp()
692/3: app.runApp()
693/1: from job_application_interface import JobApplicationApp
693/2: app = JobApplicationApp()
693/3: app.runApp()
693/4:
from tkinter import *

class Window():

    def __init__(self, root):

        self.top = Label(root, text = "Test")
        self.top.pack()

        self.e = Entry(root)
        self.e.pack()
        self.e.focus_set()

        self.b = Button(root, text = "Enter", command = self.function)
        self.b.pack()

        self.answer = StringVar()
        self.answer.set("Enter answer")

        self.check = Label(root, text = self.answer.get(), textvariable = self.answer)
        self.check.pack()

    #Functions
    def function(self):

        data = self.e.get()

        if data == "5":
            self.answer.set("Correct")
        else:
            self.answer.set("Incorrect")

root = Tk()
w = Window(root)
693/5:
from tkinter import *

class Window():

    def __init__(self, root):

        self.top = Label(root, text = "Test")
        self.top.pack()

        self.e = Entry(root)
        self.e.pack()
        self.e.focus_set()

        self.b = Button(root, text = "Enter", command = self.function)
        self.b.pack()

        self.answer = StringVar()
        self.answer.set("Enter answer")

        self.check = Label(root, text = self.answer.get(), textvariable = self.answer)
        self.check.pack()

    #Functions
    def function(self):

        data = self.e.get()

        if data == "5":
            self.answer.set("Correct")
        else:
            self.answer.set("Incorrect")

root = Tk()
w = Window(root)
root.mainloop()
694/1: from job_application_interface import JobApplicationApp
694/2: app = JobApplicationApp()
694/3: app.runApp()
695/1: from job_application_interface import JobApplicationApp
695/2: app = JobApplicationApp()
695/3: app.runApp()
696/1: from job_application_interface import JobApplicationApp
696/2: app = JobApplicationApp()
696/3: app.runApp()
698/1: from job_application_interface import JobApplicationApp
698/2: app = JobApplicationApp()
698/3: app.runApp()
699/1: from job_application_interface import JobApplicationApp
699/2: app = JobApplicationApp()
699/3: app.runApp()
701/1: from job_application_interface import JobApplicationApp
701/2: app = JobApplicationApp()
701/3: app.runApp()
702/1: from job_application_interface import JobApplicationApp
702/2: app = JobApplicationApp()
702/3: app.runApp()
703/1: from job_application_interface import JobApplicationApp
703/2: app = JobApplicationApp()
703/3: app.runApp()
705/1: import requests
705/2:

requests.get()
705/3:
url = r"https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom"
requests.get()
705/4:
url = r"https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom"
requests.get(url)
705/5: soup = BeautifulSoup(r.content, "html.parser")
705/6:
import requests
from bs4 import BeautifulSoup
705/7:
url = r"https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom"
r = requests.get(url)
705/8: soup = BeautifulSoup(r.content, "html.parser")
705/9: soup
705/10: soup.find_all("ul", class_ = "jobs-search")
705/11: soup.find("ul", class_ = "jobs-search")
705/12: soup.find_all("ul", class_ = "jobs-search")
705/13: soup.find_all("ul")
705/14: soup.prettify
705/15: r.content
705/16: soup.find_all("ul", class_ ="jobs-search-results__list artdeco-list")
705/17: soup.find_all("ul", {"class": "jobs-search-results__list artdeco-list"} )
705/18: soup.find_all("div", {"class": "jobs-search-results__list artdeco-list"})
705/19: soup.find_all("div", {"class": "jobs-search-results jobs-search-results--is-two-pane"})
705/20: soup.find("div", {"class": "jobs-search-results jobs-search-results--is-two-pane"})
705/21: soup = BeautifulSoup(r.content, "html.parser")
705/22: soup
705/23: soup.prettify()
705/24: print(soup.prettify())
705/25: soup.find("div", {"class": "filter-list__list"})
705/26: soup.find("div", {"class": "filter-list__list"})
705/27:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
import json
import re
705/28:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
import json
import re
705/29:
def InitialiseLinkedin(url_to_launch):

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
        data = json.load(f)

        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", {
        "profile.default_content_setting_values.notifications": 1 })

        driver = webdriver.Chrome(options=option,
                                  executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\chromedriver.exe")

        driver.get(url_to_launch)

        return driver, data
705/30: InitialiseLinkedin(url_to_launch= r"www.linkedin.com")
705/31:
def InitialiseLinkedin(url_to_launch):

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
        data = json.load(f)

        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", {
        "profile.default_content_setting_values.notifications": 1 })

        driver = webdriver.Chrome(options=option,
                                  executable_path=r"\chromedriver.exe")

        driver.get(url_to_launch)

        return driver, data
705/32: InitialiseLinkedin(url_to_launch= r"www.linkedin.com")
705/33:
def InitialiseLinkedin(url_to_launch):

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Selenium Project\Keys.json") as f:
        data = json.load(f)

        option = Options()

        option.add_argument("--disable-infobars")
        option.add_argument("start-maximized")
        option.add_argument("--disable-extensions")

        # Pass the argument 1 to allow and 2 to block
        option.add_experimental_option("prefs", {
        "profile.default_content_setting_values.notifications": 1 })

        driver = webdriver.Chrome(options=option,
                                  executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

        driver.get(url_to_launch)

        return driver, data
705/34: InitialiseLinkedin(url_to_launch= r"www.linkedin.com")
705/35: InitialiseLinkedin(url_to_launch= "https://www.linkedin.com/")
705/36:
def InitialiseLinkedin(url_to_launch):

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data
705/37: InitialiseLinkedin(url_to_launch= "https://www.linkedin.com/")
705/38:
driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

def InitialiseLinkedin(url_to_launch):

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })    

    driver.get(url_to_launch)

    return driver, data
705/39: InitialiseLinkedin(url_to_launch= "https://www.linkedin.com/")
705/40:
def InitialiseLinkedin(url_to_launch):

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver
705/41: driver = InitialiseLinkedin(url_to_launch= "https://www.linkedin.com/")
705/42:
def InitialiseLinkedin(url_to_launch):

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver
705/43: driver = InitialiseLinkedin(url_to_launch = "https://www.linkedin.com/")
705/44: driver.find_element_by_xpath("/html/body/nav/a[3]")
705/45: driver.find_element_by_xpath("/html/body/nav/a[3]").click()
705/46: from job_application_filter import *
705/47:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
706/1: from job_application_filter import *
706/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
706/3: login.clickSignIn()
707/1: from job_application_filter import *
707/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
707/3: login.clickSignIn()
707/4: driver.find_element_by_tag_name("button")
707/5: driver.find_element_by_tag_name("button").text
708/1: from job_application_filter import *
708/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
708/3: login.clickSignIn()
709/1: from job_application_filter import *
709/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
709/3: login.SignIn()
709/4: driver.find_element_by_id("jobs-nav-item")
709/5: driver.find_element_by_id("jobs-nav-item").click()
709/6: driver.find_element_by_tag("span")
709/7: driver.find_element_by_tag_name("span")
709/8: driver.find_element_by_tag_name("span").text
709/9: driver.find_element_by_class_name("flex-1 overflow-hidden").text
709/10: driver.find_element_by_class_name("flex-1 overflow-hidden")
709/11: driver.find_element_by_class_name("flex-1")
709/12: driver.find_element_by_class_name("flex-1").text
709/13: driver.find_element_by_class_name("peek-carousel__slides").text
709/14: driver.find_element_by_class_name("peek-carousel__slides")
709/15: driver.page_source
709/16: html = driver.page_source
709/17: soup = BeautifulSoup(html)
709/18:
from bs4 import BeautifulSoup
soup = BeautifulSoup(html)
709/19: soup
709/20: soup.find_all("ul", {"class":"peak-carousel"})
709/21: soup.find_all("ul", {"class":"peek-carousel__slides"})
709/22: driver.find_element_by_class_name("flex-1")
709/23: driver.find_element_by_class_name("flex-1").click()
710/1: from job_application_filter import *
710/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
711/1: from job_application_filter import *
711/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
711/3: login.SignIn()
711/4: NavigateLinkedIn.clickJobs()
711/5: navigate = NavigateLinkedIn()
711/6: navigate.clickJobs()
711/7:
navigate.clickJobs()
navigate.clickUKJuniorDataScientist()
711/8: from bs4 import BeautifulSoup
711/9:
html = driver.page_source
soup = BeautifulSoup(html)
711/10: print(soup.prettify())
711/11: soup.find("ul", "jobs-search-results__list artdeco-list")
711/12: soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
711/13: soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li").find_all("h4")
711/14: soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li").find("h4")
711/15: soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li"))
711/16: soup.find("ul", "jobs-search-results__list artdeco-list").find("li")
711/17: soup.find("ul", "jobs-search-results__list artdeco-list").find("li").find("h4")
711/18: soup.find("ul", "jobs-search-results__list artdeco-list").find("li").find("h4").text
711/19: job_frame = soup.find("ul", "jobs-search-results__list artdeco-list")
711/20: job_frame
711/21: job_frame = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
711/22: job_list = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
711/23: job_list
711/24: soup.find("ul", "jobs-search-results__list artdeco-list").find("li").find("h4").text.strip(0)
711/25: soup.find("ul", "jobs-search-results__list artdeco-list").find("li").find("h4").text.strip()
711/26: soup.find("ul", "jobs-search-results__list artdeco-list").find("li").find("h4").text
712/1:
from job_application_filter import *
from bs4 import BeautifulSoup
712/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
712/3: login.SignIn()
712/4:
navigate.clickJobs()
navigate.clickUKJuniorDataScientist()
712/5:
navigate.clickJobs()
navigate.clickUKJuniorDataScientist()
712/6: navigate.clickJobs()
712/7: navigate.clickUKJuniorDataScientist()
712/8: scrape.passURLtoBeautifulSoup()
712/9: navigate.url
713/1:
from job_application_filter import *
from bs4 import BeautifulSoup
713/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
713/3: login.SignIn()
713/4: navigate.clickJobs()
713/5: navigate.clickUKJuniorDataScientist()
713/6: navigate.url
713/7: scrape.url
714/1:
from job_application_filter import *
from bs4 import BeautifulSoup
714/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
715/1:
from job_application_filter import *
from bs4 import BeautifulSoup
715/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
715/3: login.SignIn()
715/4: navigate.clickJobs()
715/5: navigate.clickUKJuniorDataScientist()
715/6: scrape.url
715/7: navigate.url
715/8: scrape.url
716/1:
from job_application_filter import *
from bs4 import BeautifulSoup
716/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
716/3: login.SignIn()
716/4: navigate.clickJobs()
716/5: navigate.clickUKJuniorDataScientist()
716/6: scrape.url
716/7: navigate.url
716/8: scrape.passURLtoBeautifulSoup()
717/1:
from job_application_filter import *
from bs4 import BeautifulSoup
717/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
717/3: login.SignIn()
717/4: navigate.clickJobs()
717/5: navigate.clickUKJuniorDataScientist()
717/6: scrape.url
717/7: scrape.html_content
717/8: scrape.passHTMLContenttoBeautifulSoup(0)
717/9: scrape.passHTMLContenttoBeautifulSoup()
717/10: scrape.retrieveCompanyName()
717/11: self.soup
717/12: scrape.soup
717/13: scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
717/14: scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
717/15: scrape.html_content
717/16: print(scrape.html_content.prettify())
717/17: scrape.html_content
717/18: type(scrape.html_content)
717/19: scrape.html_content
717/20: html = driver.page_source
717/21: html
717/22:
from bs4 import BeautifulSoup
soup = BeautifulSoup(html)
717/23: soup.find_all("ul", {"class":"peek-carousel__slides"})
717/24:
html = driver.page_source
soup = BeautifulSoup(html)
717/25: print(soup.prettify())
717/26: soup.find("ul", "jobs-search-results__list artdeco-list").find("li").find("h4").text
717/27: scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
717/28: scrape.html_content
717/29: scrape.retrieveCompanyName()
717/30:
html = driver.page_source
soup = BeautifulSoup(scrape.html_content)
717/31: print(soup.prettify())
717/32: soup.find("ul", "jobs-search-results__list artdeco-list").find("li").find("h4").text
718/1:
from job_application_filter import *
from bs4 import BeautifulSoup
718/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
718/3: login.SignIn()
718/4: navigate.clickJobs()
718/5: navigate.clickUKJuniorDataScientist()
718/6: scrape.passHTMLContenttoBeautifulSoup()
718/7: scrape.html_content
718/8: scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
718/9:
scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
scrape
718/10: scrape
718/11: self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
718/12: scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
718/13: scrape.html_content
718/14: scrape.html_content.prettify()
718/15: scrape.html_content
718/16: driver.get_cookies
718/17: driver.get_cookies.text
718/18: driver.current_url
718/19: scrape.driver.current_url
718/20: scrape.html_content
718/21: scrape.driver
718/22: scrape.driver.page_source
718/23: scrape.driver.page_source
719/1:
from job_application_filter import *
from bs4 import BeautifulSoup
719/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
719/3: login.SignIn()
719/4: navigate.clickJobs()
719/5: navigate.clickUKJuniorDataScientist()
719/6: scrape.passHTMLContenttoBeautifulSoup()
719/7: scrape.driver.current_url
719/8: scrape.driver.current_url
719/9: scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
719/10: type(scrape.soup.find("ul", "jobs-search-results__list artdeco-list"))
719/11: scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
719/12: scrape.driver.page_source
719/13: scrape.driver.page_source == scrape.html_content
719/14: scrape.html_content
719/15: scrape.driver.page_source
720/1:
from job_application_filter import *
from bs4 import BeautifulSoup
720/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
720/3: login.SignIn()
720/4: navigate.clickJobs()
720/5: navigate.clickUKJuniorDataScientist()
720/6: scrape.passHTMLContenttoBeautifulSoup()
720/7: scrape.driver.current_url
720/8: scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
720/9: scrape.retrieveCompanyName()
720/10: scrape.list_job_ads
720/11:
for job in scrape.list_job_ads:
    print(job)
720/12:
for job in scrape.list_job_ads:
    job.find("h4")
720/13: scrape.company_names
720/14: scrape.list_job_ads:
720/15: scrape.list_job_ads
721/1:
from job_application_filter import *
from bs4 import BeautifulSoup
721/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
721/3: login.SignIn()
721/4: navigate.clickJobs()
721/5: navigate.clickUKJuniorDataScientist()
721/6: scrape.passHTMLContenttoBeautifulSoup()
721/7: navigate.clickUKJuniorDataScientist()
721/8: scrape.passHTMLContenttoBeautifulSoup()
721/9: scrape.retrieveCompanyName()
721/10: scrape.list_job_ads
721/11: scrape.company_names
721/12: scrape.driver.page_source
721/13: list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
721/14:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
list_job_ads
721/15:
company_names = []

for job in list_job_ads:
            #try:
    company_names.append(job.find("h4").text.strip())
            #except:
            #    pass
721/16:
company_names = []

for job in list_job_ads:
            try:
                 company_names.append(job.find("h4").text.strip())
            except:
                print(job)
                break
721/17:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", {"id":"ember"})
list_job_ads
721/18:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", {"id":"ember "})
list_job_ads
721/19:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", {"id":"em"})
list_job_ads
721/20:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", id_ = "ember")
list_job_ads
721/21:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", id_ = "ember421")
list_job_ads
721/22:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
list_job_ads
721/23:
company_names = []

for job in list_job_ads:
            try:
                company_names.append(job.find("h4").text.strip())
            except:
                print(job)
                break
721/24:
company_names = []

for job in list_job_ads:
            try:
                company_names.append(job.find("h4").text.strip())
            except:
                print(job)
721/25:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", {"class":"occludable-update"})
list_job_ads
721/26:
company_names = []

for job in list_job_ads:
            try:
                company_names.append(job.find("h4").text.strip())
            except:
                print(job)
721/27: company_names
721/28: list_job_ads
721/29:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
#find_all("li", {"class":"occludable-update"})
list_job_ads
721/30:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", {"class":"occludable-update"})
list_job_ads
721/31: scrape.company_names
721/32:
list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", {"class":"occludable-update"})
list_job_ads
721/33:
company_names = []

for job in list_job_ads:
            try:
                company_names.append(job.find("h4").text.strip())
            except:
                print(job)
721/34: company_names
721/35: scrape.driver.execute_script("window.scrollTo(0, 1080)")
721/36:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/37:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
721/38:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/39:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/40:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = scarpe.driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/41:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = scrape.driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    scrape.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = scrape.driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/42:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = scrape.driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    scrape.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = scrape.driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/43:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = scrape.driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    scrape.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = scrape.driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/44:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = scrape.driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    scrape.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = scrape.driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/45: scrape.driver.find_element_by_xpath('//*[@id="ember29884"]').click()
721/46:
from selenium.webdriver.common.keys import Keys

html = scrape.soup.find_element_by_tag_name('html')
html.send_keys(Keys.END)
721/47:
from selenium.webdriver.common.keys import Keys

html = scrape.driver.page_source.find_element_by_tag_name('html')
html.send_keys(Keys.END)
721/48:
action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 5, 5)
action.click()
action.perform()
721/49:
elem = find_element_by_id("ember32786")
ac = ActionChains(browser)
ac.move_to_element(elem).move_by_offset(x_off, y_off).click().perform()
721/50:
elem = scrape.driver.find_element_by_id("ember32786")
ac = ActionChains(browser)
ac.move_to_element(elem).move_by_offset(x_off, y_off).click().perform()
721/51:
from selenium import webdriver
el = scrape.driver.find_element_by_id("ember32786")

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 5, 5)
action.click()
action.perform()
721/52:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('//*[@id="ember32790"]')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, , 2)
action.click()
action.perform()
721/53:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('//*[@id="ember32790"]')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()
721/54:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('//*[@id="ember32790"]')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()
721/55:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('//*[@id="ember32790"]')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()

SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = scrape.driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    scrape.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = scrape.driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/56:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('//*[@id="ember32790"]')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()

SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = scrape.driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    scrape.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = scrape.driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/57:

elem = scrape.driver.find_element_by_id("ember32786")
ac = ActionChains(browser)
ac.move_to_element(elem).move_by_offset(x_off, y_off).click().perform()
721/58:
SCROLL_PAUSE_TIME = 0.5

# Get scroll height
last_height = scrape.driver.execute_script("return document.body.scrollHeight")

while True:
    # Scroll down to bottom
    scrape.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    # Wait to load page
    time.sleep(SCROLL_PAUSE_TIME)

    # Calculate new scroll height and compare with last scroll height
    new_height = scrape.driver.execute_script("return document.body.scrollHeight")
    if new_height == last_height:
        break
    last_height = new_height
721/59:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('//*[@id="ember32790"]')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()
721/60:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[2]/div/ul/li[1]')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()
721/61:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[2]/div/ul/li[1]')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()
721/62:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()
721/63:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 5, 5)
action.click()
action.perform()
721/64:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 10, 10)
action.click()
action.perform()
721/65:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()
721/66:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 0, 0)
action.click()
action.perform()
721/67:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 1, 1)
action.click()
action.perform()
721/68:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 5, 5)
action.click()
action.perform()
721/69:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 1000, 1000)
action.click()
action.perform()
721/70:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 100, 100)
action.click()
action.perform()
721/71:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember32786')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
721/72:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember34023')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
721/73:
import org.openqa.selenium.Keys

WebElement.sendKeys(Keys.DOWN);
WebElement.sendKeys(Keys.RETURN);
721/74:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember34023')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()

actions.send_keys(Keys.SPACE).perform()
721/75:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember34023')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()

action.send_keys(Keys.SPACE).perform()
721/76:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember34023')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
721/77:
from selenium import webdriver
el = scrape.driver.find_element_by_id('ember34023')

action = webdriver.common.action_chains.ActionChains(driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
721/78:

elem = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')
ac = ActionChains(browser)
ac.move_to_element(elem).move_by_offset(x_off, y_off).click().perform()
721/79: scrape.driver.find_element_by_tag_name('button')
721/80: scrape.driver.find_element_by_tag_name('button')["label"]
721/81: scrape.driver.find_element_by_tag_name('button', {"label": "Manage alerts"})
721/82: scrape.soup.find_element_by_tag_name('button', {"label": "Manage alerts"})
721/83: scrape.soup
721/84: scrape.soup.find('button', {"label": "Manage alerts"})
721/85: scrape.soup.find('button')
721/86: scrape.driver.page_source
721/87: scrape.driver.page_source.find('button', {"label": "Manage alerts"})
721/88: scrape.driver.page_source
721/89: scrape.driver.page_source.find_all('button', {"label": "Manage alerts"})
721/90: scrape.driver.page_source.findall('button', {"label": "Manage alerts"})
721/91: self.soup.find('button', {"label": "Manage alerts"})
721/92: scrape.soup.find('button', {"label": "Manage alerts"})
721/93: type*scrape.soup.find('button', {"label": "Manage alerts"})()
721/94: type(scrape.soup.find('button', {"label": "Manage alerts"}))
721/95: scrape.soup.find('button', {"label": "Manage alerts"})
721/96: scrape.soup
721/97: scrape.soup.find("button",
721/98: scrape.soup.find('button', {"aria-label": "Manage alerts"})
721/99: driver.find_element_by_tag_name('button')["aria-label"]
721/100: driver.find_element_by_xpath('//button[@arial-type="Manage alerts"]')
721/101: driver.find_element_by_class_name("artdeco-button")
721/102: driver.find_element_by_class_name("artdeco-button").click()
721/103: driver.find_element_by_class_name("artdeco-button")
721/104: driver.find_element_by_tag_name("button")
721/105: driver.find_element_by_tag_name("button").text
721/106: driver.find_element_by_tag_name("button")
721/107: driver.find_element_by_tag_name("button").get_attribute("aria-label/")
721/108: driver.find_element_by_tag_name("button").get_attribute("aria-label")
721/109: driver.find_element_by_tag_name("button")
721/110: driver.find_element_by_tag_name("button").a
721/111: driver.find_element_by_tag_name("button").id
722/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
722/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
722/3: login.SignIn()
722/4: navigate.clickJobs()
722/5: navigate.clickUKJuniorDataScientist()
722/6: scrape.passHTMLContenttoBeautifulSoup()
722/7: scrape.driver.find_element_by_tag_name("button").id
722/8: scrape.driver.find_element_by_tag_name("button")
722/9: scrape.driver.find_element_by_tag_name("button").click()
722/10: scrape.driver.find_element_by_tag_name("button")
722/11:
scrape.driver.find_element_by_tag_name("button")

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 5, 5)
action.click()
action.perform()
722/12:
el = scrape.driver.find_element_by_tag_name("button")

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 5, 5)
action.click()
action.perform()
722/13:
el = scrape.driver.find_element_by_tag_name("button")

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 5, 5)
action.click()
action.perform()
722/14:
el = scrape.driver.find_element_by_tag_name("button")

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 5, 5)
action.click()
action.perform()
722/15:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
722/16:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
722/17:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
722/18:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
722/19:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
722/20:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
723/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
723/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
723/3: login.SignIn()
723/4: navigate.clickJobs()
723/5: navigate.clickUKJuniorDataScientist()
723/6: scrape.passHTMLContenttoBeautifulSoup()
723/7:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
723/8:
from selenium import webdriver
el = scrape.driver.find_element_by_xpath('/html/body/div[5]/div[6]/div[3]/section[1]/div[2]/div/div/div[1]/div[1]/div[3]/button')

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(xoffset = 530, yoffset= 126)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
723/9: scrape.driver.find_element_by_tag_name("li-icon")
723/10: scrape.driver.find_element_by_tag_name("li-icon").type
723/11: scrape.driver.find_element_by_css_selector("button[aria-label='Manage alerts']").type
723/12: scrape.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
723/13: scrape.driver.find_element_by_css_selector("button[aria-label='Manage alerts']").click()
723/14:
from selenium import webdriver
el = scrape.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")

action = webdriver.common.action_chains.ActionChains(scrape.driver)
action.move_to_element_with_offset(el, 35, 78)
action.click()
action.perform()
for _ in range(2):
    action.send_keys(Keys.SPACE).perform()
    time.sleep(0.3)
724/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
725/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
725/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
725/3: login.SignIn()
725/4: navigate.clickJobs()
725/5: navigate.clickUKJuniorDataScientist()
725/6: scrape.passHTMLContenttoBeautifulSoup()
726/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
726/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
726/3: login.SignIn()
726/4: navigate.clickJobs()
726/5: navigate.clickUKJuniorDataScientist()
726/6: scrape.passHTMLContenttoBeautifulSoup()
727/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
727/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
727/3: login.SignIn()
727/4: navigate.clickJobs()
727/5: navigate.clickUKJuniorDataScientist()
727/6: scrape.passHTMLContenttoBeautifulSoup()
727/7: scrape.retrieveCompanyName()
727/8: scrape.company_names
727/9: scrape.soup.find_all("ul","artdeco-pagination__pages artdeco-pagination__pages--number")
727/10: scrape.soup.find_all("ul","artdeco-pagination__pages artdeco-pagination__pages--number").find_all(li)
727/11: scrape.soup.find_all("ul","artdeco-pagination__pages artdeco-pagination__pages--number").find_all("li")
727/12: scrape.soup.find_all("ul","artdeco-pagination__pages artdeco-pagination__pages--number").findall("li")
727/13: scrape.soup.find_all("ul","artdeco-pagination__pages artdeco-pagination__pages--number")
727/14: scrape.soup.find("ul","artdeco-pagination__pages artdeco-pagination__pages--number")
727/15: scrape.soup.find("ul","artdeco-pagination__pages artdeco-pagination__pages--number").find_all("li")
727/16: scrape.soup.find("ul","artdeco-pagination__pages artdeco-pagination__pages--number").find_all("li")[-1]
727/17: scrape.soup.find("ul","artdeco-pagination__pages artdeco-pagination__pages--number").find_all("li")[-1].span()
727/18: scrape.soup.find("ul","artdeco-pagination__pages artdeco-pagination__pages--number").find_all("li")[-1].span
727/19: scrape.soup.find("ul","artdeco-pagination__pages artdeco-pagination__pages--number").find_all("li")[-1].span.text
727/20: scrape.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").find_all("li")[-1].span.text
727/21:
for page in range(40)*25:
    print(page)
727/22:
for page in len(range(40)*25(:
    print(page)
727/23:
for page in len(range(40))*25:
    print(page)
727/24:
for page in range(40):
    print(page)
727/25:
for page in range(40):
    print(page*25)
728/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
729/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
729/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
729/3: login.SignIn()
729/4: navigate.clickJobs()
729/5: navigate.clickUKJuniorDataScientist()
729/6: scrape.retrieveCompanyName()
730/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
730/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
730/3: login.SignIn()
730/4: navigate.clickJobs()
730/5: navigate.clickUKJuniorDataScientist()
730/6: scrape.retrieveCompanyName()
731/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
731/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
731/3: login.SignIn()
731/4: navigate.clickJobs()
731/5: navigate.clickUKJuniorDataScientist()
731/6: scrape.retrieveCompanyName()
732/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
733/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
733/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
733/3: login.SignIn()
733/4: navigate.clickJobs()
733/5: navigate.clickUKJuniorDataScientist()
733/6: scrape.retrieveCompanyName()
734/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
734/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
734/3: login.SignIn()
734/4: navigate.clickJobs()
734/5: navigate.clickUKJuniorDataScientist()
734/6: scrape.retrieveCompanyName()
735/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
735/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
735/3: login.SignIn()
735/4: navigate.clickJobs()
735/5: navigate.clickUKJuniorDataScientist()
735/6: scrape.retrieveCompanyName()
735/7: scrape.list_job_ads
736/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
737/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
737/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
737/3: login.SignIn()
737/4: navigate.clickJobs()
737/5: navigate.clickUKJuniorDataScientist()
737/6: scrape.retrieveCompanyName()
737/7: scrape.list_job_ads
737/8: scrape.company_names
737/9: len(scrape.company_names)
737/10: scrape.company_names
737/11: "Ericsson" in scrape.company_names
737/12: in scrape.company_names
737/13: scrape.company_names
737/14:
html = driver.page_source
soup = BeautifulSoup(scrape.html_content)
737/15:
html = self.driver.page_source
soup = BeautifulSoup(html)
737/16:
html = scrape.driver.page_source
soup = BeautifulSoup(html)
737/17: soup
737/18: scrape.list_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
737/19: scrape.list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
737/20: list_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
737/21: list_job_ads
737/22: list_job_ads.find_all("h3")
737/23: list_job_ads
737/24: list_job_ads[0]
737/25: list_job_ads[0].find("h3")
737/26: list_job_ads[0].find("h3").text
738/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
739/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
739/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
739/3: login.SignIn()
739/4: navigate.clickJobs()
739/5: navigate.clickUKJuniorDataScientist()
740/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
740/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
740/3: login.SignIn()
740/4: navigate.clickJobs()
740/5: navigate.clickUKJuniorDataScientist()
740/6: scrape.retrieveInfo()
740/7: scrape.job_title
740/8: scrape.company_names
740/9: scrape,list_job_ads
740/10: scrape.list_job_ads
740/11: #scrape.retrieveInfo()
740/12: scrape.list_job_ads[3]
740/13: scrape.list_job_ads[3].text
740/14: scrape.list_job_ads[3].find("h4")
740/15: scrape.list_job_ads[3].find("h4").text
740/16: scrape.list_job_ads[2].find("h4").text
740/17: scrape.list_job_ads[1].find("h4").text
740/18: scrape.list_job_ads[4].find("h4").text
740/19: scrape.list_job_ads[6].find("h4").text
740/20: scrape.list_job_ads[8].find("h4").text
740/21: scrape.list_job_ads[4].find("h3").text
740/22: scrape.list_job_ads[6].find("h3").text
740/23: scrape.list_job_ads[8].find("h3").text
740/24: scrape.list_job_ads[10].find("h3").text
740/25: scrape.list_job_ads[0].find("h3").text
740/26: scrape.list_job_ads[1].find("h3").text
740/27: scrape.list_job_ads[2].find("h3").text
740/28: scrape.list_job_ads[2].find("h4").text
740/29: scrape.list_job_ads[0].find("h4").text
740/30: scrape.list_job_ads[0].find("h3").text
741/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
741/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
741/3: login.SignIn()
741/4: navigate.clickJobs()
741/5: navigate.clickUKJuniorDataScientist()
741/6: scrape.retrieveInfo()
741/7: scrape.company_names
741/8: len(scrape.company_names)
741/9: scrape.company_names
741/10: scrape.job_title
743/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
743/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
743/3: login.SignIn()
743/4: navigate.clickJobs()
743/5: navigate.clickUKJuniorDataScientist()
743/6: scrape.retrieveInfo()
743/7: scrape.job_title
743/8: scrape.company_name
743/9: scrape.company_names
743/10: len(scrape.company_names)
743/11: scrape.company_names
743/12:
last_page = scrape.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
find_all("li")
743/13: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
743/14: job_list
743/15: job_list[0]
743/16: job_list[0]["id"]
743/17: self.driver.find_element_by_id["{}".format(job_list[0]["id"])]
743/18: scrape.driver.find_element_by_id["{}".format(job_list[0]["id"])]
743/19: scrape.driver.find_element_by_id()"{}".format(job_list[0]["id"]))
743/20: scrape.driver.find_element_by_id("{}".format(job_list[0]["id"]))
743/21: scrape.driver.find_element_by_id("{}".format(job_list[0]["id"])).click()
743/22:
job_ids = []

for job_ads in job_list:
    job_ids.append(job_ads["id"])
743/23:
job_ids = []

for job_ads in job_list:
    try:
        job_ids.append(job_ads["id"])
    except:
        pass
743/24: job_ids
743/25: len(job_ids)
743/26: job_ids
743/27:
job_ids = []

for job_ads in job_list:
    try:
        job_ids.find("h4").text
        job_ids.append(job_ads["id"])
    except:
        pass
743/28: scrape.driver.find_element_by_id("{}".format(job_list[0]["id"])).click()
743/29: job_ids
743/30:
job_ids = []

for job_ads in job_list:
    try:
        job_ads.find("h4").text
        job_ids.append(job_ads["id"])
    except:
        pass
743/31: scrape.driver.find_element_by_id("{}".format(job_list[0]["id"])).click()
743/32: job_ids
743/33: len(job_ids)
743/34: job_ids
744/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
744/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
744/3: login.SignIn()
744/4: navigate.clickJobs()
744/5: navigate.clickUKJuniorDataScientist()
744/6: scrape.retrieveInfo()
745/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
745/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
745/3: login.SignIn()
745/4: navigate.clickJobs()
745/5: navigate.clickUKJuniorDataScientist()
745/6: scrape.retrieveInfo()
746/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
746/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
746/3: login.SignIn()
746/4: navigate.clickJobs()
746/5: navigate.clickUKJuniorDataScientist()
746/6: scrape.retrieveInfo()
747/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
747/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
747/3: login.SignIn()
747/4: navigate.clickJobs()
747/5: navigate.clickUKJuniorDataScientist()
747/6: scrape.retrieveInfo()
747/7: scrape.job_ids
747/8: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
747/9:
job_ids = []

for job_ads in job_list:
    try:
        job_ads.find("h4").text
        job_ids.append(job_ads["id"])
    except:
        pass
747/10: scrape.driver.find_element_by_id("{}".format(job_list[0]["id"])).click()
747/11: job_ids
748/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
748/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
749/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
749/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
749/3: login.SignIn()
749/4: navigate.clickJobs()
749/5: navigate.clickUKJuniorDataScientist()
749/6: scrape.retrieveInfo()
749/7: scrape.job_ids
749/8: scrape.company_names
750/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
750/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
750/3: login.SignIn()
750/4: navigate.clickJobs()
750/5: navigate.clickJobs()
750/6: navigate.clickUKJuniorDataScientist()
750/7: scrape.retrieveInfo()
750/8: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
750/9:
job_ids = []

for job_ad in job_list:
    try:
        job_ad.find("h4").text
        job_ids.append(job_ad["id"])
    except:
        pass
750/10: job_ids
750/11:
for id_ in job_ids:
    scrape.driver.find_element_by_id("{}".format(id)).click()
    time.sleep(0.5)
750/12:
for id_ in job_ids:
    scrape.driver.find_element_by_id("{}".format(id_)).click()
    time.sleep(0.5)
751/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
751/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
751/3: login.SignIn()
751/4: navigate.clickJobs()
751/5: navigate.clickJobs()
751/6: navigate.clickUKJuniorDataScientist()
751/7: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
751/8:
scrape.soup = scrape.driver.page_source
job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
751/9: scrape.soup
751/10:
scrape.soup = scrape.driver.page_source
job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list")
751/11:
job_ids = []

for job_ad in job_list:
    try:
        job_ad.find("h4").text
        job_ids.append(job_ad["id"])
    except:
        pass
751/12: scrape.soup = scrape.driver.page_source
751/13: scrape.soup = scrape.driver.page_source
751/14: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
751/15: scrape.soup = BeautifulSoup(self.driver.page_source, "html.parser")
751/16: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
751/17: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
751/18: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
751/19:
job_ids = []

for job_ad in job_list:
    try:
        job_ad.find("h4").text
        job_ids.append(job_ad["id"])
    except:
        pass
751/20: job_ids
751/21:
for id_ in job_ids:
    scrape.driver.find_element_by_id("{}".format(id_)).click()
    time.sleep(0.5)
751/22: job_ad
751/23: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
751/24: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
751/25:
job_ids = []

for job_ad in job_list:
    try:
        job_ids.append(job_ad.find("h3")["id"]        )
    except:
        pass
751/26: job_ids
751/27:
for id_ in job_ids:
    scrape.driver.find_element_by_id("{}".format(id_)).click()
    time.sleep(0.5)
752/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
752/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
752/3: login.SignIn()
752/4: navigate.clickJobs()
752/5: navigate.clickUKJuniorDataScientist()
752/6: scrape.retrieveInfo()
752/7: scrape.job_ids
753/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
753/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
753/3: login.SignIn()
753/4: navigate.clickJobs()
753/5: navigate.clickUKJuniorDataScientist()
753/6: scrape.retrieveInfo()
753/7: scrape.job_ids
754/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
754/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
754/3: login.SignIn()
754/4: navigate.clickJobs()
754/5: navigate.clickUKJuniorDataScientist()
754/6: scrape.retrieveInfo()
755/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
755/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
756/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
756/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
756/3: login.SignIn()
756/4: navigate.clickJobs()
756/5: navigate.clickJobs()
756/6: navigate.clickUKJuniorDataScientist()
756/7: scrape.retrieveInfo()
756/8: scrape.job_ids
756/9: scrape.company_names
756/10: len(scrape.company_names)
756/11: scrape.company_names
756/12: len(scrape.job_ids)
756/13: scrape.job_ids
756/14: scrape.retrieveInfo()
756/15: #scrape.retrieveInfo()
756/16: #scrape.job_ids
756/17: #scrape.company_names
756/18: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
756/19: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
756/20: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
756/21:
job_ids = []

for job_ad in job_list:
    try:
        job_ids.append(job_ad.find("h3")["id"])
    except:
        pass
756/22: job_ids
756/23:
for id_ in job_ids:
    scrape.driver.find_element_by_id("{}".format(id_)).click()
    time.sleep(0.5)
756/24: job_list[0]
756/25: job_list[0].a
756/26: job_list[0].a["data-control-id"]
756/27: job_list[0].a["href"]
757/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
757/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
757/3: login.SignIn()
757/4: navigate.clickJobs()
757/5: navigate.clickUKJuniorDataScientist()
757/6: scrape.retrieveInfo()
757/7: scrape.job_hrefs
757/8: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
757/9: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
757/10: job_list[0].a["href"]
757/11:
job_ids = []
job_hrefs = []

for job_ad in job_list:
    try:
        job_ids.append(job_ad.find("h3")["id"])
        job_hrefs.append(job_ad.a["href"])
    except:
        pass
757/12: job_hrefs
758/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
758/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
758/3: login.SignIn()
758/4: navigate.clickJobs()
758/5: navigate.clickUKJuniorDataScientist()
758/6: scrape.retrieveInfo()
758/7: scrape.job_hrefs
758/8: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
758/9: scrape.soup.find("h2", string="Company")
758/10: scrape.soup.find("div").find("h2", string="Company")
758/11: scrape.soup.find("h2", string = "Company")
758/12: scrape.soup.find("h2", string = "Company").child
758/13: scrape.soup.find("h2", string = "Company").children
758/14: list(scrape.soup.find("h2", string = "Company").children)
758/15: scrape.soup.find("h2", string = "Company").children
758/16: scrape.soup.find("h2", string = "Company").div
758/17: scrape.soup.find("h2", string = "Company")
758/18: import re
758/19:
for elem in scrape.soup(text=re.compile(r'Company')):
    print elem.parent
758/20:
for elem in scrape.soup(text=re.compile(r'Company')):
    print(elem.parent)
758/21:
for elem in scrape.soup(text=re.compile(r'Company')):
    print(elem.children)
758/22:
for elem in scrape.soup(text=re.compile(r'Company')):
    print(elem.child)
758/23:
for elem in scrape.soup(text=re.compile(r'Company')):
    elem
758/24: elem
758/25: scrape.soup.find("div", class_ = "ph2")
758/26: scrape.soup.find("div", class_ = "ph2").li
758/27: scrape.soup.find("div", class_ = "ph2")
758/28: scrape.soup.find("div", class_ = "ph2").text
758/29: company_text = scrape.soup.find("div", class_ = "ph2").text
758/30: company_text
758/31: re.sub(r"\\n|Company|Company page not claimed","", text)?
758/32: re.sub(r"\\n|Company|Company page not claimed","", text)
758/33: re.sub(r"\\n|Company|Company page not claimed","", company_text)
758/34: re.sub(r"\n|Company|Company page not claimed","", company_text)
758/35:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text)
if "employee" in
758/36:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    company_text_re
758/37:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    print(company_text_re)
758/38:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    match = re.search("(.+) employee")
758/39:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    match = re.search("(.+) employee", company_text_re)
    print(match_group)
758/40:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    match = re.search("(.+) employee", company_text_re)
    print(match.grou[])
758/41:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    match = re.search("(.+) employee", company_text_re)
    print(match.group)
758/42:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    match = re.search("(.+) employee", company_text_re)
    print(match.group())
758/43:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    match = re.search("(.+) employee", company_text_re)
    print(match.group(0))
758/44:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    match = re.search("(.+) employee", company_text_re)
    print(match.group(1))
758/45:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    match = re.search("(.+) employee", company_text_re)
    print(match.group(1))
else:
    match = ""
758/46:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    company_text_re = re.search("(.+) employee", company_text_re)
    print(company_text_re.group(1))
758/47:
company_text = scrape.soup.find("div", class_ = "ph2").text
company_text = "Company page not claimed"
758/48:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
if "employee" in company_text_re:
    company_text_re = re.search("(.+) employee", company_text_re)
    print(company_text_re.group(1))
758/49:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
# if "employee" in company_text_re:
#     company_text_re = re.search("(.+) employee", company_text_re)
#     print(company_text_re.group(1))
758/50:
company_text = scrape.soup.find("div", class_ = "ph2").text
company_text = "Company page not claimed"
758/51:
company_text_re = re.sub(r"\n|Company|Company page not claimed","", company_text).strip()
# if "employee" in company_text_re:
#     company_text_re = re.search("(.+) employee", company_text_re)
#     print(company_text_re.group(1))
758/52: company_text_re
758/53:
company_text_re = re.sub(r"\n|Company|page"not claimed","", company_text).strip()
# if "employee" in company_text_re:
#     company_text_re = re.search("(.+) employee", company_text_re)
#     print(company_text_re.group(1))
758/54:
company_text = scrape.soup.find("div", class_ = "ph2").text
company_text = "Company page not claimed"
758/55:
company_text_re = re.sub(r"\n|Company|page|not|claimed","", company_text).strip()
# if "employee" in company_text_re:
#     company_text_re = re.search("(.+) employee", company_text_re)
#     print(company_text_re.group(1))
758/56: company_text_re
764/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
764/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
764/3: login.SignIn()
764/4: navigate.clickJobs()
764/5: navigate.clickUKJuniorDataScientist()
764/6: scrape.retrieveInfo()
764/7: scrape.job_hrefs
764/8: scrape.company_size
764/9: scrape.company_size
764/10: scrape.company_size
764/11: len(scrape.company_size)
764/12: scrape.company_size
764/13: scrape.company_names
764/14: len(scrape.company_names)
765/1: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
765/2:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
765/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
765/4: login.SignIn()
765/5: navigate.clickJobs()
765/6: navigate.clickUKJuniorDataScientist()
765/7: scrape.retrieveInfo()
765/8: scrape.company_names
765/9: scrape.company_size
765/10: import re
765/11: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
765/12: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
765/13:
job_ids = []
job_hrefs = []

for job_ad in job_list:
    try:
        job_ids.append(job_ad.find("h3")["id"])
        job_hrefs.append(job_ad.a["href"])
    except:
        pass
765/14: job_hrefs
765/15: job_list[0]
765/16: job_list[0].span
765/17: job_list[0]
765/18: job_list[0].find("span", class_ = "search__location")
765/19: job_list[0].find("span")
765/20: job_list[0].text
765/21: job_list[0].h3
765/22: job_list[0].h3.id
765/23: job_list[0].h3["id"]
765/24: job_list[0]
765/25: job_list[0].find("span")
765/26: job_list[0].find(class_ = "location")
765/27: job_ids
765/28: job_ids[0]
765/29: re.search("\d+", job_ids[0])
765/30: re.search("\d+", job_ids[0]).group(1)
765/31: re.search("\d+", job_ids[0]).group(0)
765/32:
number_job_id = re.search("\d+", job_ids[0]).group(0)
number_job_id
765/33:
number_job_id = re.search("\d+", job_ids[0]).group(0)
number_job_id = int(number_job_id)
765/34:
number_job_id = re.search("\d+", job_ids[0]).group(0)
number_job_id = int(number_job_id)
number_job_id
765/35:
id_h3 = re.search("\d+", job_ids[0]).group(0)
id_loc = int(id_h3) + 4
id_loc
765/36:
id_h3 = re.search("\d+", job_ids[0]).group(0)
id_loc = int(id_h3) + 4
id_loc = "ember" + str(id_loc)
765/37:
id_h3 = re.search("\d+", job_ids[0]).group(0)
id_loc = int(id_h3) + 4
id_loc = "ember" + str(id_loc)
id_loc
765/38: self.soup.find("id_loc")
765/39: self.soup.find(id_loc)
765/40: scrape.soup.find(id_loc)
765/41: scrape.soup.find(id_ = id_loc)
765/42: div = soup.find(id=id_loc)
765/43: div = scrape.soup.find(id=id_loc)
765/44: div = scrape.soup.find(id=id_loc)
765/45: div = scrape.soup.find(id=id_loc)
765/46: div
765/47: div.text
765/48: div.text.strip(0)
765/49: div.text.strip()
766/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
766/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
767/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
767/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
767/3: login.SignIn()
767/4: navigate.clickJobs()
767/5: navigate.clickUKJuniorDataScientist()
767/6: scrape.retrieveInfo()
767/7: scrape.job_location
768/1:
columns = ["Company Name", ""]
df_jobs = []
768/2:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
768/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
768/4: login.SignIn()
768/5: navigate.clickJobs()
768/6: navigate.clickUKJuniorDataScientist()
768/7: scrape.retrieveInfo()
768/8: #scrape.job_location
768/9:
import pandas as pd

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs], columns = columns)
768/10:
import pandas as pd

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame([[scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]], columns = columns)
768/11: df_jobs
768/12:
import pandas as pd

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs], columns = columns)
768/13:
import pandas as pd

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame([[scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]], columns = columns)
768/14: df_jobs.iloc[0,0]
768/15: df = pd.DataFrame(scrape.job_hrefs)
768/16: df
768/17:
import pandas as pd

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs], columns = columns)
768/18:
for list_ in [scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]:
    
    print(len(list_))
768/19: scrape.job_location
768/20: scrape.company_names
769/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
770/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
770/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
770/3: login.SignIn()
770/4: navigate.clickJobs()
770/5: navigate.clickUKJuniorDataScientist()
770/6: scrape.retrieveInfo()
770/7:
import pandas as pd

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs], columns = columns)
770/8:
for list_ in [scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]:
    
    print(len(list_))
770/9: scrape.job_location
770/10: #scrape.job_location
770/11:
import pandas as pd

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame([[scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]], columns = columns)
770/12: df_jobs
770/13:
import pandas as pd

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs], columns = columns)
770/14:
import pandas as pd
import numpy as np

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame(np.column_stack([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]), columns = columns)
770/15: df_jobs
770/16: df_jobs.to_csv("test.csv")
770/17: df_jobs
770/18:
import pandas as pd
import numpy as np

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame(np.column_stack([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]), columns = columns, dtype = "str")
770/19: df_jobs
770/20: df_jobs.to_csv("test.csv")
771/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
771/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
771/3: login.SignIn()
771/4: navigate.clickJobs()
771/5: navigate.clickUKJuniorDataScientist()
771/6: navigate.clickUKJuniorDataScientist()
771/7: scrape.retrieveInfo()
772/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
772/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
772/3: login.SignIn()
772/4: navigate.clickJobs()
772/5: navigate.clickUKJuniorDataScientist()
772/6: navigate.clickJobs()
772/7: navigate.clickUKJuniorDataScientist()
772/8: scrape.retrieveInfo()
772/9: scrape.job_IDs
772/10: import re
772/11: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
772/12: company_text = scrape.soup.find("div", class_ = "ph2").text
772/13:
company_text_re = re.sub(r"\n|Company|page|not|claimed","", company_text).strip()
if "employee" in company_text_re:
    company_text_re = re.search("(.+) employee", company_text_re)
    print(company_text_re.group(1))
772/14: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
772/15:
job_ids = []
job_hrefs = []

for job_ad in job_list:
    try:
        job_ids.append(job_ad.find("h3")["id"])
        job_hrefs.append(job_ad.a["href"])
    except:
        pass
772/16: job_hrefs
772/17: job_ids
772/18:
for id_ in job_ids:
    scrape.driver.find_element_by_id("{}".format(id_)).click()
    time.sleep(0.5)
772/19:
for id_ in job_ids:
    scrape.driver.find_element_by_id("{}".format(id_)).click()
    time.sleep(1)
772/20: scrape.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header']")
772/21: scrape.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']")
772/22: scrape.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click
772/23: scrape.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click(0)
772/24: scrape.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()
773/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
773/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
773/3: login.SignIn()
773/4: login.SignIn()
773/5: navigate.clickJobs()
773/6: navigate.clickUKJuniorDataScientist()
773/7: scrape.retrieveInfo()
774/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
774/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
775/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
775/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
775/3: login.SignIn()
775/4: navigate.clickJobs()
775/5: navigate.clickUKJuniorDataScientist()
775/6: scrape.retrieveInfo()
776/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
776/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
776/3: login.SignIn()
776/4: navigate.clickJobs()
776/5: navigate.clickUKJuniorDataScientist()
776/6: scrape.retrieveInfo()
777/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
777/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
777/3: login.SignIn()
777/4: navigate.clickJobs()
777/5: navigate.clickUKJuniorDataScientist()
777/6: scrape.retrieveInfo()
777/7: scrape.job_IDs
777/8: len(scrape.job_IDs)
777/9: scrape.job_IDs
778/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
778/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
778/3: login.SignIn()
778/4: navigate.clickJobs()
778/5: navigate.clickUKJuniorDataScientist()
778/6: scrape.retrieveInfo()
779/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
779/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
779/3: login.SignIn()
779/4: navigate.clickJobs()
779/5: navigate.clickUKJuniorDataScientist()
780/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
780/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
780/3: login.SignIn()
780/4: navigate.clickJobs()
780/5: navigate.clickUKJuniorDataScientist()
780/6: scrape.retrieveInfo()
782/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
782/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
782/3: login.SignIn()
782/4: navigate.clickJobs()
782/5: navigate.clickUKJuniorDataScientist()
782/6: scrape.retrieveInfo()
782/7: scrape.html_content
782/8: scrape.html_content.keys()
782/9: scrape.html_content[1]
782/10: scrape.job_IDs
783/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
783/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
783/3: login.SignIn()
783/4: navigate.clickJobs()
783/5: navigate.clickUKJuniorDataScientist()
783/6: scrape.retrieveInfo()
783/7: scrape.job_IDs
783/8: scrape.job_IDs[-25]
783/9: scrape.job_IDs[:-25]
783/10: scrape.job_IDs[-1]
783/11: scrape.job_IDs[-2]
783/12: scrape.job_IDs[::-25]
783/13: scrape.job_IDs[:-25]
783/14: scrape.job_IDs[-25:]
783/15: scrape.job_IDs
784/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
784/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
784/3: login.SignIn()
784/4: navigate.clickJobs()
784/5: navigate.clickUKJuniorDataScientist()
784/6: scrape.retrieveInfo()
784/7: scrape.job_IDs
784/8: #scrape.job_IDs
784/9:
import pandas as pd
import numpy as np

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame(np.column_stack([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]), columns = columns, dtype = "str")
784/10:
for list_ in [scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]:
    
    print(len(list_))
784/11: scrape.company_names
784/12: scrape.company_names.append(["XXX1", "XXX2", "XXX3"])
784/13:
for list_ in [scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]:
    
    print(len(list_))
784/14: scrape.company_names.pop(["XXX1", "XXX2", "XXX3"])
784/15: scrape.company_names[-1]
784/16: scrape.company_names.pop()
784/17:
for list_ in [scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]:
    
    print(len(list_))
784/18:
scrape.company_names.append(["XXX1"])
scrape.company_names.append(["XXX2"])
scrape.company_names.append(["XXX3"])
784/19:
for list_ in [scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]:
    
    print(len(list_))
784/20:
import pandas as pd
import numpy as np

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame(np.column_stack([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]), columns = columns, dtype = "str")
784/21:
import pandas as pd
import numpy as np

columns = ["Company Name", "Job Title", "Company Size", "Job Location", "Job Link"]
df_jobs = pd.DataFrame(np.column_stack([scrape.company_names,
                        scrape.job_titles,
                        scrape.company_size,
                        scrape.job_location,
                        scrape.job_hrefs]), columns = columns)
784/22: df_jobs
784/23: df_jobs.to_csv("test.csv")
786/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
787/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
787/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
787/3: login.SignIn()
787/4: navigate.clickJobs()
787/5: navigate.clickUKJuniorDataScientist()
788/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
788/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
788/3: login.SignIn()
788/4: navigate.clickJobs()
788/5: navigate.clickUKJuniorDataScientist()
788/6: scrape.retrieveInfo()
788/7: scrape.job_IDs
789/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
789/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
789/3: login.SignIn()
789/4: navigate.clickJobs()
789/5: navigate.clickUKJuniorDataScientist()
789/6: scrape.retrieveInfo()
789/7:
keys = ["company_name", "company_size","job_title", "job_ID", "job_location", "job_href"]
values = [1,2,3,4,5,6]

dict(zip(keys,values))
790/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
791/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
792/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
793/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
793/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
793/3: login.SignIn()
793/4: navigate.clickJobs()
793/5: navigate.clickUKJuniorDataScientist()
793/6: scrape.retrieveInfo()
793/7: scrape.retrieveInfo()
794/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
794/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
794/3: login.SignIn()
794/4: navigate.clickJobs()
794/5: navigate.clickUKJuniorDataScientist()
794/6: scrape.retrieveInfo()
794/7: scrape.job_IDs
794/8: scrape.lst_job_IDs
795/1:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
795/2:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
795/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
795/4: login.SignIn()
795/5: navigate.clickJobs()
795/6: navigate.clickUKJuniorDataScientist()
795/7: scrape.retrieveInfo()
796/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
797/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
797/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
797/3: login.SignIn()
797/4: navigate.clickJobs()
797/5: navigate.clickUKJuniorDataScientist()
797/6: navigate.clickUKJuniorDataScientist()
797/7: scrape.retrieveInfo()
797/8: import re
797/9: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
797/10: job_list = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li")
797/11: job_list
797/12: job_list[0]
797/13: job_list[0].find("h4").text.strip()
797/14: job_list[1].find("h4").text.strip()
797/15: job_list[2].find("h4").text.strip()
797/16: job_list[3].find("h4").text.strip()
797/17: job_list[4].find("h4").text.strip()
797/18: job_list[5].find("h4").text.strip()
797/19: job_list[9].find("h4").text.strip()
797/20: job_list[10].find("h4").text.strip()
797/21: job_list[0].find("h4").text.strip()
797/22: job_list[5].find("h4").text.strip()
797/23: job_list[1].find("h4").text.strip()
797/24: job_list[8].find("h4").text.strip()
797/25: job_list[8].find("h4").a.text.strip()
797/26: job_list[0].find("h4").a.text.strip()
797/27: job_list[1].find("h4").a.text.strip()
797/28: job_list[0].find("h4").a.text.strip()
797/29: job_list[0].find_all("h4", {"data-control-name":"job_card_company_link"})
797/30: job_list.find_all("h4", {"data-control-name":"job_card_company_link"})
797/31: jscrape.soup.find_all("h4", {"data-control-name":"job_card_company_link"})
797/32: scrape.soup.find_all("h4", {"data-control-name":"job_card_company_link"})
797/33: scrape.soup.findall("h4", {"data-control-name":"job_card_company_link"})
797/34: scrape.soup
797/35: scrape.soup.findall("a4", {"data-control-name":"job_card_company_link"})
797/36: scrape.soup.find_all("a4", {"data-control-name":"job_card_company_link"})
797/37: job_list("a4", {"data-control-name":"job_card_company_link"})
797/38: job_list[0]("a4", {"data-control-name":"job_card_company_link"})
797/39: job_list[0]
797/40: job_list[0].h4
797/41: job_list[0].h4.a
797/42: job_list[0].h4.a.text
797/43: job_list[0].h4.a.text.strip()
797/44: job_list[1].h4.a.text.strip()
797/45: job_list[2].h4.a.text.strip()
797/46: job_list.aa.text.strip()
797/47: job_list.a.text.strip()
797/48: job_list.a
797/49: job_list["a"]
797/50: job_list[0].a
797/51: job_list[0].a["data-control-name"]
797/52: job_list[0].a
797/53: job_list[0].a.text
797/54: job_list[0].a
797/55: job_list[0].a["title"]
797/56: job_list[0].a
797/57: job_list[0].omg
797/58: job_list[0].img
797/59: job_list[0].img["title"]
797/60: job_list[0].img
797/61: job_list[0].find("img", class_ = "job-card-search__logo")
797/62: job_list[0].find("h4")
797/63: job_list[1]
797/64:
job_list = scrape.soup.find("ul", class_ = "jobs-search-results__list artdeco-list").find_all("li")
#("a4", {"data-control-name":"job_card_company_link"})
797/65: job_list[1]
797/66: job_list[0]
797/67: job_list[1]
797/68:
job_list = scrape.soup.find("ul", class_ = "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
#("a4", {"data-control-name":"job_card_company_link"})
797/69: job_list[1]
797/70: job_list[0]
797/71: job_list[0].find("h4").text.strip()
797/72: job_list[1].find("h4").text.strip()
797/73: job_list[2].find("h4").text.strip()
797/74: job_list[3].find("h4").text.strip()
798/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
798/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
798/3: login.SignIn()
798/4: navigate.clickJobs()
798/5: navigate.clickUKJuniorDataScientist()
798/6: scrape.retrieveInfo()
799/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
799/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
799/3: login.SignIn()
799/4: navigate.clickJobs()
799/5: navigate.clickUKJuniorDataScientist()
799/6: scrape.retrieveInfo()
799/7: scrape.lst_job_IDs
799/8: scrape.dict_data_row
800/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
800/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
800/3: login.SignIn()
800/4: navigate.clickJobs()
800/5: navigate.clickUKJuniorDataScientist()
800/6: scrape.retrieveInfo()
801/1:
keys = ["company_name", "company_size","job_title", "job_ID", "job_location", "job_href"]
values = [1,2,3,4,5,6]

dict(zip(keys,values))
801/2: dict_ = {}
801/3:
keys = ["company_name", "company_size","job_title", "job_ID", "job_location", "job_href"]
values = [1,2,3,4,5,6]

test_dict = dict(zip(keys,values))
test_dict
801/4: dict_ = {}
801/5: test_dict.update(dict_)
801/6: dict_
801/7: dict_.update(test_dict)
801/8: dict_
802/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
802/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
802/3: login.SignIn()
802/4: navigate.clickJobs()
802/5: navigate.clickUKJuniorDataScientist()
802/6: scrape.retrieveInfo()
802/7: scrape.dict_data_row
802/8:
keys = ["company_name", "company_size","job_title", "job_ID", "job_location", "job_href"]
values = [1,2,3,4,5,6]

test_dict = dict(zip(keys,values))
test_dict
802/9: dict_ = {}
802/10: dict_.update(test_dict)
802/11: dict_
803/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
803/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
803/3: login.SignIn()
803/4: navigate.clickJobs()
803/5: navigate.clickUKJuniorDataScientist()
803/6: scrape.retrieveInfo()
803/7: scrape.dict_data_row
803/8: scrape.dict_data_row[1]
803/9: scrape.dict_data_row
803/10: i,j = 1
803/11: i,j = 1, 1
803/12: i
804/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
804/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
804/3: login.SignIn()
804/4: navigate.clickJobs()
804/5: navigate.clickUKJuniorDataScientist()
804/6: scrape.retrieveInfo()
804/7: scrape.dict_data_row
805/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
805/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
805/3: login.SignIn()
805/4: navigate.clickJobs()
805/5: navigate.clickUKJuniorDataScientist()
805/6: scrape.retrieveInfo()
805/7: scrape.df
806/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
806/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
806/3: login.SignIn()
806/4: navigate.clickJobs()
806/5: navigate.clickUKJuniorDataScientist()
806/6: scrape.retrieveInfo()
806/7: scrape.df
807/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
807/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
807/3: login.SignIn()
807/4: navigate.clickJobs()
807/5: navigate.clickUKJuniorDataScientist()
807/6: scrape.retrieveInfo()
807/7: scrape.df
808/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
808/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
809/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
809/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
809/3: login.SignIn()
809/4: navigate.clickJobs()
809/5: navigate.clickUKJuniorDataScientist()
809/6: scrape.retrieveInfo()
809/7: scrape.df
809/8: scrape.df.shape[0]
809/9: scrape
809/10: self.dv.to_csv("test.csv")
809/11: scrape.dv.to_csv("test.csv")
809/12: scrape.df.to_csv("test.csv")
809/13: scrape.df.to_csv("test.csv")
809/14: scrape.df
809/15: scrape.dict_html_content
809/16: job_text = scrape.soup.find("div", class_ = "pr2").text
809/17:
job_text = scrape.soup.find("div", class_ = "pr2").text
job_text
809/18:
job_text = scrape.soup.find("div", class_ = "pr2").text
re.search(r" (.+ level)", job_text)
809/19:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" (.+ level)", job_text)
809/20:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" (.+ level)", job_text)
809/21:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" (.+ level)", job_text)
match.group(0)
809/22:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"(.+ level)", job_text)
match.group(0)
809/23:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"(.+ level)", job_text)
match.group(0)
809/24:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"(.+ level)", job_text)
match.group(1)
809/25:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"(.+ level)", job_text)
match.group(2)
809/26:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"(.+ level)", job_text)
match.group(0)
809/27:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" (.+ level)", job_text)
match.group(0)
809/28:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" ?(.+ level)", job_text)
match.group(0)
809/29:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" ?( .+ level)", job_text)
match.group(0)
809/30:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" ( .+ level)", job_text)
match.group(0)
809/31:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"( .+ level)", job_text)
match.group(0)
809/32:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"(.+ level)", job_text)
match.group(0)
809/33:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"(.+) level", job_text)
match.group(0)
809/34:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r"(.+) level", job_text)
match.group(1)
809/35:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" (.+) level", job_text)
match.group(1)
809/36:
job_text = scrape.soup.find("div", class_ = "pr2").text
match = re.search(r" (.+ level)", job_text)
match.group(1)
809/37: job_text = scrape.soup.find("div", class_ = "pr2").text
809/38:
job_text = scrape.soup.find("div", class_ = "pr2").text
job_text
809/39: applicant_count.group(1)
809/40:
job_text = scrape.soup.find("div", class_ = "pr2").text
position_level = re.search(r" (.+ level)", job_text)
applicant_count = re.search(r" (\d+) applic")
position_level.group(1)
809/41: applicant_count.group(1)
809/42:
job_text = scrape.soup.find("div", class_ = "pr2").text
position_level = re.search(r" (.+ level)", job_text)
applicant_count = re.search(r" (\d+) applic". job_text)
position_level.group(1)
809/43:
job_text = scrape.soup.find("div", class_ = "pr2").text
position_level = re.search(r" (.+ level)", job_text)
applicant_count = re.search(r" (\d+) applic", job_text)
position_level.group(1)
809/44: applicant_count.group(1)
809/45:
job_text = scrape.soup.find("div", class_ = "pr2").text
position_level = re.search(r" (.+ level)", job_text)
applicant_count = re.search(r" (\d+ applicants?)", job_text)
position_level.group(1)
809/46: applicant_count.group(1)
810/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
810/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
810/3: login.SignIn()
810/4: navigate.clickJobs()
810/5: navigate.clickUKJuniorDataScientist()
810/6: scrape.retrieveInfo()
811/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
811/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
811/3: login.SignIn()
811/4: navigate.clickJobs()
811/5: navigate.clickUKJuniorDataScientist()
811/6: navigate.clickUKJuniorDataScientist()
811/7: scrape.retrieveInfo()
812/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
812/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
812/3: login.SignIn()
812/4: navigate.clickJobs()
812/5: navigate.clickUKJuniorDataScientist()
812/6: scrape.retrieveInfo()
812/7: scrape.df
812/8: scrape.df["job_href"][0]
812/9: scrape.df
813/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
813/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
813/3: login.SignIn()
813/4: navigate.clickJobs()
813/5: navigate.clickUKJuniorDataScientist()
813/6: import re
813/7: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
813/8:
job_list = scrape.soup.find("ul", class_ = "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
#("a4", {"data-control-name":"job_card_company_link"})
813/9: job_list[3].find("time")
813/10: job_list[3].find("time")[datetime]
813/11: job_list[3].find("time")["datetime"]
814/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
814/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
814/3: login.SignIn()
814/4: navigate.clickJobs()
814/5: navigate.clickUKJuniorDataScientist()
815/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
815/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
815/3: login.SignIn()
815/4: navigate.clickJobs()
815/5: navigate.clickUKJuniorDataScientist()
815/6: scrape.retrieveInfo()
815/7: scrape.df
815/8: scrape.df.sort_values(by="applicant_count")
815/9: scrape.df.sort_values(by="applicant_count", ascending = False)
815/10:
scrape.df.applicant_count. = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
815/11:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
815/12: import re
815/13: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
815/14: company_text = scrape.soup.find("div", class_ = "ph2").text
815/15: company_text
815/16: company_text.strip()
815/17: company_text
815/18: company_text_re = re.sub(r"\n","", company_text).strip()
815/19:
company_text_re = re.sub(r"\n","", company_text).strip()
company_text_re
815/20: company_text = scrape.soup.find("div", class_ = "ph2").text
815/21:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text)
    company_size = re.search("(.+) employee", company_text).group(1)
else:
    company_size = re.sub(r"Company|page|not|claimed|This|is|my|company|>","", company_text).strip()
815/22: company_sector
815/23: company_sector.group(1)
815/24: company_sector
815/25: company_size
815/26:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search("(.+) employee", company_text).group(1)
else:
    company_size = re.sub(r"Company|page|not|claimed|This|is|my|company|>","", company_text).strip()
815/27: company_sector
815/28: company_size
815/29: company_text = scrape.soup.find("div", class_ = "ph2").text
815/30:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search("(.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/31: company_sector
815/32: company_size
815/33:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"(.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/34: company_sector
815/35: company_size
815/36:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"(.+) employee", company_text).group(0)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/37: company_sector
815/38: company_size
815/39:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"(.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/40:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/41: company_sector
815/42: company_size
815/43:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" ( .+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/44: company_sector
815/45: company_size
815/46:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/47: company_sector
815/48: company_size
815/49:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/50: company_size
815/51:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/52: company_size
815/53:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"(.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/54: company_size
815/55:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"( .+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/56: company_size
815/57:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/58: company_size
815/59:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/60: company_size
815/61: company_sector
815/62:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee ", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/63: company_size
815/64:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/65: company_size
815/66: company_sector
815/67:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"(?< )(.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/68:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"(.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/69: company_size
815/70: company_sector
815/71:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r" (.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/72: company_size
815/73:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"\s*(.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/74: company_size
815/75:
company_text = re.sub(r"\n", "", company_text).strip()

if "employee" in company_text:
    company_sector = re.search(r"employees? (.+)", company_text).group(1)
    company_size = re.search(r"\s+(.+) employee", company_text).group(1)
else:
    company_sector = "COMPANY SECTOR N/A"
    company_size = "COMPANY SIZE N/A"
815/76: company_size
815/77: company_sector
817/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
817/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
817/3: login.SignIn()
817/4: navigate.clickJobs()
817/5: navigate.clickUKJuniorDataScientist()
817/6: scrape.retrieveInfo()
818/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
818/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
818/3: login.SignIn()
818/4: navigate.clickJobs()
818/5: navigate.clickUKJuniorDataScientist()
818/6: scrape.retrieveInfo()
818/7:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
818/8: scrape.df.to_csv("test.csv")
818/9: scrape.df["job_post_date"]
818/10: scrape.df.to_csv("test.csv", date_format='%d%m%Y')
818/11: scrape.df.to_csv("test.csv", date_format='%d%m%Y')
818/12: scrape.df['job_post_date'] = pd.to_datetime(scrape.df['job_post_date'])
818/13: scrape.df['job_post_date']
818/14: scrape.df.sort_values(by='job_post_date', ascending = False)
818/15: scrape.df['job_post_date']
818/16: scrape.df['job_post_date'].date
818/17: scrape.df['job_post_date'][0]
818/18: scrape.df['job_post_date'][0].day
818/19: scrape.df['job_post_date'][0]
818/20: scrape.df['job_post_date'][0].pmth
818/21: scrape.df['job_post_date'][0].month
818/22: scrape.df['job_post_date'][0]
818/23: scrape.df['job_post_date']
818/24: scrape.df['job_href']
818/25: scrape.df['job_href'][0]
818/26: scrape.df
818/27:
from datetime import datetime

datetime.today().strftime('%Y-%m-%d')
818/28:
from datetime import datetime

today = datetime.today().strftime('%Y-%m-%d')
818/29: today
818/30: df
818/31: scrape.df
818/32: scrape.df["job_post_date"]
818/33: scrape.df["job_post_date"][0]
818/34: today - scrape.df["job_post_date"][0]
818/35:
from datetime import datetime

today = datetime.today()
818/36: today - scrape.df["job_post_date"][0]
818/37: scrape.df["since_posted (days)"] = today - scrape.df["job_post_date"][0]
818/38: scrape.df["since_posted (days)"]
818/39: scrape.df
818/40: scrape.df["since_posted (days)"] = today - scrape.df["job_post_date"]
818/41: scrape.df["job_post_date"][0]
818/42: scrape.df
818/43: scrape.df["since_posted"] = today - scrape.df["job_post_date"]
818/44: scrape.df["job_post_date"][0]
818/45: scrape.df
818/46: scrape.df["since_posted"] = today - scrape.df["job_post_date"]
818/47: scrape.df["job_post_date"][0]
818/48: scrape.df
818/49:
scrape.df.drop("since_posted (days
              )")
818/50: scrape.df.drop("since_posted (days")
818/51: scrape.df.drop("since_posted (days)")
818/52: scrape.df.drop("since_posted (days)", axis= 1)
818/53: scrape.df[0]
818/54: scrape.df
818/55: scrape.df.iloc[0, :]
818/56:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
818/57:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
818/58: login.SignIn()
818/59: navigate.clickJobs()
818/60: navigate.clickUKJuniorDataScientist()
818/61: scrape.df
819/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
819/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
819/3: login.SignIn()
819/4: navigate.clickJobs()
819/5: navigate.clickUKJuniorDataScientist()
819/6: scrape.retrieveInfo()
819/7:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
819/8: scrape.df['job_post_date'] = pd.to_datetime(scrape.df['job_post_date'])
819/9: scrape.df.sort_values(by='job_post_date', ascending = False)
819/10:
from datetime import datetime

today = datetime.today()
819/11: scrape.df["since_posted"] = today - scrape.df["job_post_date"]
819/12: scrape.df
819/13: scrape.df.shape[1]
819/14: scrape.df.shape[0]
819/15: scrape.df.since_posted
819/16: scrape.df.since_posted[0]
819/17: str(scrape.df.since_posted[0])
819/18: re.search(r"(\d+) days", str(scrape.df.since_posted[0])
819/19: re.search(r"(\d+) days", str(scrape.df.since_posted[0]))
819/20: re.search(r"(\d+) days", str(scrape.df.since_posted[0])).group(1)
819/21: re.search(r"(\d+) days", str(scrape.df.since_posted[1])).group(1)
819/22: re.search(r"(\d+) days", str(scrape.df.since_posted[3])).group(1)
819/23: re.search(r"(\d+) days", str(scrape.df.since_posted[2])).group(1)
819/24: scrape.df.since_posted[0]
819/25: scrape.df.since_posted[0].days
819/26: scrape.df.since_posted[1].days
819/27: scrape.df.since_posted[88].days
819/28: scrape.df["since_posted_days"] = scrape.df["since_posted"].days
819/29: scrape.df["since_posted_days"] = scrape.df["since_posted"].day
819/30: scrape.df.since_posted[88].days
819/31: scrape.df["since_posted_days"] = scrape.df["since_posted"].days
819/32: scrape.df.since_posted[88]
819/33: scrape.df.since_posted[88].days
819/34: scrape.df["since_posted"]
819/35: type(scrape.df["since_posted"])
819/36: scrape.df["since_posted"]
819/37: scrape.df["since_posted_days"] = scrape.df["since_posted"].apply(lambda x: x.days)
819/38: scrape.df["since_posted"]
819/39: scrape.df["since_posted_days"]
819/40: scrape.df
819/41:
def getDays(row):
    
    row = row.days
    return row

scrape.df["since_posted"].apply(getDays)
819/42: scrape.df["since_posted"]
819/43: scrape.df["since_posted"][0]
819/44: scrape.df["since_posted"][0].days
820/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
820/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
821/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
821/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
822/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
822/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
822/3: login.SignIn()
822/4: navigate.clickJobs()
822/5: navigate.clickUKJuniorDataScientist()
822/6: scrape.retrieveInfo()
822/7: test = "30/09/2019"
822/8:
import datetime

date_time_str = '30/09/2019'
date_time_obj = datetime.datetime.strptime(date_time_str, '%d/%m/%Y')
822/9: date_time_obj
822/10: date_time_obj.year
822/11: date_time_obj
822/12: date_time_obj.strftime('We are the %d, %b %Y')
822/13: date_time_obj.strftime('We are the %a, %b %Y')
823/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
823/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
823/3: login.SignIn()
823/4: navigate.clickJobs()
823/5: navigate.clickUKJuniorDataScientist()
823/6: scrape.retrieveInfo()
823/7:
from datetime import datetime

date_time_str = '30/09/2019'
date_time_obj = datetime.datetime.strptime(date_time_str, '%d/%m/%Y')
823/8:
from datetime import datetime

today = datetime.today()
823/9: today
823/10:
import datetime

today = datetime.today()
823/11:
from datetime import datetime

today = datetime.today()
823/12: today
823/13:
import datetime as dt
from datetime import datetime

today = datetime.today()
print(today)

date_time_str = '30/09/2019'
date_time_obj = dt.dt.strptime(date_time_str, '%d/%m/%Y')
823/14:
import datetime as dt
from datetime import datetime

today = datetime.today()
print(today)

date_time_str = '30/09/2019'
date_time_obj = datetime.dt.strptime(date_time_str, '%d/%m/%Y')
823/15:
import datetime as dt
from datetime import datetime

today = dt.today()
print(today)

date_time_str = '30/09/2019'
date_time_obj = datetime.dt.strptime(date_time_str, '%d/%m/%Y')
823/16:
import datetime as dt
from datetime import datetime

today = datetime.today()
print(today)

date_time_str = '30/09/2019'
date_time_obj = datetime.dt.strptime(date_time_str, '%d/%m/%Y')
823/17:
import datetime as dt
from datetime import datetime

today = datetime.today()
print(today)

date_time_str = '30/09/2019'
date_time_obj = dt.dt.strptime(date_time_str, '%d/%m/%Y')
823/18:
date_time_str = '30/09/2019'
date_time_obj = dt.dt.strptime(date_time_str, '%d/%m/%Y')
823/19:
import datetime as dt
from datetime import datetime

today = datetime.today()
print(today)
823/20:
date_time_str = '30/09/2019'
date_time_obj = dt.dt.strptime(date_time_str, '%d/%m/%Y')
823/21:
date_time_str = '30/09/2019'
date_time_obj = dt.datetiem.strptime(date_time_str, '%d/%m/%Y')
823/22:
date_time_str = '30/09/2019'
date_time_obj = dt.datetime.strptime(date_time_str, '%d/%m/%Y')
823/23: date_time_obj
824/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
824/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
824/3: login.SignIn()
824/4: navigate.clickJobs()
824/5: navigate.clickUKJuniorDataScientist()
824/6: scrape.retrieveInfo()
825/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
825/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
825/3: login.SignIn()
825/4: navigate.clickJobs()
825/5: navigate.clickUKJuniorDataScientist()
825/6: scrape.retrieveInfo()
826/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
826/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
826/3: login.SignIn()
826/4: navigate.clickJobs()
826/5: navigate.clickUKJuniorDataScientist()
826/6: scrape.retrieveInfo()
827/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
827/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
827/3: login.SignIn()
827/4: navigate.clickJobs()
827/5: navigate.clickUKJuniorDataScientist()
827/6: scrape.retrieveInfo()
827/7: test = None
828/1:
from job_application_filter import *
from bs4 import BeautifulSoup
import time
828/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
828/3: login.SignIn()
828/4: navigate.clickJobs()
828/5: navigate.clickUKJuniorDataScientist()
828/6: scrape.retrieveInfo()
828/7:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
828/8: scrape.df.to_csv("test.csv")
828/9: scrape.df
828/10:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
828/11: scrape.df.sort_values(by='job_post_date', ascending = False)
828/12: scrape.df.sort_values(by='job_post_date', ascending = False).iloc[0]
828/13: scrape.df.sort_values(by='job_post_date', ascending = False)["job_href"]
828/14: scrape.df.sort_values(by='job_post_date', ascending = False)["job_href"][0]
828/15: scrape.df.sort_values(by='job_post_date', ascending = False)["job_href"]
828/16: scrape.df.sort_values(by='job_post_date', ascending = False)
828/17: scrape.df.sort_values(by='job_post_date', ascending = False).iloc[0]
828/18: scrape.df.sort_values(by='job_post_date', ascending = False).iloc[0.10]
828/19: scrape.df.sort_values(by='job_post_date', ascending = False).iloc[0,10]
828/20: scrape.df.sort_values(by='job_post_date', ascending = False).iloc[0,9]
828/21: scrape.df.sort_values(by="job_post_date", ascending = False)
828/22: scrape.df.sort_values(by=["job_post_date", "applicant_count"], ascending = False)
829/1:
from job_application_filter import *
from bs4 import BeautifulSoup
829/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
829/3: login.SignIn()
829/4: navigate.clickJobs()
829/5: navigate.clickUKJuniorDataScientist()
829/6: scrape.retrieveInfo()
829/7: scrape.df.to_csv("test.csv")
829/8:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
829/9: scrape.df[scrape.df.applicant_count == 'APPLICANT COUNT N/A']
829/10: scrape.df.iloc[251]
829/11: scrape.df.iloc[251]["applicant_count"]
829/12: import numpy as np
829/13: scrape.df[scrape.df.applicant_count == 'APPLICANT COUNT N/A']
829/14: scrape.df.iloc[251]["applicant_count"] = np.nan
829/15:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
829/16: scrape.df.iloc[251]["applicant_count"]
829/17: scrape.df.iloc[251]
829/18: scrape.df.iloc[251, 5]
829/19: scrape.df.iloc[251, 5] = np.nan
829/20:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
829/21: scrape.df.iloc[251, 5]
829/22: scrape.df.iloc[251, 5] = 0
829/23: scrape.df.iloc[251, 5]
829/24:
scrape.df.applicant_count = scrape.df.applicant_count.astype("int32")
scrape.df.sort_values(by="applicant_count", ascending = False)
829/25: scrape.df.to_csv("test.csv")
829/26: scrape.df.to_csv("test.csv")
829/27: scrape.df.company_sector
829/28: scrape.df.company_sector.value_count
829/29: scrape.df.company_sector.value_counts
829/30: scrape.df.company_sector.value_counts(0)
829/31: scrape.df.company_sector.value_counts()
829/32: scrape.df.company_sector.value_counts()
829/33: list(scrape.df.company_sector.value_counts())
829/34: scrape.df.company_sector.value_counts()
829/35: scrape.df.company_sector.value_counts().index
829/36: list(scrape.df.company_sector.value_counts().index)
829/37:
to_write = list(scrape.df.company_sector.value_counts().index)
text_file = open("Output.txt", "w")
text_file.write()
829/38:
to_write = list(scrape.df.company_sector.value_counts().index)
text_file = open("company_sectors.txt", "w")
text_file.write(to_write)
829/39: scrape.df.company_sector.value_counts().index
829/40:
for sector in scrape.df.company_sector.value_counts().index:
    print(sector)
829/41:
text_file = open("company_sectors.txt", "w")

for sector in scrape.df.company_sector.value_counts().index:
    text_file.write(company_sector)
829/42:
text_file = open("company_sectors.txt", "w")

for sector in scrape.df.company_sector.value_counts().index:
    text_file.write(sector)
829/43:
text_file = open("company_sectors.txt", "w")

for sector in scrape.df.company_sector.value_counts().index:
    text_file.write(sector)
    
text_file.close()
829/44:
text_file = open("company_sectors.txt", "w")

for sector in scrape.df.company_sector.value_counts().index:
    text_file.write(sector)
    text_file.write("\n")
text_file.close()
829/45:
text_file = open("company_sectors.txt", "w")

for sector in scrape.df.company_sector.value_counts().index:
    if "," in sector and "&" not in sector:
        text_file.write(sector)
        text_file.write("\n")
        
text_file.close()
829/46:
text_file = open("company_sectors.txt", "w")

for sector in scrape.df.company_sector.value_counts().index:
    if "," not in sector and "&" in sector:
        text_file.write(sector)
        text_file.write("\n")
        
text_file.close()
829/47:
text_file = open("company_sectors.txt", "w")

for sector in scrape.df.company_sector.value_counts().index:
    if "," in sector:
        if "&" in sector
            text_file.write(sector)
            text_file.write("\n")
        else:
            pass
    else:
        text_file.write(sector)
        text_file.write("\n")
        
text_file.close()
829/48:
text_file = open("company_sectors.txt", "w")

for sector in scrape.df.company_sector.value_counts().index:
    if "," in sector:
        if "&" in sector:
            text_file.write(sector)
            text_file.write("\n")
        else:
            pass
    else:
        text_file.write(sector)
        text_file.write("\n")
        
text_file.close()
831/1:
from job_application_filter import *
from bs4 import BeautifulSoup
831/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
831/3: login.SignIn()
831/4: navigate.clickJobs()
831/5: navigate.clickUKJuniorDataScientist()
831/6: scrape.retrieveInfo()
831/7: scrape.df.to_csv("test.csv")
833/1:
import numpy as np
from transfer_functions import *
833/2:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    z = w.dot(p) + b
    if len(z) != 1:
        return [activation_function(a) for a in z]
    else:
        return activation_function(z)
833/3:
def normaliseLayerOutput(elements):
    for i, element in enumerate(elements):
        if type(element) == np.ndarray:
            elements[i] = element[0]
        else:
            pass
833/4:
p_array = np.array(range(-3,4))
p_array
833/5:
w_1 = np.array([2, 1])
b_1 = np.array([2, -1])
w_2 = np.array([1, -1])
b_2 = np.array(0)
q1_first_layer_output = [calculateOutput(p = p,
                                         w = w_1,
                                         b = b_1,
                                         activation_function = satlin,
                                         input_dim = 1,
                                         layer_dim = 2) for p in p_array]

for i, first_layer_output in enumerate(q1_first_layer_output):
    normaliseLayerOutput(first_layer_output)
    print(first_layer_output)
#      q1_output = [calculateOutput(p = first_layer_output, w=np.array(w_2),
#                                   b=np.array(b_2),
#                                   activation_function=purelin) for p in p_array]
833/6:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]
q1_first_layer_output = [calculateOutput(p = p,
                                         w = w_1,
                                         b = b_1,
                                         activation_function = satlin,
                                         input_dim = 1,
                                         layer_dim = 2) for p in p_array]


for i, first_layer_output in enumerate(q1_first_layer_output):
    normaliseLayerOutput(first_layer_output)
    print(first_layer_output)
#      q1_output = [calculateOutput(p = first_layer_output, w=np.array(w_2),
#                                   b=np.array(b_2),
#                                   activation_function=purelin) for p in p_array]
833/7:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = np.array(w)
    b = np.array(b)
    print(w, b)
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    z = w.dot(p) + b
    if len(z) != 1:
        return [activation_function(a) for a in z]
    else:
        return activation_function(z)
833/8:
def normaliseLayerOutput(elements):
    for i, element in enumerate(elements):
        if type(element) == np.ndarray:
            elements[i] = element[0]
        else:
            pass
833/9:
p_array = np.array(range(-3,4))
p_array
833/10:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]
q1_first_layer_output = [calculateOutput(p = p,
                                         w = w_1,
                                         b = b_1,
                                         activation_function = satlin,
                                         input_dim = 1,
                                         layer_dim = 2) for p in p_array]


for i, first_layer_output in enumerate(q1_first_layer_output):
    normaliseLayerOutput(first_layer_output)
    print(first_layer_output)
#      q1_output = [calculateOutput(p = first_layer_output, w=np.array(w_2),
#                                   b=np.array(b_2),
#                                   activation_function=purelin) for p in p_array]
833/11:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = np.array(w)
    b = np.array(b)
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    z = w.dot(p) + b
    if len(z) != 1:
        return [activation_function(a) for a in z]
    else:
        return activation_function(z)
833/12:
def normaliseLayerOutput(elements):
    for i, element in enumerate(elements):
        if type(element) == np.ndarray:
            elements[i] = element[0]
        else:
            pass
833/13:
p_array = np.array(range(-3,4))
p_array
833/14:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]
q1_first_layer_output = [calculateOutput(p = p,
                                         w = w_1,
                                         b = b_1,
                                         activation_function = satlin,
                                         input_dim = 1,
                                         layer_dim = 2) for p in p_array]


for i, first_layer_output in enumerate(q1_first_layer_output):
    normaliseLayerOutput(first_layer_output)
    print(first_layer_output)
#      q1_output = [calculateOutput(p = first_layer_output, w=np.array(w_2),
#                                   b=np.array(b_2),
#                                   activation_function=purelin) for p in p_array]
833/15: a_1
833/16:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]


for i, first_layer_output in enumerate(q1_first_layer_output):
    normaliseLayerOutput(first_layer_output)
    print(first_layer_output)
#      q1_output = [calculateOutput(p = first_layer_output, w=np.array(w_2),
#                                   b=np.array(b_2),
#                                   activation_function=purelin) for p in p_array]
833/17: a_1
833/18:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]


for i, a in enumerate(a_1):
    normaliseLayerOutput(a)
    print(a)
#      q1_output = [calculateOutput(p = first_layer_output, w=np.array(w_2),
#                                   b=np.array(b_2),
#                                   activation_function=purelin) for p in p_array]
833/19: a_1
833/20: a_1
833/21:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]


for i, a in enumerate(a_1):
    normaliseLayerOutput(a)
    print("p: {0} - a {1}".format(p[i],a))
#      q1_output = [calculateOutput(p = first_layer_output, w=np.array(w_2),
#                                   b=np.array(b_2),
#                                   activation_function=purelin) for p in p_array]
833/22:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]


for i, a in enumerate(a_1):
    normaliseLayerOutput(a)
    print("p: {0} - a {1}".format(p_array[i],a))
#      q1_output = [calculateOutput(p = first_layer_output, w=np.array(w_2),
#                                   b=np.array(b_2),
#                                   activation_function=purelin) for p in p_array]
833/23:
p = list(range(-3,4))
p
833/24:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = )]


for i, a in enumerate(a_1):
    normaliseLayerOutput(a)
    print("p: {0} - a {1}".format(p_array[i],a))
833/25:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]


for i, a in enumerate(a_1):
    normaliseLayerOutput(a)
    print("p: {0} - a {1}".format(p_array[i],a))
833/26:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]


for i, output in enumerate(output):
    normaliseLayerOutput(a)
    print("p: {0} - a {1}".format(p_array[i],a))
833/27:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]


for i, output in enumerate(output):
    normaliseLayerOutput(output)
    print("p: {0} - a {1}".format(p_array[i],output))
833/28:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]


for i, output in enumerate(output):
    normaliseLayerOutput(output)
    print("p: {0} - a {1}".format(p_array[i],output[0]))
833/29:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]


for i, output in enumerate(output):
    normaliseLayerOutput(output)
    print("p: {0} - a {1}".format(p_array[i],output[0][0]))
833/30:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]


for i, output in enumerate(output):
    normaliseLayerOutput(output)
    print("p: {0} - a: {1}".format(p_array[i],output[0][0]))
833/31:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]


for i, output in enumerate(output):
    normaliseLayerOutput(output)
    print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/32:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = np.array(w)
    b = np.array(b)
    p = np.array(p)
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    n = w.dot(p) + b
    return n
    if len(n) != 1:
        return [activation_function(a) for a in n]
    else:
        return activation_function(n)
833/33:
def normaliseLayerOutput(elements):
    for i, element in enumerate(elements):
        if type(element) == np.ndarray:
            elements[i] = element[0]
        else:
            pass
833/34:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a_1 = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/35: a_1
833/36:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_s: {1}".format(p_array[i],a_s))

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/37:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_s: {1}".format(p_array[i],a_s[0]))

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/38:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_s: {1}".format(p_array[i],a_s))

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/39:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_s: {1}".format(p_array[i],a_s[0]))

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/40: a
833/41:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_s: {1}".format(p_array[i],a_s[0]))

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/42: a
833/43: a_s
833/44:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_s: {1}".format(p_array[i],a_s[0]))

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/45: a_s
833/46: a
833/47: a.shape[:]
833/48: a
833/49:
for element in a:
    print(element)
833/50:
for element in a:
    print(element[0])
833/51:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i],a_s[0]))

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/52:
for element in a:
    print(element[0])
833/53:
for element in a:
    print(element[0][0])
833/54:
import numpy as np
from transfer_functions import *
import matplotlib.pyplot as plt
833/55:
import numpy as np
from transfer_functions import *
import matplotlib.pyplot as plt
%matplotlib inline
833/56:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = np.array(w)
    b = np.array(b)
    p = np.array(p)
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    n = w.dot(p) + b
    return n
    if len(n) != 1:
        return [activation_function(a) for a in n]
    else:
        return activation_function(n)
833/57:
def normaliseLayerOutput(elements):
    for i, element in enumerate(elements):
        if type(element) == np.ndarray:
            elements[i] = element[0]
        else:
            pass
833/58:
p = list(range(-3,4))
p
833/59:
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i],a_s[0]))

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/60:
for element in a:
    print(element[0][0])
833/61:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0])

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/62: n_1
833/63:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0][0])

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/64: n_1
833/65: plt.plot("line", x = n_1, y = p)
833/66: plt.plot("line", n_1, p)
833/67: n_1
833/68: print(len(n_1), len(p))
833/69: plt.plot(n_1, p)
833/70:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0][0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/71:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0][0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/72:
import numpy as np
from transfer_functions import *
import matplotlib.pyplot as plt
%matplotlib inline
833/73:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = np.array(w)
    b = np.array(b)
    p = np.array(p)
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    n = w.dot(p) + b
    if len(n) != 1:
        return [activation_function(a) for a in n]
    else:
        return activation_function(n)
833/74:
def normaliseLayerOutput(elements):
    for i, element in enumerate(elements):
        if type(element) == np.ndarray:
            elements[i] = element[0]
        else:
            pass
833/75:
p = list(range(-3,4))
p
833/76:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0][0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/77:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_1[0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/78:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_1[0][0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/79:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
a_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_1: {1}".format(p_array[i], a_s[0]))
    a_1.append(a_1[0][0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/80:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
a_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_1: {1}".format(p_array[i], a_s[0]))
    a_1.append(a_1[0])
    
plt.plot(a_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/81:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
a_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_1: {1}".format(p_array[i], a_s[0]))
    a_1.append(a_s[0])
    
plt.plot(a_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/82: a_1
833/83:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_2 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/84:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = np.array(w)
    b = np.array(b)
    p = np.array(p)
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    n = w.dot(p) + b
    return n
    if len(n) != 1:
        return [activation_function(a) for a in n]
    else:
        return activation_function(n)
833/85:
def normaliseLayerOutput(elements):
    for i, element in enumerate(elements):
        if type(element) == np.ndarray:
            elements[i] = element[0]
        else:
            pass
833/86:
p = list(range(-3,4))
p
833/87:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0][0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/88:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/89:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[1]))
    n_1.append(a_s[0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/90:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_2 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_2: {1}".format(p_array[i], a_s[1]))
    n_2.append(a_s[1])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/91:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/92:
#ex 2.6 - 1
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_2 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_2: {1}".format(p_array[i], a_s[1]))
    n_2.append(a_s[1])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/93:
#ex 2.6 - 3
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_2 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_2: {1}".format(p_array[i], a_s[1]))
    n_2.append(a_s[1])
    
plt.plot(n_2, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/94:
#ex 2.6 - 2
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]

for i, output in enumerate(output):
    normaliseLayerOutput(output)
    print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/95:
#ex 2.6 - 6
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]
output_list = []
for i, output in enumerate(output):
    normaliseLayerOutput(output)
    print("p: {0} - output: {1}".format(p_array[i], output[0][0]))
    output_list.append(output[0])
    
plt.plot(n_2, p)
833/96:
#ex 2.6 - 6
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]

output = [calculateOutput(p = a,
                          w = w_2,
                          b = b_2,
                          activation_function = purelin,
                          input_dim = 2,
                          layer_dim = 1) for a in a_1]
output_list = []
for i, output in enumerate(output):
    normaliseLayerOutput(output)
    print("p: {0} - output: {1}".format(p_array[i], output[0][0]))
    output_list.append(output[0])
    
plt.plot(output_list, p)
833/97:
#ex 2.6 - 4
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
a_2 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_2: {1}".format(p_array[i], a_s[1]))
    a_2.append(a_s[0])
    
plt.plot(a_2, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/98:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = np.array(w)
    b = np.array(b)
    p = np.array(p)
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    n = w.dot(p) + b
    if len(n) != 1:
        return [activation_function(a) for a in n]
    else:
        return activation_function(n)
833/99:
#ex 2.6 - 4
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
a_2 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - a_2: {1}".format(p_array[i], a_s[1]))
    a_2.append(a_s[0])
    
plt.plot(a_2, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
833/100:
def calculateOutput(w,
                    p,
                    b,
                    activation_function,
                    input_dim,
                    layer_dim):
    
    w = np.array(w)
    b = np.array(b)
    p = np.array(p)
    w = w.reshape(layer_dim, input_dim)
    b = b.reshape(layer_dim, 1)
    n = w.dot(p) + b
    return n
    if len(n) != 1:
        return [activation_function(a) for a in n]
    else:
        return activation_function(n)
833/101:
#ex 2.6 - 5
w_1 = [2, 1]
b_1 = [2, -1]
w_2 = [1, -1]
b_2 = [0]

a = [calculateOutput(p = p,
                       w = w_1,
                       b = b_1,
                       activation_function = satlin,
                       input_dim = 1,
                       layer_dim = 2) for p in p_array]
n_1 = []
for i, a_s in enumerate(a):
    normaliseLayerOutput(a_s)
    print("p: {0} - n_1: {1}".format(p_array[i], a_s[0]))
    n_1.append(a_s[0])
    
plt.plot(n_1, p)

# output = [calculateOutput(p = a,
#                           w = w_2,
#                           b = b_2,
#                           activation_function = purelin,
#                           input_dim = 2,
#                           layer_dim = 1) for a in a_1]

# for i, output in enumerate(output):
#     normaliseLayerOutput(output)
#     print("p: {0} - output: {1}".format(p_array[i],output[0][0]))
835/1: p_1 = np.array([-1, 1, -1])
835/2: import numpy as np
835/3:
p_1 = np.array([-1, 1, -1])
p_1
835/4: p_1 = np.array([-1, 1, -1]).reshape(3, 1)
835/5:
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_1
835/6:
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
p_2
835/7: p_2.T
835/8:
p_2 = np.array((-1, -1, 1).reshape(3, 1)
p_2
835/9:
p_2 = np.array((-1, -1, 1)).reshape(3, 1)
p_2
835/10:
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
p_2
835/11: p_2.T
835/12: w_l_1 = np.zeros(2, p_1.shape[0])
835/13: w_l_1 = np.zeros((2, p_1.shape[0])
835/14: w_l_1 = np.zeros((2, p_1.shape[0]))
835/15:
w_l_1 = np.zeros((2, p_1.shape[0]))
w_l_1
835/16: w_l_1.iloc[0]
835/17: w_l_1[0]
835/18:
w_l_1[0] = p_1
w_l_1[1] = p_2
w_l_1
835/19: import numpy as np
835/20:
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_1
835/21:
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
p_2
835/22:
w_l_1 = np.zeros((2, p_1.shape[0]))
w_l_1
835/23:
w_l_1[0] = p_1
w_l_1[1] = p_2
w_l_1
835/24:
w_l_1[0] = p_1.T
w_l_1[1] = p_2.T
w_l_1
835/25:
p_1 = np.array([-1, 1, -1]).reshape((3, 1))
p_1
835/26:
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_1
835/27: from perceptron import Perceptron
835/28:
weights = np.array([0,0,1]).reshape(3, 1)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

Perceptron()
835/29:
from perceptron import Perceptron
from transfer_function import *
835/30:
from perceptron import Perceptron
from transfer_functions import *
835/31:
weights = np.array([0,0,1]).reshape(3, 1)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

Perceptron(weights=weights, bias=bias, transfer_function=satlins )
835/32:
weights = np.array([0,0,1]).reshape(3, 1)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins )
835/33: perceptron.weights
835/34:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins )
835/35: perceptron.weights
835/36: perceptron.classify(p_1)
836/1:
from perceptron import Perceptron
from transfer_functions import *
836/2:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins )
836/3: perceptron.classify(p_1)
836/4:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins())
836/5:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins)
836/6: perceptron.classify(p_1)
837/1:
from perceptron import Perceptron
from transfer_functions import *
837/2:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins)
837/3: perceptron.classify(p_1)
837/4: perceptron.classify(p_2)
837/5: perceptron.classify(p_1)
838/1:
from perceptron import Perceptron
from transfer_functions import *
838/2:
import numpy as np

from transfer_functions import *

class Perceptron(object):
    """
    Implementation of network described on pages 3-3:3-8
    An output of 1 means the input p is orthogonal of the decision boundary and points in the same direction as the weight.
    An oupout of -1 means the input p points in the opposite direction of the weight.
    Author: Jacob Taylor Cassady
    """
    def __init__(self, W, b, transfer_function=hardlims):
        self.Weights = W
        self.bias = b
        self.transfer_function = np.vectorize(transfer_function)
    def classify(self, prototype):
        net_input = self.Weights.dot(prototype) + self.bias
        return self.transfer_function(net_input)


if __name__ == "__main__":
    # prototype = [shape, texture, weight] as a column vector
    orange_prototype = np.array([1, -1, -1]).reshape((3, 1))
    apple_prototype = np.array([1, 1, -1]).reshape((3, 1))

    # Weight matrix and bias determined by decision boundary.
    decision_boundary = (orange_prototype != apple_prototype).astype(np.int).reshape((1, len(orange_prototype)))
    print(decision_boundary)
    bias = 0

    fruit_perceptron = Perceptron(W=decision_boundary, b=bias)

    test_prototype = np.array([-1, -1, -1]).reshape((3, 1))
    print(fruit_perceptron.classify(test_prototype))
838/3:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins)
838/4: perceptron.classify(p_1)
838/5:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins)
840/1:
from perceptron import Perceptron
from transfer_functions import *
840/2:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)
bias = np.array([1]).reshape(1, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=satlins)
840/3: perceptron.classify(p_1)
840/4: perceptron.classify(p_2)
840/5: perceptron.classify(p_1)
840/6: perceptron.classify(p_1[0])
840/7: perceptron.classify(p_1)[0]
840/8: perceptron.classify(p_1)
840/9: np.array(1).reshape(1,3)
840/10: orange_prototype = np.array([1, -1, -1]).reshape((3, 1))
840/11: apple_prototype = np.array([1, 1, -1]).reshape((3, 1))
840/12: decision_boundary = (orange_prototype != apple_prototype).astype(np.int).reshape((1, len(orange_prototype)))
840/13: decision_boundary
840/14: (orange_prototype != apple_prototype)@
840/15: (orange_prototype != apple_prototype)@
840/16: (orange_prototype != apple_prototype)
840/17: perceptron.inferDecisionBoundary(p_1, p_2)
841/1:
from perceptron import Perceptron
from transfer_functions import *
841/2:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias=bias, transfer_function=hardlims)
841/3:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, transfer_function=hardlims)
842/1:
from perceptron import Perceptron
from transfer_functions import *
842/2:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias = None transfer_function=hardlims)
842/3:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias = None. transfer_function=hardlims)
842/4:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias = None,@ transfer_function=hardlims)
842/5:
weights = np.array([0,0,1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias = None, transfer_function=hardlims)
842/6: perceptron.classify(p_1)
842/7: perceptron.inferDecisionBoundary(p_1, p_2)
842/8: perceptron.decision_boundary
842/9: perceptron.classify(p_1)
842/10: perceptron.classify(p_2)
842/11:
weights = np.array([0, 1, 1]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias = None, transfer_function=hardlims)
842/12: perceptron.inferDecisionBoundary(p_1, p_2)
842/13: perceptron.decision_boundary
842/14: perceptron.classify(p_1)
842/15: perceptron.classify(p_2)
842/16:
import numpy as np

from transfer_functions import *

class Perceptron(object):
    """
    Implementation of network described on pages 3-3:3-8
    An output of 1 means the input p is orthogonal of the decision boundary and points in the same direction as the weight.
    An oupout of -1 means the input p points in the opposite direction of the weight.
    Author: Jacob Taylor Cassady
    """
    def __init__(self, W, b, transfer_function=hardlims):
        self.Weights = W
        self.bias = b
        self.transfer_function = np.vectorize(transfer_function)
    def classify(self, prototype):
        net_input = self.Weights.dot(prototype) + self.bias
        return self.transfer_function(net_input)


if __name__ == "__main__":
    # prototype = [shape, texture, weight] as a column vector
    orange_prototype = np.array([1, -1, -1]).reshape((3, 1))
    apple_prototype = np.array([1, 1, -1]).reshape((3, 1))

    # Weight matrix and bias determined by decision boundary.
    decision_boundary = (orange_prototype != apple_prototype).astype(np.int).reshape((1, len(orange_prototype)))
    print(decision_boundary)
    bias = 0

    fruit_perceptron = Perceptron(W=decision_boundary, b=bias)

    test_prototype = np.array([-1, -1, -1]).reshape((3, 1))
    print(fruit_perceptron.classify(test_prototype))
842/17:
import numpy as np

from transfer_functions import *

class Perceptron(object):
    """
    Implementation of network described on pages 3-3:3-8
    An output of 1 means the input p is orthogonal of the decision boundary and points in the same direction as the weight.
    An oupout of -1 means the input p points in the opposite direction of the weight.
    Author: Jacob Taylor Cassady
    """
    def __init__(self, W, b, transfer_function=hardlims):
        self.Weights = W
        self.bias = b
        self.transfer_function = np.vectorize(transfer_function)
    def classify(self, prototype):
        net_input = self.Weights.dot(prototype) + self.bias
        return self.transfer_function(net_input)


if __name__ == "__main__":
    # prototype = [shape, texture, weight] as a column vector
    orange_prototype = np.array([1, -1, -1]).reshape((3, 1))
    apple_prototype = np.array([1, 1, -1]).reshape((3, 1))

    # Weight matrix and bias determined by decision boundary.
    decision_boundary = (orange_prototype != apple_prototype).astype(np.int).reshape((1, len(orange_prototype)))
    print(decision_boundary)
    bias = 0

    fruit_perceptron = Perceptron(W=decision_boundary, b=bias)

    test_prototype = np.array([-1, -1, -1]).reshape((3, 1))
    print(fruit_perceptron.classify(test_prototype))
842/18:
decision_boundary = perceptron.decision_boundary
decision_boundary
842/19:
k = np.array([ 0.59500984,  0.09655469, -0.79789754])
decision_boundary -= decision_boundary.dot(k) * k       # make it orthogonal to k
decision_boundary /= np.linalg.norm(decision_boundary)
842/20:
k = np.array([ 0,  1, -1])
decision_boundary -= decision_boundary.dot(k) * k       # make it orthogonal to k
decision_boundary /= np.linalg.norm(decision_boundary)
842/21:
k = decision_boundary
x = np.random.randn(3)  
x -= x.dot(k) * k
x /= np.linalg.norm(x)
842/22:
k = decision_boundary
x = np.random.randn(3).reshape(3,1)
x -= x.dot(k) * k
x /= np.linalg.norm(x)
842/23: decision_boundary
842/24:
k = decision_boundary
x = np.random.randn(3).reshape(1,3)
x -= x.dot(k) * k
x /= np.linalg.norm(x)
842/25:
k = decision_boundary
x = np.random.randn(3).reshape(3,1)
x -= x.dot(k) * k
x /= np.linalg.norm(x)
842/26: x
842/27: decision_boundary.shape[:]
842/28: np.cross(p_1, p_2)
842/29: p_1
842/30: p_2
842/31: np.cross(p_1.T, p_2.T)
842/32:
test_1 = np.array([1, -1, -1])
test_2 = np.array([1, 1, -1])
842/33: np.cross(test_1, test_2)
842/34:
weights = np.array([1, 0, 0]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias = None, transfer_function=hardlims)
843/1:
from perceptron import Perceptron
from transfer_functions import *
843/2:
weights = np.array([1, 0, 0]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias = None, transfer_function=hardlims)
843/3: perceptron.inferDecisionBoundary(p_1, p_2)
843/4:
decision_boundary = perceptron.decision_boundary
decision_boundary
843/5: perceptron.classify(p_1)
843/6: perceptron.classify(p_2)
843/7: np.cross(p_1.T, p_2.T)
843/8:
test_1 = np.array([1, -1, -1])
test_2 = np.array([1, 1, -1])
843/9: np.cross(test_1, test_2)
843/10:
from perceptron import Perceptron
from transfer_functions import *
843/11:
weights = np.array([0, 1, 0]).reshape(1, 3)
p_1 = np.array([-1, 1, -1]).reshape(3, 1)
p_2 = np.array([-1, -1, 1]).reshape(3, 1)

perceptron = Perceptron(weights=weights, bias = None, transfer_function=hardlims)
843/12: perceptron.inferDecisionBoundary(p_1, p_2)
843/13:
decision_boundary = perceptron.decision_boundary
decision_boundary
843/14: perceptron.classify(p_1)
843/15: perceptron.classify(p_2)
844/1:
from job_application_filter import *
from bs4 import BeautifulSoup
844/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
844/3: login.SignIn()
844/4: navigate.clickJobs()
844/5: navigate.clickUKJuniorDataScientist()
844/6: scrape.retrieveInfo()
845/1:
from job_application_filter import *
from bs4 import BeautifulSoup
845/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
845/3: login.SignIn()
845/4: navigate.clickJobs()
845/5: navigate.clickUKJuniorDataScientist()
845/6: scrape.retrieveInfo()
846/1:
from job_application_filter import *
from bs4 import BeautifulSoup
846/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
846/3: login.SignIn()
846/4: navigate.clickJobs()
846/5: navigate.clickUKJuniorDataScientist()
846/6: scrape.retrieveInfo()
847/1:
from job_application_filter import *
from bs4 import BeautifulSoup
847/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
847/3: login.SignIn()
847/4: navigate.clickJobs()
847/5: navigate.clickUKJuniorDataScientist()
847/6: navigate.clickUKJuniorDataScientist()
847/7: scrape.retrieveInfo()
847/8: scrape.df.to_csv("test.csv")
851/1: import numpy as np
851/2: data = open("data/ex1data1.txt", "r")
851/3: data
851/4:
for line in data:
    print(lime)
851/5:
for line in data:
    print(line)
851/6:
for line in data:
    data = line.split(",")
    print(data)
851/7:
for line in data:
    line_splitted = line.split(",")
    print(line_splitted)
851/8: line_splitted
851/9:
for line in data:
    print(line.split(","))
851/10: import numpy as np
851/11: data = open("data/ex1data1.txt", "r")
851/12:
for line in data:
    print(line.split(","))
851/13:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_splitted[0])
    profit.append(line_splitted[1])
851/14: population_of_the_city
851/15: profit
851/16:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    print(line_splitted)
    population_of_the_city.append(line_splitted[0])
    profit.append(line_splitted[1])
851/17: import numpy as np
851/18: data = open("data/ex1data1.txt", "r")
851/19:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_splitted[0])
    profit.append(line_splitted[1])
851/20: profit
851/21:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_spl(itted[0])
    profit.append(line_splitted[1].replace("\n", "")))
851/22: profit
851/23:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_spl(itted[0])
    profit.append(line_splitted[1].replace("\n", ""))
851/24: import numpy as np
851/25: data = open("data/ex1data1.txt", "r")
851/26:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_spl(itted[0])
    profit.append(line_splitted[1].replace("\n", ""))
851/27: profit
851/28: import numpy as np
851/29: data = open("data/ex1data1.txt", "r")
851/30:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_spl(itted[0])
    profit.append(line_splitted[1].replace("\n", ""))
851/31:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_splitted[0])
    profit.append(line_splitted[1].replace("\n", ""))
851/32: import numpy as np
851/33: data = open("data/ex1data1.txt", "r")
851/34:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_splitted[0])
    profit.append(line_splitted[1].replace("\n", ""))
851/35: profit
851/36: population_of_the_city
851/37: profit
851/38: import numpy as np
851/39: data = open("data/ex1data1.txt", "r")
851/40:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(line_splitted[0])
    profit.append(line_splitted[1].replace("\n", ""))
851/41: population_of_the_city
851/42: profit
851/43:
population_of_the_city = np.array(population_of_the_city)
population_of_the_city
851/44:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/45: population_of_the_city = np.array(population_of_the_city)
851/46: profit
851/47: import numpy as np
851/48: data = open("data/ex1data1.txt", "r")
851/49:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/50: population_of_the_city = np.array(population_of_the_city)
851/51: profit
851/52:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/53: import numpy as np
851/54: data = open("data/ex1data1.txt", "r")
851/55:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/56:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/57: population_of_the_city
851/58: profit
851/59:
def LinearRegression(x):
    
    return h_theta_1*x
851/60:
def CostFunction(x, y):
    
    y_hat = LinearRegression(x)
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/61:
def LinearRegression(x, h_theta_1 = 0):
    
    return h_theta_1*x
851/62:
def CostFunction(x, y):
    
    y_hat = LinearRegression(x)
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/63: CostFunction(population_of_the_city, profit)
851/64: (population_of_the_city - profit)**2
851/65: sum(0.5(population_of_the_city - profit)**2)
851/66: sum(0.5*(population_of_the_city - profit)**2)
851/67: len(profit)
851/68: sum(0.5*(population_of_the_city - profit)**2) / len(profit)
851/69: LinearRegression(population_of_the_city)
851/70: sum(0.5*(LinearRegression(population_of_the_city) - profit)**2) / len(profit)
851/71:
def GradientDescent(alfa = 0.2, x, y):
    
    return h_theta_1 - alfa(h_theta_1*x - y)
851/72:
def GradientDescent(x, y, alfa = 0.2):
    
    return h_theta_1 - alfa(h_theta_1*x - y)
851/73: profit
851/74: GradientDescent(x, y)
851/75:
def GradientDescent(x, y, alfa = 0.2):
    
    return h_theta_1 - alfa(h_theta_1*x - y)
851/76: GradientDescent(x, y)
851/77: GradientDescent(population_of_the_city, profit)
851/78: GradientDescent(population_of_the_city, profit, h_theta_1)
851/79:
x = population_of_the_city
y = profit
851/80:
h_theta_1 = 0
alfa= 0.2
851/81:
x = population_of_the_city
y = profit
851/82: h_theta_1 - alfa(h_theta_1*x - y)
851/83:
def GradientDescent(x, y, alfa = 0.2, h_theta_1 = 0):
    
    return h_theta_1 - alfa*(h_theta_1*x - y)
851/84:
x = population_of_the_city
y = profit
851/85: h_theta_1 - alfa*(h_theta_1*x - y)
851/86:
x = population_of_the_city
y = profit
m = len(x)
851/87: h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/88: #GradientDescent(population_of_the_city, profit, h_theta_1)
851/89:
def runLinearRegression():
    
    h_theta_1 = 0
    y_hat = LinearRegression(x, h_theta_1)
    cost = CostFunction(x, y, y_hat)
    h_theta_1 = GradientDescent(x, y, alfa = 0.2, h_theta_1 = h_theta)
    
    return
851/90:
def runLinearRegression(x, y, h_theta_1 = 0, alfa = 0.2):
    
    y_hat = LinearRegression(x, h_theta_1)
    cost = CostFunction(x, y, y_hat)
    h_theta_1 = GradientDescent(x, y, alfa = 0.2, h_theta_1 = h_theta)
    
    return
851/91:
def runLinearRegression(x, y, h_theta_1 = 0, alfa = 0.2):
    
    y_hat = LinearRegression(x, h_theta_1)
    cost = CostFunction(x, y, y_hat)
    h_theta_1 = GradientDescent(x, y, alfa = 0.2, h_theta_1 = h_theta)
    
    return h_theta_1
851/92: runLinearRegression(x, y, h_theta_1, alfa)
851/93:
def LinearRegression(x, h_theta_1 = 0):
    
    return h_theta_1*x
851/94:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/95: CostFunction(population_of_the_city, profit)
851/96:
def GradientDescent(x, y, alfa = 0.2, h_theta_1 = 0):
    
    return h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/97:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/98:
def GradientDescent(x, y, alfa = 0.2, h_theta_1 = 0):
    
    return h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/99: GradientDescent(population_of_the_city, profit, h_theta_1)
851/100:
def runLinearRegression(x, y, h_theta_1 = 0, alfa = 0.2):
    
    y_hat = LinearRegression(x, h_theta_1)
    cost = CostFunction(x, y, y_hat)
    h_theta_1 = GradientDescent(x, y, alfa = 0.2, h_theta_1 = h_theta)
    
    return h_theta_1
851/101:
def runLinearRegression(x, y, h_theta_1 = 0, alfa = 0.2):
    
    y_hat = LinearRegression(x, h_theta_1)
    cost = CostFunction(x, y, y_hat)
    h_theta_1 = GradientDescent(x, y, alfa = 0.2, h_theta_1 = h_theta)
    
    return h_theta_1
851/102:
h_theta_1 = 0
alfa= 0.2
851/103:
x = population_of_the_city
y = profit
m = len(x)
851/104: h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/105: runLinearRegression(x, y, h_theta_1, alfa)
851/106:
def runLinearRegression(x, y, h_theta_1 = 0, alfa = 0.2):
    
    y_hat = LinearRegression(x, h_theta_1)
    cost = CostFunction(x, y, y_hat)
    h_theta_1 = GradientDescent(x, y, alfa = 0.2, h_theta_1 = h_theta_1)
    
    return h_theta_1
851/107:
h_theta_1 = 0
alfa= 0.2
851/108:
x = population_of_the_city
y = profit
m = len(x)
851/109: h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/110: runLinearRegression(x, y, h_theta_1, alfa)
851/111:
def runLinearRegression(x, y, h_theta_1 = 0, alfa = 0.2):
    
    for i in range(1000):
        y_hat = LinearRegression(x, h_theta_1)
        cost = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, alfa, h_theta_1 = h_theta_1)
        print(cost)
851/112:
h_theta_1 = 0
alfa= 0.2
851/113:
x = population_of_the_city
y = profit
m = len(x)
851/114: h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/115: runLinearRegression(x, y, h_theta_1, alfa)
851/116:
def runLinearRegression(x, y, h_theta_1 = 0, alfa = 0.2):
    
    for i in range(1000):
        y_hat = LinearRegression(x, h_theta_1)
        cost = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, alfa, h_theta_1 = h_theta_1)
        print(cost)
    
    return h_theta_1
851/117:
h_theta_1 = 0
alfa= 0.2
851/118:
x = population_of_the_city
y = profit
m = len(x)
851/119: h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/120: runLinearRegression(x, y, h_theta_1, alfa)
851/121: h_theta_1 = runLinearRegression(x, y, h_theta_1, alfa)
851/122: h_theta_1
851/123:
def runLinearRegression(x, y, h_theta_1 = 0, ALFA = 0.2):
    
    EPSILON = 0.0000001
    cost_t_1 = 0
    for i in range(1000):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1
851/124:
h_theta_1 = 0
alfa= 0.2
851/125:
x = population_of_the_city
y = profit
m = len(x)
851/126: h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/127: h_theta_1 = runLinearRegression(x, y, h_theta_1, alfa)
851/128:
def runLinearRegression(x, y, h_theta_1 = 0, ALFA = 0.2):
    
    EPSILON = 0.0000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1
851/129:
h_theta_1 = 0
alfa= 0.2
851/130:
x = population_of_the_city
y = profit
m = len(x)
851/131: h_theta_1 - alfa*(sum((h_theta_1*x - y))/m)
851/132: h_theta_1 = runLinearRegression(x, y, h_theta_1, alfa)
851/133: data = open("data/ex1data1.txt", "r")
851/134: import numpy as np
851/135: data = open("data/ex1data1.txt", "r")
851/136:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/137:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/138: population_of_the_city
851/139: profit
851/140:
def LinearRegression(x, h_theta_1 = 0):
    
    return h_theta_1*x
851/141:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/142:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0):
    
    return h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
851/143:
def runLinearRegression(x, y, h_theta_1 = 0, ALFA = 0.2):
    
    EPSILON = 0.0000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1
851/144:
h_theta_1 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
851/145: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/146:
def runLinearRegression(x, y, h_theta_1 = 0, ALFA = 0.2):
    
    EPSILON = 0.0000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1)
        print(cost_t_1, cost_t)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1
851/147:
h_theta_1 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
851/148: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/149:
def runLinearRegression(x, y, h_theta_1 = 0, ALFA = 0.2):
    
    EPSILON = 0.00000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1)
        print(cost_t_1, cost_t)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1
851/150:
h_theta_1 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
851/151: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/152:
def runLinearRegression(x, y, h_theta_1 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1)
        print(cost_t_1, cost_t)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1
851/153:
h_theta_1 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
851/154: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/155:
def runLinearRegression(x, y, h_theta_1 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1
851/156:
h_theta_1 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
851/157: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/158:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/159:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/160:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return h_theta_0, h_theta_1
851/161:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1, h_theta_0)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/162:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
851/163: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/164: h_theta_1
851/165: h_theta_1
851/166:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1, h_theta_0)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/167:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
851/168: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/169:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/170: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/171: h_theta_1
851/172: import numpy as np
851/173: data = open("data/ex1data1.txt", "r")
851/174:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/175:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/176: population_of_the_city
851/177: profit
851/178:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/179:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/180:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return h_theta_0, h_theta_1
851/181:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1, h_theta_0)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/182:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/183: h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/184: h_theta_1
851/185: h_theta_0, h_theta_1 = runLinearRegression(x, y, h_theta_1, ALFA)
851/186: h_theta_1
851/187: (h_theta_0, h_theta_1) = runLinearRegression(x, y, h_theta_1, ALFA)
851/188: h_theta_1
851/189: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/190: h_theta_1*x + h_theta_0
851/191: h_theta_1*x
851/192: population_of_the_city
851/193: population_of_the_city*0
851/194: population_of_the_city*0 + h_theta_0
851/195: import numpy as np
851/196: data = open("data/ex1data1.txt", "r")
851/197:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/198:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/199: population_of_the_city
851/200: profit
851/201:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/202:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/203:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return h_theta_0, h_theta_1
851/204:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1, h_theta_0)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/205:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/206: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/207: h_theta_1
851/208: h_theta_1*x
851/209: population_of_the_city*0 + h_theta_0
851/210: h_theta
851/211:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/212:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1, h_theta_0)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/213:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/214: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/215: import numpy as np
851/216: data = open("data/ex1data1.txt", "r")
851/217:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/218:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/219: population_of_the_city
851/220: profit
851/221:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/222:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/223:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/224:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1, h_theta_0)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/225:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/226: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/227: h_theta
851/228:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/229:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1, h_theta_0)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/230:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/231: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/232: import numpy as np
851/233: data = open("data/ex1data1.txt", "r")
851/234:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/235:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/236: population_of_the_city
851/237: profit
851/238:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/239:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/240:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/241:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x, h_theta_1, h_theta_0)
        cost_t_1 = CostFunction(x, y, y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x, y, ALFA, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/242:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/243: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/244: h_theta
851/245: y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
851/246: CostFunction(x, y, y_hat)
851/247: import numpy as np
851/248: data = open("data/ex1data1.txt", "r")
851/249:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/250:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/251: population_of_the_city
851/252: profit
851/253:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/254:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/255:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/256:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/257:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/258: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/259: h_theta
851/260:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/261: h_theta
851/262: import numpy as np
851/263: data = open("data/ex1data1.txt", "r")
851/264:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/265:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/266: population_of_the_city
851/267: profit
851/268:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/269:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/270:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/271:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_0, h_theta_1
851/272:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/273: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/274: h_theta
851/275:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/276: y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0)
851/277: CostFunction(x, y, y_hat)
851/278:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print(cost_t_1)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1, h_theta_0
851/279:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/280: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/281: h_theta
851/282:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print(cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1, h_theta_0
851/283:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/284: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/285: h_theta
851/286: import numpy as np
851/287: data = open("data/ex1data1.txt", "r")
851/288:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/289:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/290: population_of_the_city
851/291: profit
851/292:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/293:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/294:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/295:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%s********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1, h_theta_0
851/296:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/297: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/298: h_theta
851/299:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1, h_theta_0
851/300:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/301: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/302:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1, h_theta_0
851/303:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/304: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/305:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1, h_theta_0
851/306:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/307: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/308: import numpy as np
851/309: data = open("data/ex1data1.txt", "r")
851/310:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/311:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/312: population_of_the_city
851/313: profit
851/314:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/315:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/316:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/317:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1, h_theta_0
851/318:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/319: h_theta = runLinearRegression(x, y, h_theta_1, ALFA)
851/320: h_theta
851/321: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
851/322: import numpy as np
851/323: data = open("data/ex1data1.txt", "r")
851/324:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/325:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/326: population_of_the_city
851/327: profit
851/328:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/329:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/330:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/331:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            break
    
    return h_theta_1, h_theta_0
851/332:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/333: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
851/334: h_theta
851/335:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print()
            break
    
    return h_theta_1, h_theta_0
851/336:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
851/337:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/338: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
851/339: h_theta
851/340: import numpy as np
851/341: data = open("data/ex1data1.txt", "r")
851/342:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
851/343:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
851/344: population_of_the_city
851/345: profit
851/346:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
851/347:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
851/348:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
851/349:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
851/350:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.1
x = population_of_the_city
y = profit
851/351: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
851/352: h_theta
851/353:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.4
x = population_of_the_city
y = profit
851/354: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
851/355:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.005
x = population_of_the_city
y = profit
851/356: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
854/1: import numpy as np
854/2: data = open("data/ex1data1.txt", "r")
854/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
854/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
854/5: population_of_the_city
854/6: profit
854/7:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
854/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
854/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
854/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
854/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.005
x = population_of_the_city
y = profit
854/12: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
854/13: h_theta
854/14: import numpy as np
854/15: data = open("data/ex1data1.txt", "r")
854/16:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
854/17:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
854/18: population_of_the_city
854/19: profit
854/20:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
854/21:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
854/22:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
854/23:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
854/24:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.005
x = population_of_the_city
y = profit
854/25: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
854/26: h_theta
855/1: import numpy as np
855/2: data = open("data/ex1data1.txt", "r")
855/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
855/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
855/5: population_of_the_city
855/6: profit
855/7:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
855/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
855/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
855/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
855/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.000001
x = population_of_the_city
y = profit
855/12: h_theta = runLinearRegression(x =x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
856/1: import numpy as np
856/2: data = open("data/ex1data1.txt", "r")
856/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
856/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
856/5: population_of_the_city
856/6: profit
856/7:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
856/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
856/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
856/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
856/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.0001
x = population_of_the_city
y = profit
856/12: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
856/13: h_theta
853/1:
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import Image
import pixiedust

%matplotlib inline

print("Libraries are loaded succesfully")
853/2: path_text_file = r"C:\Users\musta\Google Drive\A_Uni of Southampton Lessons\Self Study\Andrew NG Coursera\CourseraML-master\ex1\data\ex1data1.txt"
853/3:
import csv

with open(path_text_file) as inf:
    reader = csv.reader(inf, delimiter=",")
    profit = list(list(zip(*reader))[1])
    
with open(path_text_file) as inf:
    reader = csv.reader(inf, delimiter=",")
    population = list(list(zip(*reader))[0])
853/4:
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import Image
import pixiedust

%matplotlib inline

print("Libraries are loaded succesfully")
853/5: path_text_file = r"C:\Users\Cagri\Google Drive\Self Study\Andrew NG Coursera\CourseraML-master\ex1\data\ex1data1.txt"
853/6:
import csv

with open(path_text_file) as inf:
    reader = csv.reader(inf, delimiter=",")
    profit = list(list(zip(*reader))[1])
    
with open(path_text_file) as inf:
    reader = csv.reader(inf, delimiter=",")
    population = list(list(zip(*reader))[0])
853/7:
X = np.array(population).astype(np.float)
Y = np.array(profit).astype(np.float)
853/8:
plt.figure(figsize=(10,6))
plt.scatter(X, Y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");
853/9: X
853/10:
X = np.array(population).astype(np.float)
Y = np.array(profit).astype(np.float)
853/11:
plt.figure(figsize=(10,6))
plt.scatter(X, Y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");
853/12: #X = np.concatenate((theta_1_c, X), axis=1)
853/13: Image(filename='error_1_reshape.png')
853/14:
theta_1_c = np.full((X.shape[0]), 1)
X = np.concatenate((theta_1_c.reshape(-1,1), X.reshape(-1,1)), axis=1)
X.shape[:]
853/15: X
853/16:
iterations = 1500
alpha = 0.01
853/17:
def cost_function(X,Y,thetas = np.zeros(2)):

    h_theta_x =np.dot(X, thetas)

    return np.sum(((h_theta_x - Y)**2)/(Y.shape[0]*2))

cost_function(X,Y)
853/18:
def gradient_descent(X,Y,theta = np.zeros(X.shape[1])):
    
    theta_list = []
    cost_function_values = []
    m = X.shape[0]

    for i in range(iterations):
        h_theta_x = np.dot(X, theta)
        error = h_theta_x - Y
        
        cost_function_values.append(np.sum(((h_theta_x - Y)**2)/(m*2)))
        
        for j in range(theta.size):
            theta[j] = theta[j] - (alpha/m)*np.dot(error,X.transpose()[j]) # watch out for the transpose here.
            
        theta_list.append(list(theta)) #If you do not cast the theta values to a list, theta_list returns the wrong list.
        
    return theta_list, cost_function_values

theta_list, cost_function_values = gradient_descent(X,Y)
853/19:
def gradient_descent(X,Y,theta = np.zeros(X.shape[1])):
    
    theta_list = []
    cost_function_values = []
    m = X.shape[0]

    for i in range(iterations):
        h_theta_x = np.dot(X, theta)
        error = h_theta_x - Y
        
        cost_function_values.append(np.sum(((h_theta_x - Y)**2)/(m*2)))
        
        for j in range(theta.size):
            theta[j] = theta[j] - (alpha/m)*np.dot(error,X.transpose()[j]) # watch out for the transpose here.
            
        theta_list.append(list(theta)) #If you do not cast the theta values to a list, theta_list returns the wrong list.
        
    return theta_list, cost_function_values

theta_list, cost_function_values = gradient_descent(X,Y)
853/20: cost_function_values
853/21: cost_function_values[-1]
853/22: theta_list
853/23: theta_list[-1]
856/14:
h_theta_1 = 1.166362350335582
h_theta_0 = -3.63029143940436,
ALFA= 0.0001
x = population_of_the_city
y = profit
856/15:
h_theta_1 = 1.166362350335582
h_theta_0 = -3.63029143940436
ALFA= 0.0001
x = population_of_the_city
y = profit
856/16: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
856/17:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.0001
x = population_of_the_city
y = profit
856/18: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
853/24:
plt.figure(figsize=(10,6))
plt.scatter(X[:,1], Y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(X[:,1], y_hat, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
853/25: theta_list[-1]
853/26:
y_hat = theta_list[-1]*X
y_hat = np.sum(y_hat, axis=1)
853/27:
plt.figure(figsize=(10,6))
plt.scatter(X[:,1], Y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(X[:,1], y_hat, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
856/19:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, y_hat, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
856/20:
import numpy as np
import matplotlib.pyplot as plt
856/21: data = open("data/ex1data1.txt", "r")
856/22:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
856/23:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
856/24: population_of_the_city
856/25: profit
856/26:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
856/27:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = 0.5*(y_hat - y)**2
    
    return sum(z)/m
856/28:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
856/29:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
856/30:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.0001
x = population_of_the_city
y = profit
856/31: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
856/32: h_theta
856/33:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, y_hat, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
856/34:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, y, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
856/35:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, y_hat, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
853/28:
import numpy as np
import matplotlib.pyplot as plt
from IPython.display import Image
import pixiedust

%matplotlib inline

print("Libraries are loaded succesfully")
853/29: path_text_file = r"C:\Users\Cagri\Google Drive\Self Study\Andrew NG Coursera\CourseraML-master\ex1\data\ex1data1.txt"
853/30:
import csv

with open(path_text_file) as inf:
    reader = csv.reader(inf, delimiter=",")
    profit = list(list(zip(*reader))[1])
    
with open(path_text_file) as inf:
    reader = csv.reader(inf, delimiter=",")
    population = list(list(zip(*reader))[0])
853/31:
X = np.array(population).astype(np.float)
Y = np.array(profit).astype(np.float)
853/32:
plt.figure(figsize=(10,6))
plt.scatter(X, Y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");
853/33: #X = np.concatenate((theta_1_c, X), axis=1)
853/34: Image(filename='error_1_reshape.png')
853/35:
theta_1_c = np.full((X.shape[0]), 1)
X = np.concatenate((theta_1_c.reshape(-1,1), X.reshape(-1,1)), axis=1)
X.shape[:]
853/36:
iterations = 1500
alpha = 0.01
853/37:
def cost_function(X,Y,thetas = np.zeros(2)):

    h_theta_x =np.dot(X, thetas)

    return np.sum(((h_theta_x - Y)**2)/(Y.shape[0]*2))

cost_function(X,Y)
853/38:
def gradient_descent(X,Y,theta = np.zeros(X.shape[1])):
    
    theta_list = []
    cost_function_values = []
    m = X.shape[0]

    for i in range(iterations):
        h_theta_x = np.dot(X, theta)
        error = h_theta_x - Y
        
        cost_function_values.append(np.sum(((h_theta_x - Y)**2)/(m*2)))
        
        for j in range(theta.size):
            theta[j] = theta[j] - (alpha/m)*np.dot(error,X.transpose()[j]) # watch out for the transpose here.
            
        theta_list.append(list(theta)) #If you do not cast the theta values to a list, theta_list returns the wrong list.
        
    return theta_list, cost_function_values

theta_list, cost_function_values = gradient_descent(X,Y)
853/39: theta_list[-1]
853/40: y_hat
853/41: y_hat = theta_list[-1]*X
853/42:
y_hat = theta_list[-1]*X
y_hat
853/43: theta_list
853/44: theta_list[-1]
853/45: theta_list[-1]*y
853/46: theta_list[-1]*Y
853/47:
y_hat = theta_list[-1]*X
y_hat
853/48: y_hat
853/49: np.sum(y_hat, axis=1)
856/36: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
856/37: eq = h_theta_1 * x + h_theta_0
856/38: eq
856/39:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
856/40:
import numpy as np
import matplotlib.pyplot as plt
856/41: data = open("data/ex1data1.txt", "r")
856/42:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
856/43:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
856/44: population_of_the_city
856/45: profit
856/46:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
856/47:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
856/48:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
856/49:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
856/50:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.0001
x = population_of_the_city
y = profit
856/51: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
856/52: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
856/53: eq = h_theta_1 * x + h_theta_0
856/54:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
856/55:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
856/56:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
856/57: population_of_the_city
856/58: profit
856/59:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
856/60:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
856/61:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    print(ALFA)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
856/62:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
856/63:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.001
x = population_of_the_city
y = profit
856/64: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
856/65: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
857/1:
import numpy as np
import matplotlib.pyplot as plt
857/2: data = open("data/ex1data1.txt", "r")
857/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
857/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
857/5: population_of_the_city
857/6: profit
857/7:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
857/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
857/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    print(ALFA)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
857/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
857/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.001
x = population_of_the_city
y = profit
857/12: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
857/13: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
857/14: eq = h_theta_1 * x + h_theta_0
857/15:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
857/16:
import numpy as np
import matplotlib.pyplot as plt
857/17: data = open("data/ex1data1.txt", "r")
857/18:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
857/19:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
857/20: population_of_the_city
857/21: profit
857/22:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
857/23:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
857/24:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1*x + h_theta_0 - y))/m)
    
    return temp_h_theta_0, temp_h_theta_1
857/25:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
857/26:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.001
x = population_of_the_city
y = profit
857/27: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
857/28: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
857/29: eq = h_theta_1 * x + h_theta_0
857/30:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
857/31:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_1 + h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1 + h_theta_0 - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
857/32:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
857/33:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.001
x = population_of_the_city
y = profit
857/34: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
858/1:
import numpy as np
import matplotlib.pyplot as plt
858/2: data = open("data/ex1data1.txt", "r")
858/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
858/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
858/5: population_of_the_city
858/6: profit
858/7:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
858/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
858/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_1 + h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1 + h_theta_0 - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
858/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
858/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
858/12: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
859/1:
import numpy as np
import matplotlib.pyplot as plt
859/2: data = open("data/ex1data1.txt", "r")
859/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
859/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
859/5: population_of_the_city
859/6: profit
859/7:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
859/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
859/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_1 + h_theta_0 - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_1 + h_theta_0 - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
859/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
859/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
859/12:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 + h_theta_1.x - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_0 + h_theta_1.x - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
859/13:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
859/14:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
859/15: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
859/16: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
859/17: eq = h_theta_1 * x + h_theta_0
859/18:
import numpy as np
import matplotlib.pyplot as plt
859/19: data = open("data/ex1data1.txt", "r")
859/20:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
859/21:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
859/22: population_of_the_city
859/23: profit
859/24:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
859/25:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
859/26:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 + h_theta_1.x - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_0 + h_theta_1.x - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
859/27:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
859/28:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
859/29: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
859/30: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
859/31:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum((h_theta_0 + h_theta_1*x - y))/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((h_theta_0 + h_theta_1*x - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
859/32:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
859/33:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
859/34: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
860/1:
import numpy as np
import matplotlib.pyplot as plt
860/2: data = open("data/ex1data1.txt", "r")
860/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
860/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
860/5: population_of_the_city
860/6: profit
860/7:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
860/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
860/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum(LinearRegression(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1) - y)/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((LinearRegression(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1) - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
860/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
860/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
860/12: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
861/1:
import numpy as np
import matplotlib.pyplot as plt
861/2: data = open("data/ex1data1.txt", "r")
861/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
861/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
861/5: population_of_the_city
861/6: profit
861/7:
def LinearRegression(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
861/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
861/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum(LinearRegression(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1) - y)/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((LinearRegression(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1) - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
861/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
861/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
861/12: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = h_theta_1, h_theta_0 = h_theta_0, ALFA = ALFA)
861/13: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
861/14:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
861/15:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
861/16: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
861/17:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    print(h_theta_0, h_theta_1)
    temp_h_theta_0 = h_theta_0 - ALFA*(sum(LinearRegression(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1) - y)/m)
    temp_h_theta_1 = h_theta_1 - ALFA*(sum((LinearRegression(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1) - y)*x)/m)
    
    return temp_h_theta_0, temp_h_theta_1
861/18:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = LinearRegression(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
861/19:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
861/20: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
863/1:
import numpy as np
import matplotlib.pyplot as plt
863/2: data = open("data/ex1data1.txt", "r")
863/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
863/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
863/5: population_of_the_city
863/6: profit
863/7:
def h(x, h_theta_1 = 0, h_theta_0 = 0):
    
    return h_theta_1*x + h_theta_0
863/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
863/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_1 = 0, h_theta_0 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - (ALFA/m)*(sum(h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1) - y))
    temp_h_theta_1 = h_theta_1 - (ALFA/m)*(sum((h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1) - y)*x))
    
    return temp_h_theta_0, temp_h_theta_1
863/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_1 = h_theta_1, h_theta_0 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_1 = h_theta_1,
                                               h_theta_0 = h_theta_0)
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
863/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
863/12: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
863/13:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_1*x + h_theta_0
863/14:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_0 + h_theta_1*x
863/15:
import numpy as np
import matplotlib.pyplot as plt
863/16: data = open("data/ex1data1.txt", "r")
863/17:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
863/18:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
863/19: population_of_the_city
863/20: profit
863/21:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_0 + h_theta_1*x
863/22:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
863/23:
def GradientDescent(x, y, ALFA = 0.2, h_theta_0 = 0, h_theta_1 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - (ALFA/m)*(sum(h(x = x,
                                                 h_theta_0 = h_theta_0,
                                                 h_theta_1 = h_theta_1) - y))
    
    temp_h_theta_1 = h_theta_1 - (ALFA/m)*(sum((h(x = x,
                                                  h_theta_0 = h_theta_0,
                                                  h_theta_1 = h_theta_1) - y)*x))
    
    return temp_h_theta_0, temp_h_theta_1
863/24:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, , h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
863/25:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
863/26: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
864/1:
import numpy as np
import matplotlib.pyplot as plt
864/2: data = open("data/ex1data1.txt", "r")
864/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
864/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
864/5: population_of_the_city
864/6: profit
864/7:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_0 + h_theta_1*x
864/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
864/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_0 = 0, h_theta_1 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - (ALFA/m)*(sum(h(x = x,
                                                 h_theta_0 = h_theta_0,
                                                 h_theta_1 = h_theta_1) - y))
    
    temp_h_theta_1 = h_theta_1 - (ALFA/m)*(sum((h(x = x,
                                                  h_theta_0 = h_theta_0,
                                                  h_theta_1 = h_theta_1) - y)*x))
    
    return temp_h_theta_0, temp_h_theta_1
864/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.000000000000000000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
864/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
864/12: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
864/13:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.0000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
864/14:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.2
x = population_of_the_city
y = profit
864/15: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
864/16: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
864/17: eq = h_theta_1 * x + h_theta_0
864/18: eq
864/19:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.001
x = population_of_the_city
y = profit
864/20: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
864/21:
import numpy as np
import matplotlib.pyplot as plt
864/22: data = open("data/ex1data1.txt", "r")
864/23:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
864/24:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
864/25: population_of_the_city
864/26: profit
864/27:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_0 + h_theta_1*x
864/28:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
864/29:
def GradientDescent(x, y, ALFA = 0.2, h_theta_0 = 0, h_theta_1 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - (ALFA/m)*(sum(h(x = x,
                                                 h_theta_0 = h_theta_0,
                                                 h_theta_1 = h_theta_1) - y))
    
    temp_h_theta_1 = h_theta_1 - (ALFA/m)*(sum((h(x = x,
                                                  h_theta_0 = h_theta_0,
                                                  h_theta_1 = h_theta_1) - y)*x))
    
    return temp_h_theta_0, temp_h_theta_1
864/30:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.0000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
864/31:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.001
x = population_of_the_city
y = profit
864/32: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
864/33: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
864/34: eq = h_theta_1 * x + h_theta_0
864/35:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = 1.17x-3.63","Training Data"])
864/36:
eq = h_theta_1 * x + h_theta_0
eq
864/37: eq = h_theta_1 * x + h_theta_0
864/38:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = {0}x-{1}".format(h_theta_1, h_theta_0),"Training Data"])
864/39:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = {0.3f}x-{1}".format(h_theta_1, h_theta_0),"Training Data"])
864/40:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = {0}x-{1}".format(h_theta_1, h_theta_0),"Training Data"])
864/41:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = %.3fx-.3f" %(h_theta_1, h_theta_0),"Training Data"])
864/42:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = %0.3fx-%0.3f" %(h_theta_1, h_theta_0),"Training Data"])
864/43:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = %.3fx-%.3f" %(h_theta_1, h_theta_0),"Training Data"])
864/44:
plt.figure(figsize=(10,6))
plt.scatter(x, y, c="r")

plt.title("Population vs Profit of a food truck")
plt.xlabel("Population of a city in 10,000")
plt.ylabel("Profit of a food truck in $10,000");

plt.plot(x, eq, c="b")

plt.legend(["Regression Line = %.3fx%.3f" %(h_theta_1, h_theta_0),"Training Data"])
864/45:
def plotRegressionLine(x, y, h_theta_1, h_theta_0):
    plt.figure(figsize=(10,6))
    plt.scatter(x, y, c="r")

    plt.title("Population vs Profit of a food truck")
    plt.xlabel("Population of a city in 10,000")
    plt.ylabel("Profit of a food truck in $10,000");

    plt.plot(x, eq, c="b")

    plt.legend(["Regression Line = %.3fx%.3f" %(h_theta_1, h_theta_0),"Training Data"])
864/46: plotRegressionLine
864/47: plotRegressionLine()
864/48: plotRegressionLine(z, y, h_theta_1, h_theta_0)
864/49: plotRegressionLine(z, y, h_theta_1, h_theta_0)
864/50: plotRegressionLine(x, y, h_theta_1, h_theta_0)
864/51:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.00000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if i%500 == 0:
            plotRegressionLine(x, y, h_theta_1, h_theta_0)
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
864/52:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.001
x = population_of_the_city
y = profit
864/53: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
864/54:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.00000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if i%500 == 0:
            print("HEREEEEEEEEEEEEEEEE")
            plotRegressionLine(x, y, h_theta_1, h_theta_0)
            
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
864/55:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.001
x = population_of_the_city
y = profit
864/56: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
864/57:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
864/58: data = open("data/ex1data1.txt", "r")
864/59:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
865/1:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
865/2: data = open("data/ex1data1.txt", "r")
865/3:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
865/4:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
865/5: population_of_the_city
865/6: profit
865/7:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_0 + h_theta_1*x
865/8:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
865/9:
def GradientDescent(x, y, ALFA = 0.2, h_theta_0 = 0, h_theta_1 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - (ALFA/m)*(sum(h(x = x,
                                                 h_theta_0 = h_theta_0,
                                                 h_theta_1 = h_theta_1) - y))
    
    temp_h_theta_1 = h_theta_1 - (ALFA/m)*(sum((h(x = x,
                                                  h_theta_0 = h_theta_0,
                                                  h_theta_1 = h_theta_1) - y)*x))
    
    return temp_h_theta_0, temp_h_theta_1
865/10:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.00000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if i%500 == 0:
            print("HEREEEEEEEEEEEEEEEE")
            plotRegressionLine(x, y, h_theta_1, h_theta_0)
            
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
865/11:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.01
x = population_of_the_city
y = profit
865/12: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
865/13: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
865/14:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
865/15:
def plotRegressionLine(x, y, h_theta_1, h_theta_0):
    plt.figure(figsize=(10,6))
    plt.scatter(x, y, c="r")

    plt.title("Population vs Profit of a food truck")
    plt.xlabel("Population of a city in 10,000")
    plt.ylabel("Profit of a food truck in $10,000");

    plt.plot(x, eq, c="b")

    plt.legend(["Regression Line = %.3fx%.3f" %(h_theta_1, h_theta_0),"Training Data"])
865/16: data = open("data/ex1data1.txt", "r")
865/17:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
865/18:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
865/19: population_of_the_city
865/20: profit
865/21:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_0 + h_theta_1*x
865/22:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
865/23:
def GradientDescent(x, y, ALFA = 0.2, h_theta_0 = 0, h_theta_1 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - (ALFA/m)*(sum(h(x = x,
                                                 h_theta_0 = h_theta_0,
                                                 h_theta_1 = h_theta_1) - y))
    
    temp_h_theta_1 = h_theta_1 - (ALFA/m)*(sum((h(x = x,
                                                  h_theta_0 = h_theta_0,
                                                  h_theta_1 = h_theta_1) - y)*x))
    
    return temp_h_theta_0, temp_h_theta_1
865/24:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.00000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if i%500 == 0:
            print("HEREEEEEEEEEEEEEEEE")
            plotRegressionLine(x, y, h_theta_1, h_theta_0)
            
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
865/25:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.01
x = population_of_the_city
y = profit
865/26: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
865/27: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
865/28:
def plotRegressionLine(x, y, h_theta_1, h_theta_0):
    eq = h_theta_1*x + h_theta_0
    plt.figure(figsize=(10,6))
    plt.scatter(x, y, c="r")

    plt.title("Population vs Profit of a food truck")
    plt.xlabel("Population of a city in 10,000")
    plt.ylabel("Profit of a food truck in $10,000");

    plt.plot(x, eq, c="b")

    plt.legend(["Regression Line = %.3fx%.3f" %(h_theta_1, h_theta_0),"Training Data"])
865/29:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
865/30:
def plotRegressionLine(x, y, h_theta_1, h_theta_0):
    eq = h_theta_1*x + h_theta_0
    plt.figure(figsize=(10,6))
    plt.scatter(x, y, c="r")

    plt.title("Population vs Profit of a food truck")
    plt.xlabel("Population of a city in 10,000")
    plt.ylabel("Profit of a food truck in $10,000");

    plt.plot(x, eq, c="b")

    plt.legend(["Regression Line = %.3fx%.3f" %(h_theta_1, h_theta_0),"Training Data"])
865/31: data = open("data/ex1data1.txt", "r")
865/32:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
865/33:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
865/34: population_of_the_city
865/35: profit
865/36:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_0 + h_theta_1*x
865/37:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
865/38:
def GradientDescent(x, y, ALFA = 0.2, h_theta_0 = 0, h_theta_1 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - (ALFA/m)*(sum(h(x = x,
                                                 h_theta_0 = h_theta_0,
                                                 h_theta_1 = h_theta_1) - y))
    
    temp_h_theta_1 = h_theta_1 - (ALFA/m)*(sum((h(x = x,
                                                  h_theta_0 = h_theta_0,
                                                  h_theta_1 = h_theta_1) - y)*x))
    
    return temp_h_theta_0, temp_h_theta_1
865/39:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.00000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        print("ALFA: %s" %ALFA)
        if i%500 == 0:
            print("HEREEEEEEEEEEEEEEEE")
            plotRegressionLine(x, y, h_theta_1, h_theta_0)
            
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
865/40:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.01
x = population_of_the_city
y = profit
865/41: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
865/42: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
865/43: eq = h_theta_1 * x + h_theta_0
865/44:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.00000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        #print("ALFA: %s" %ALFA)
        if i % 500 == 0 or i == 1:
            plotRegressionLine(x, y, h_theta_1, h_theta_0)
            
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
865/45:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.01
x = population_of_the_city
y = profit
865/46: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = 0, h_theta_0 = 0, ALFA = ALFA)
866/1:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
866/2:
def plotRegressionLine(x, y, h_theta_1, h_theta_0):
    eq = h_theta_1*x + h_theta_0
    plt.figure(figsize=(10,6))
    plt.scatter(x, y, c="r")

    plt.title("Population vs Profit of a food truck")
    plt.xlabel("Population of a city in 10,000")
    plt.ylabel("Profit of a food truck in $10,000");

    plt.plot(x, eq, c="b")

    plt.legend(["Regression Line = %.3fx%.3f" %(h_theta_1, h_theta_0),"Training Data"])
866/3: data = open("data/ex1data1.txt", "r")
866/4:
population_of_the_city = []
profit = []

for line in data:
    line_splitted = line.split(",")
    population_of_the_city.append(np.float64(line_splitted[0]))
    profit.append(np.float64(line_splitted[1].replace("\n", "")))
866/5:
population_of_the_city = np.array(population_of_the_city)
profit = np.array(profit)
866/6: population_of_the_city
866/7: profit
866/8:
def h(x, h_theta_0 = 0, h_theta_1 = 0):
    
    return h_theta_0 + h_theta_1*x
866/9:
def CostFunction(x, y, y_hat):
    
    m = len(x)
    z = ((y_hat - y)**2)/2
    
    return sum(z)/m
866/10:
def GradientDescent(x, y, ALFA = 0.2, h_theta_0 = 0, h_theta_1 = 0):
    
    m = len(x)
    temp_h_theta_0 = h_theta_0 - (ALFA/m)*(sum(h(x = x,
                                                 h_theta_0 = h_theta_0,
                                                 h_theta_1 = h_theta_1) - y))
    
    temp_h_theta_1 = h_theta_1 - (ALFA/m)*(sum((h(x = x,
                                                  h_theta_0 = h_theta_0,
                                                  h_theta_1 = h_theta_1) - y)*x))
    
    return temp_h_theta_0, temp_h_theta_1
866/11:
def runLinearRegression(x, y, h_theta_1 = 0, h_theta_0 = 0, ALFA = 0.2):
    
    EPSILON = 0.00000000001
    cost_t_1 = 0
    for i in range(99**99):
        cost_t = cost_t_1
        y_hat = h(x = x, h_theta_0 = h_theta_0, h_theta_1 = h_theta_1)
        cost_t_1 = CostFunction(x = x, y = y, y_hat = y_hat)
        print("\n******%0.3f********" %cost_t_1)
        print("ho: {0}    h1: {1}".format(h_theta_0, h_theta_1))
        h_theta_0, h_theta_1 = GradientDescent(x = x, y = y, ALFA = ALFA,
                                               h_theta_0 = h_theta_0,
                                               h_theta_1 = h_theta_1)
        #print("ALFA: %s" %ALFA)
        if i % 500 == 0 or i == 1:
            plotRegressionLine(x, y, h_theta_1, h_theta_0)
            
        if abs(cost_t_1 - cost_t) < EPSILON:
            print("Algorithm converged, took %s iterations" %i)
            break
    
    return h_theta_1, h_theta_0
866/12:
h_theta_1 = 0
h_theta_0 = 0
ALFA= 0.01
x = population_of_the_city
y = profit
866/13: h_theta = runLinearRegression(x = x, y = y, h_theta_1 = -5, h_theta_0 = -5, ALFA = ALFA)
866/14: h_theta_1, h_theta_0 = h_theta[0], h_theta[1]
868/1:
x = None
y = None

x == y
868/2: id(x) == id(y)
868/3:
if x is None:
    print("yes")
    
if x == None:
    print("yes")
868/4: id(x)
868/5: id(y)
870/1:
from job_application_filter import *
from bs4 import BeautifulSoup
870/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
870/3: login.SignIn()
870/4: navigate.clickJobs()
870/5: navigate.clickUKJuniorDataScientist()
870/6: scrape.retrieveInfo()
871/1: import numpy as np
871/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
871/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def check_bet_amount(self):
        if self.bet <= self.money:
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money +=self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
871/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = []
        self.dcards = []
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
871/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.check_bet_amount()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
871/6:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)
                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
871/7: player = start_game()
872/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
872/2: hangman_my_solution.initGame()
872/3:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
872/4: hangman_my_solution.initGame()
873/1:
%load_ext autoreload
%autoreload 0.1

import hangman_my_solution
from hangman_my_solution import *
873/2: hangman_my_solution.initGame()
874/1:
%load_ext autoreload
%autoreload 0.1

from SeleniumFB import *
874/2: import re
874/3:
driver, data = InitialiseFacebook("https://www.facebook.com/")
data = {
     "name":"mcagriardic.ytu@gmail.com",
     "password":"amele123"
}
874/4: login = Login(driver, data)
881/1:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
        
    def __iterator__(self):
        return self
    
    def __next__
881/2:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
        
    def __iterator__(self):
        return self
    
    def __next__(self):
        self.current = self.low
        if self.current < self.high:
            return self.current
        self.current += 1
        raise StopIteration
881/3:
for c in IteratorProtocol(3,9):
    print(c)
881/4:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.current = self.low
        if self.current < self.high:
            return self.current
        self.current += 1
        raise StopIteration
881/5:
for c in IteratorProtocol(3,9):
    print(c)
881/6:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
        
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.low < self.high:
            return self.low
        self.low += 1
        raise StopIteration
881/7:
for c in IteratorProtocol(3,9):
    print(c)
882/1:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
        
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.low < self.high:
            return self.low
        self.low += 1
        raise StopIteration
882/2:
for c in IteratorProtocol(3,9):
    print(c)
882/3:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.low += 1
        if self.low < self.high:
            return self.low
        raise StopIteration
882/4:
for c in IteratorProtocol(3,9):
    print(c)
882/5:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.low += 1
        if self.low -1 < self.high:
            return self.low
        raise StopIteration
882/6:
for c in IteratorProtocol(3,9):
    print(c)
882/7:
for c in IteratorProtocol(3,9):
    print(c)
882/8:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low
        self.high = high
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.low += 1
        if self.low < self.high:
            return self.low
        raise StopIteration
882/9:
for c in IteratorProtocol(3,9):
    print(c)
882/10:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low -1
        self.high = high
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.low += 1
        if self.low < self.high:
            return self.low
        raise StopIteration
882/11:
for c in IteratorProtocol(3,9):
    print(c)
882/12:
class IteratorProtocol():
    
    def __init__(self, low, high):
        self.low = low - 1
        self.high = high + 1
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.low += 1
        if self.low < self.high:
            return self.low
        raise StopIteration
882/13:
for c in IteratorProtocol(3,9):
    print(c)
882/14:
class IteratorTest(object):
    
    def __init__(self, count):
        self.test_attribute = list(range(count))

#     def __iter__(self):
#         for index, number in enumerate(self.test_attribute, 1):
#             print(f"Element {index} is exhausted!")
#             if number is None:
#                 print("All iterables are exhausted!")
#                 break

    def __iter__(self):
        n = max(self.test_attribute)
        while n >= 0:
            yield n
            print(n)
            n -= 1
882/15: test = IteratorTest(10)
882/16: test.test_attribute
882/17:
class IteratorProtocol():
    
    def __init__(self, low, high, step=1):
        self.low = low - 1
        self.high = high + 1
        self.step = step
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.low += self.step
        if self.low < self.high:
            return self.low
        raise StopIteration
882/18:
for c in IteratorProtocol(3,9):
    print(c)
882/19:
for c in IteratorProtocol(3,9,2):
    print(c)
882/20:
for c in IteratorProtocol(3,9):
    print(c)
882/21: iterator_protocol_instance = IteratorProtocol(3,9)
882/22:
for c in iterator_protocol_instance:
    print(c)
882/23: iterator_protocol_instance.low
882/24:
class IteratorProtocol():
    
    def __init__(self, low, high, step=1):
        self.low = low - 1
        self.high = high + 1
        self.current = low -1
        self.step = step
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.current += self.step
        if self.current < self.high:
            return self.current
        raise StopIteration
882/25: iterator_protocol_instance = IteratorProtocol(3,9)
882/26:
for c in iterator_protocol_instance:
    print(c)
882/27: iterator_protocol_instance.low
882/28:
class IteratorProtocol():
    
    def __init__(self, low, high, step=1):
        self.low = low
        self.high = high + 1
        self.current = low -1
        self.step = step
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.current += self.step
        if self.current < self.high:
            return self.current
        raise StopIteration
882/29: iterator_protocol_instance = IteratorProtocol(3,9)
882/30:
for c in iterator_protocol_instance:
    print(c)
882/31: iterator_protocol_instance.low
882/32:
class IteratorProtocol():
    
    def __init__(self, low, high, step=1):
        self.low = low
        self.high = high + 1
        self.__current = low -1
        self.step = step
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.__current += self.step
        if self.__current < self.high:
            return self.__current
        raise StopIteration
882/33: iterator_protocol_instance = IteratorProtocol(3,9)
882/34:
for c in iterator_protocol_instance:
    print(c)
882/35: iterator_protocol_instance.low
882/36: iterator_protocol_instance.__current
883/1:
class IteratorProtocol(object):
    
    def __init__(self, low, high, step=1):
        self.low = low
        self.high = high + 1
        self.__current = low -1
        self.step = step
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.__current += self.step
        if self.__current < self.high:
            return self.__current
        raise StopIteration
883/2: iterator_protocol_instance = IteratorProtocol(3,9)
883/3:
for c in iterator_protocol_instance:
    print(c)
883/4:
class IteratorProtocol(object):
    
    def __init__(self, low, high, step=1):
        self.low = low
        self.high = high + 1
        self.__current = low -1
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        self.__current += self.step
        if self.__current < self.high:
            return self.__current
        raise StopIteration
883/5: iterator_protocol_instance = IteratorProtocol(3,9)
883/6:
for c in iterator_protocol_instance:
    print(c)
883/7: iterator_protocol_instance_w_step = IteratorProtocol(3,21,2)
883/8:
for c in iterator_protocol_instance_w_step:
    print(c)
883/9:
class IteratorProtocol(object):
    
    def __init__(self, low, high, step=1):
        self.low = low
        self.high = high + 1
        self.__current = low - step
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        self.__current += self.step
        if self.__current < self.high:
            return self.__current
        raise StopIteration
883/10: iterator_protocol_instance = IteratorProtocol(3,9)
883/11:
for c in iterator_protocol_instance:
    print(c)
883/12: iterator_protocol_instance_w_step = IteratorProtocol(3,21,2)
883/13:
for c in iterator_protocol_instance_w_step:
    print(c)
883/14:
class IteratorProtocol(object):
    
    def __init__(self, low, high, step=1):
        self.low = low
        self.high = high
        self.__current = low - step
        self.step = step

    def __iter__(self):
        return self

    def __next__(self):
        self.__current += self.step
        if self.__current < self.high:
            return self.__current
        raise StopIteration
883/15: iterator_protocol_instance = IteratorProtocol(3,9)
883/16:
for c in iterator_protocol_instance:
    print(c)
883/17: iterator_protocol_instance_w_step = IteratorProtocol(3,21,2)
883/18:
for c in iterator_protocol_instance_w_step:
    print(c)
884/1:
%load_ext autoreload
%autoreload 0.1

import hangman
from hangman import *
884/2: hangman_my_solution.initGame()
884/3: hangman.initGame()
890/1:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
890/2:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")
#adding the constant column

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]
x = ex2data1[:, :2]
y = ex2data1[:, -1]
890/3:
# fig = plt.figure(figsize=(10,8))
# ax = fig.add_subplot(111)
# ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
# plt.xlabel("Exam 1 Score")
# plt.ylabel("Exam 2 Score")
# plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
890/4:
class LogisticRegression:
    

    def __init__(self, x, y, has_constant=True):
        self.x = x
        self.y = y.reshape(len(x), 1)

        self._has_constant = has_constant
        self.m = len(x)
        self.n = (len(x.T) + 1) if has_constant else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        
        self._add_constant()
        self._initalise_θ()
  

    def _add_constant(self):
        if self._has_constant:
            constants = np.ones((self.m ,1))
            self.x = np.concatenate((constants, self.x), axis = 1)
            return x


    def _initalise_θ(self, weight_to_initialise=0):
        self.thetas = np.zeros(
            self.n
        ) + weight_to_initialise
        
        self._temp_thetas = self.thetas


    def h(self):
        e = np.exp(1)
        z = self.x.dot(self.thetas.reshape(-1, 1))
        return (1 / (1 + e**-z))
    

    def calculate_cost(self):
        return sum((self.y)*-1*np.log(self.h())+(1-self.y)*-1*np.log(1-self.h())) / self.m
        
    
    def gradient(self):
        grad =(1/self.m)*self.x.T.dot(self.h()-self.y)
        return(grad.flatten())
890/5:
class LogisticRegression:
    def __init__(self, lr=0.01, num_iter=100000, fit_intercept=True, verbose=False):
        self.lr = lr
        self.num_iter = num_iter
        self.fit_intercept = fit_intercept
    
    def __add_intercept(self, X):
        intercept = np.ones((X.shape[0], 1))
        return np.concatenate((intercept, X), axis=1)
    
    def __sigmoid(self, z):
        return 1 / (1 + np.exp(-z))
    def __loss(self, h, y):
        return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()
    
    def fit(self, X, y):
        if self.fit_intercept:
            X = self.__add_intercept(X)
        
        # weights initialization
        self.theta = np.zeros(X.shape[1])
        
        for i in range(self.num_iter):
            z = np.dot(X, self.theta)
            h = self.__sigmoid(z)
            gradient = np.dot(X.T, (h - y)) / y.size
            self.theta -= self.lr * gradient
            
            if(self.verbose == True and i % 10000 == 0):
                z = np.dot(X, self.theta)
                h = self.__sigmoid(z)
                print(f'loss: {self.__loss(h, y)} \t')
    
    def predict_prob(self, X):
        if self.fit_intercept:
            X = self.__add_intercept(X)
    
        return self.__sigmoid(np.dot(X, self.theta))
    
    def predict(self, X, threshold):
        return self.predict_prob(X) >= threshold
890/6: LogisticRegression.fit(X, y)
890/7: LogisticRegression.fit(x, y)
890/8:
log = LogisticRegression()
.fit(x, y)
890/9:
log = LogisticRegression()
log.fit(x, y)
890/10:
class LogisticRegression:
    def __init__(self, lr=0.01, num_iter=100000, fit_intercept=True, verbose=False):
        self.lr = lr
        self.num_iter = num_iter
        self.fit_intercept = fit_intercept
        self.verbose = verbose
    
    def __add_intercept(self, X):
        intercept = np.ones((X.shape[0], 1))
        return np.concatenate((intercept, X), axis=1)
    
    def __sigmoid(self, z):
        return 1 / (1 + np.exp(-z))
    def __loss(self, h, y):
        return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()
    
    def fit(self, X, y):
        if self.fit_intercept:
            X = self.__add_intercept(X)
        
        # weights initialization
        self.theta = np.zeros(X.shape[1])
        
        for i in range(self.num_iter):
            z = np.dot(X, self.theta)
            h = self.__sigmoid(z)
            gradient = np.dot(X.T, (h - y)) / y.size
            self.theta -= self.lr * gradient
            
            if(self.verbose == True and i % 10000 == 0):
                z = np.dot(X, self.theta)
                h = self.__sigmoid(z)
                print(f'loss: {self.__loss(h, y)} \t')
    
    def predict_prob(self, X):
        if self.fit_intercept:
            X = self.__add_intercept(X)
    
        return self.__sigmoid(np.dot(X, self.theta))
    
    def predict(self, X, threshold):
        return self.predict_prob(X) >= threshold
890/11:
log = LogisticRegression()
log.fit(x, y)
890/12: log.theta
890/13: from scipy.optimize import minimize
890/14:
thetas = 
m = y.size

def sigmoid(z):
    return(1 / (1 + np.exp(-z)))

def calculate_cost(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    J =  (sum((y)*-1*np.log(h)+(1-y)*-1*np.log(1-h)) / m)
    
    if np.isnan(J[0]):
        return(np.inf)
    return(J[0])

def gradient(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    grad = (1/m)*x.T.dot(h-y)
    return(grad.flatten())
890/15:
thetas = np.zeros(3)
m = y.size

def sigmoid(z):
    return(1 / (1 + np.exp(-z)))

def calculate_cost(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    J =  (sum((y)*-1*np.log(h)+(1-y)*-1*np.log(1-h)) / m)
    
    if np.isnan(J[0]):
        return(np.inf)
    return(J[0])

def gradient(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    grad = (1/m)*x.T.dot(h-y)
    return(grad.flatten())
890/16: thetas
890/17:
thetas = np.zeros(3)
m = y.size

def sigmoid(z):
    return(1 / (1 + np.exp(-z)))

def calculate_cost(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    J =  (sum((y)*-1*np.log(h)+(1-y)*-1*np.log(1-h)) / m)
    
    if np.isnan(J[0]):
        return(np.inf)
    return(J[0])

def gradient(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    grad = (1/m)*x.T.dot(h-y)
    return(grad.flatten())
890/18:
minimize(
    fun=calculate_cost,
    x0=thetas,
    args=(x,y),
    method=None,
    jac=gradient,
    options={'maxiter':400}
)
890/19:
class LogisticRegression:
    def __init__(self, lr=0.01, num_iter=100000, fit_intercept=True, verbose=False):
        self.lr = lr
        self.num_iter = num_iter
        self.fit_intercept = fit_intercept
        self.verbose = verbose
    
    def __add_intercept(self, X):
        intercept = np.ones((X.shape[0], 1))
        return np.concatenate((intercept, X), axis=1)
    
    def __sigmoid(self, z):
        return 1 / (1 + np.exp(-z))
    def __loss(self, h, y):
        return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()
    
    def fit(self, X, y):
        if self.fit_intercept:
            X = self.__add_intercept(X)
        
        # weights initialization
        self.theta = np.zeros(X.shape[1])
        
        for i in range(self.num_iter):
            z = np.dot(X, self.theta)
            h = self.__sigmoid(z)
            gradient = np.dot(X.T, (h - y)) / y.size
            self.theta -= self.lr * gradient
            
            if(self.verbose == True and i % 10000 == 0):
                z = np.dot(X, self.theta)
                h = self.__sigmoid(z)
                print(f'loss: {self.__loss(h, y)} \t')
    
    def predict_prob(self, X):
        if self.fit_intercept:
            X = self.__add_intercept(X)
    
        return self.__sigmoid(np.dot(X, self.theta))
    
    def predict(self, X, threshold):
        return self.predict_prob(X) >= threshold
890/20:
log = LogisticRegression()
'log.fit(x, y)
890/21:
log = LogisticRegression()
'log.fit(x, y)''
890/22:
log = LogisticRegression()
'log.fit(x, y)'
890/23: log = LogisticRegression()
890/24: _log.__add_intercept(x)
890/25:
intercept = np.ones((x.shape[0], 1))
x = np.concatenate((intercept, x), axis=1)
890/26: x
890/27:
thetas = np.zeros(3)
m = y.size

def sigmoid(z):
    return(1 / (1 + np.exp(-z)))

def calculate_cost(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    J =  (sum((y)*-1*np.log(h)+(1-y)*-1*np.log(1-h)) / m)
    
    if np.isnan(J[0]):
        return(np.inf)
    return(J[0])

def gradient(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    grad = (1/m)*x.T.dot(h-y)
    return(grad.flatten())
890/28:
minimize(
    fun=calculate_cost,
    x0=thetas,
    args=(x,y),
    method=None,
    jac=gradient,
    options={'maxiter':400}
)
891/1:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
891/2:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")
#adding the constant column

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]
x = ex2data1[:, :2]
y = ex2data1[:, -1]
891/3:
class LogisticRegression:
    def __init__(self, lr=0.01, num_iter=100000, fit_intercept=True, verbose=False):
        self.lr = lr
        self.num_iter = num_iter
        self.fit_intercept = fit_intercept
        self.verbose = verbose
    
    def __add_intercept(self, X):
        intercept = np.ones((X.shape[0], 1))
        return np.concatenate((intercept, X), axis=1)
    
    def __sigmoid(self, z):
        return 1 / (1 + np.exp(-z))
    def __loss(self, h, y):
        return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()
    
    def fit(self, X, y):
        if self.fit_intercept:
            X = self.__add_intercept(X)
        
        # weights initialization
        self.theta = np.zeros(X.shape[1])
        
        for i in range(self.num_iter):
            z = np.dot(X, self.theta)
            h = self.__sigmoid(z)
            gradient = np.dot(X.T, (h - y)) / y.size
            self.theta -= self.lr * gradient
            
            if(self.verbose == True and i % 10000 == 0):
                z = np.dot(X, self.theta)
                h = self.__sigmoid(z)
                print(f'loss: {self.__loss(h, y)} \t')
    
    def predict_prob(self, X):
        if self.fit_intercept:
            X = self.__add_intercept(X)
    
        return self.__sigmoid(np.dot(X, self.theta))
    
    def predict(self, X, threshold):
        return self.predict_prob(X) >= threshold
891/4:
intercept = np.ones((x.shape[0], 1))
x = np.concatenate((intercept, x), axis=1)
891/5: x
891/6: x.shape[:]
891/7:
x.shape[:]
y
891/8:
x.shape[:]
y.shape[:]
891/9:
x.shape[:]
y = y.reshape(-1, 1)
891/10: from scipy.optimize import minimize
891/11:
thetas = np.zeros(3)
m = y.size

def sigmoid(z):
    return(1 / (1 + np.exp(-z)))

def calculate_cost(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    J =  (sum((y)*-1*np.log(h)+(1-y)*-1*np.log(1-h)) / m)
    
    if np.isnan(J[0]):
        return(np.inf)
    return(J[0])

def gradient(thetas, x, y):
    h = sigmoid(x.dot(thetas.reshape(-1, 1)))
    grad = (1/m)*x.T.dot(h-y)
    return(grad.flatten())
891/12:
minimize(
    fun=calculate_cost,
    x0=thetas,
    args=(x,y),
    method=None,
    jac=gradient,
    options={'maxiter':400}
)
891/13:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
891/14:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")
#adding the constant column

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]
x = ex2data1[:, :2]
y = ex2data1[:, -1]
891/15:
# fig = plt.figure(figsize=(10,8))
# ax = fig.add_subplot(111)
# ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
# plt.xlabel("Exam 1 Score")
# plt.ylabel("Exam 2 Score")
# plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
891/16:
class LogisticRegression:
    def __init__(self, lr=0.01, num_iter=100000, fit_intercept=True, verbose=False):
        self.lr = lr
        self.num_iter = num_iter
        self.fit_intercept = fit_intercept
        self.verbose = verbose
    
    def __add_intercept(self, X):
        intercept = np.ones((X.shape[0], 1))
        return np.concatenate((intercept, X), axis=1)
    
    def __sigmoid(self, z):
        return 1 / (1 + np.exp(-z))
    def __loss(self, h, y):
        return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()
    
    def fit(self, X, y):
        if self.fit_intercept:
            X = self.__add_intercept(X)
        
        # weights initialization
        self.theta = np.zeros(X.shape[1])
        
        for i in range(self.num_iter):
            z = np.dot(X, self.theta)
            h = self.__sigmoid(z)
            gradient = np.dot(X.T, (h - y)) / y.size
            self.theta -= self.lr * gradient
            
            if(self.verbose == True and i % 10000 == 0):
                z = np.dot(X, self.theta)
                h = self.__sigmoid(z)
                print(f'loss: {self.__loss(h, y)} \t')
    
    def predict_prob(self, X):
        if self.fit_intercept:
            X = self.__add_intercept(X)
    
        return self.__sigmoid(np.dot(X, self.theta))
    
    def predict(self, X, threshold):
        return self.predict_prob(X) >= threshold
891/17:
log = LogisticRegression()
log.fit(x, y)
891/18: log.theta
891/19:
log = LogisticRegression(verbose = True)
log.fit(x, y)
891/20: log.theta
891/21:
log = LogisticRegression(lr=0.001, verbose = True)
log.fit(x, y)
891/22: log.theta
891/23: log.theta.shape[:]
891/24: test_rows = np.array([1,2,3])
891/25: test_rows
891/26: test_rows = np.array([1,2,3]).reshape(3, 1)
891/27: test_rows
891/28:
test_rows = np.array([1,2,3]).reshape(3, 1)
test_columns = np.array([4,5,6]).reshape(1, 3)
891/29: test_rows, test_columns
891/30:
test_rows = np.array([1,2,3]).reshape(3, 1)
test_columns = np.array([4,5,6]).reshape(1, 3)
891/31: test_rows @ test_columns
891/32: test_rows * test_rows
891/33:
class LogisticRegression:
    

    def __init__(self, X, y, fit_intercept=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self.__fit_intercept = fit_intercept
        self.m = len(X)
        self.n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        
        self._add_constant()
        self._initalise_θ()
  

    def _add_constant(self):
        if self._has_constant:
            constants = np.ones((self.m ,1))
            self.x = np.concatenate((constants, self.x), axis = 1)
            return x


    def _initalise_θ(self, weight_to_initialise=0):
        self.thetas = np.zeros(
            self.n
        ) + weight_to_initialise
        
        self._temp_thetas = self.thetas


    def h(self):
        e = np.exp(1)
        z = self.x.dot(self.thetas.reshape(-1, 1))
        return (1 / (1 + e**-z))
    

    def calculate_cost(self):
        return sum((self.y)*-1*np.log(self.h())+(1-self.y)*-1*np.log(1-self.h())) / self.m
        
    
    def gradient(self):
        grad =(1/self.m)*self.x.T.dot(self.h()-self.y)
        return(grad.flatten())
891/34: np.exp
891/35: np.exp()
891/36: np.exp(1)
891/37: np.exp(2)
891/38:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)


    def gradient(self):
        grad =(1/self.m)*self.x.T.dot(self.h()-self.y)
        return(grad.flatten())
891/39: log = LogisticRegression()
891/40:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")
#adding the constant column

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]
X = ex2data1[:, :2]
y = ex2data1[:, -1]
891/41:
# fig = plt.figure(figsize=(10,8))
# ax = fig.add_subplot(111)
# ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
# plt.xlabel("Exam 1 Score")
# plt.ylabel("Exam 2 Score")
# plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
891/42:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)


    def gradient(self):
        grad =(1/self.m)*self.x.T.dot(self.h()-self.y)
        return(grad.flatten())
891/43: log = LogisticRegression(X, y)
891/44:
log = LogisticRegression(X, y)
log.thetas
891/45: log = LogisticRegression(X, y)
891/46: log = LogisticRegression(X, y)
891/47: log._calculate_cost
891/48: log._calculate_cost()
891/49:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)[0]


    def gradient(self):
        grad =(1/self.m)*self.x.T.dot(self.h()-self.y)
        return(grad.flatten())
891/50: log = LogisticRegression(X, y)
891/51: log._calculate_cost()
891/52:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)[0]


    def gradient(self):
        grad = (1 / self._m) * self.X.T @ (self.h()-self.y)
        return(grad.flatten())
891/53: log._gradient()
891/54:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self.h()-self.y)
        return(grad.flatten())
891/55: log = LogisticRegression(X, y)
891/56: log._calculate_cost()
891/57: log._gradient()
891/58:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad.flatten())
891/59: log = LogisticRegression(X, y)
891/60: log._calculate_cost()
891/61: log._gradient()
891/62: log = LogisticRegression(X, y, weights_to_initialise=1)
891/63: log._calculate_cost()
891/64: log.thetas
891/65:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 10e-05
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad.flatten())
891/66:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-05
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad.flatten())
891/67:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5
        return (sum(-1 * (
            (self.y) * np.log(self._h())
            + (1 - self.y) * np.log(1 - self._h()))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad.flatten())
891/68:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad.flatten())
891/69: log = LogisticRegression(X, y, weights_to_initialise=1)
891/70: log._calculate_cost()
891/71:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 0 ! #
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad.flatten())
891/72: log = LogisticRegression(X, y, weights_to_initialise=1)
891/73:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 0 #
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad.flatten())
891/74: log = LogisticRegression(X, y, weights_to_initialise=1)
891/75: log._calculate_cost()
891/76:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon))
                  ) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad.flatten())
891/77: log = LogisticRegression(X, y, weights_to_initialise=1)
891/78: log._calculate_cost()
891/79: log._gradient()
891/80:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        )) / self._m)[0]


    def _gradient(self):
        grad = (1 / self._m) * self.X.T @ (self._h()-self.y)
        return(grad)
    
    def fit(self):
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()
            self.thetas = self.thetas - self.alfa * self._gradient
891/81: log._gradient()
891/82: log = LogisticRegression(X, y, weights_to_initialise=1)
891/83: log._calculate_cost()
891/84: log._gradient()
891/85:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        )) / self._m)


    def _gradient(self):
        return (1 / self._m) * self.X.T @ (self._h() - self.y) 


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}")
                print(f"Weights: {self.thetas}")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/86: log = LogisticRegression(X, y, weights_to_initialise=0)
891/87: log = LogisticRegression(X, y)
891/88: log._calculate_cost()
891/89: log._gradient()
891/90: log.fit()
891/91: log._gradient()
891/92: 0.01* log._gradient()
891/93: log.thetas
891/94: log.thetas = 0.01 * log._gradient().flatten()
891/95:
log.thetas = 0.01 * log._gradient().flatten()
log.thetas
891/96: log._gradient()
891/97: log._gradient() *  0.01
891/98:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        )) / self._m)


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}")
                print(f"Weights: {self.thetas}")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/99: log = LogisticRegression(X, y)
891/100: log._calculate_cost()
891/101:
log.thetas = 0.01 * log._gradient().flatten()
log.thetas
891/102: log.fit()
891/103:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        )) / self._m)


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}")
                print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/104: log = LogisticRegression(X, y)
891/105: log._calculate_cost()
891/106:
log.thetas = 0.01 * log._gradient().flatten()
log.thetas
891/107: log.fit()
891/108: log._calculate_cost()
891/109:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = len(X)
        self._n = (len(X.T) + 1) if fit_intercept else len(x.T)
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return (sum(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        )) / self._m)


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost[0]}")
                print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/110: log = LogisticRegression(X, y, alfa=0.001)
891/111: log._calculate_cost()
891/112: log.fit()
891/113:
class LogisticRegression:
    def __init__(self, lr=0.01, num_iter=100000, fit_intercept=True, verbose=False):
        self.lr = lr
        self.num_iter = num_iter
        self.fit_intercept = fit_intercept
        self.verbose = verbose
    
    def __add_intercept(self, X):
        intercept = np.ones((X.shape[0], 1))
        return np.concatenate((intercept, X), axis=1)
    
    def __sigmoid(self, z):
        return 1 / (1 + np.exp(-z))
    def __loss(self, h, y):
        return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()
    
    def fit(self, X, y):
        if self.fit_intercept:
            X = self.__add_intercept(X)
        
        # weights initialization
        self.theta = np.zeros(X.shape[1])
        
        for i in range(self.num_iter):
            z = np.dot(X, self.theta)
            h = self.__sigmoid(z)
            gradient = np.dot(X.T, (h - y)) / y.size
            self.theta -= self.lr * gradient
            
            if(self.verbose == True and i % 10000 == 0):
                z = np.dot(X, self.theta)
                h = self.__sigmoid(z)
                print(f'loss: {self.__loss(h, y)} \t')
    
    def predict_prob(self, X):
        if self.fit_intercept:
            X = self.__add_intercept(X)
    
        return self.__sigmoid(np.dot(X, self.theta))
    
    def predict(self, X, threshold):
        return self.predict_prob(X) >= threshold
891/114:
log = LogisticRegression(lr=0.001, verbose = True)
log.fit(x, y)
891/115:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost[0]}\n")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/116: log = LogisticRegression(X, y, alfa=0.001)
891/117: log._calculate_cost()
891/118: log.fit()
891/119:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}\n")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/120: log = LogisticRegression(X, y, alfa=0.001)
891/121: log._calculate_cost()
891/122: log.fit()
891/123:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}\n")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/124: log = LogisticRegression(X, y, alfa=0.01)
891/125: log._calculate_cost()
891/126: log.fit()
891/127:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.001, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}\n")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/128: log = LogisticRegression(X, y, alfa=0.01)
891/129: log._calculate_cost()
891/130: log.fit()
891/131:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.01, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}\n")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/132: log = LogisticRegression(X, y, alfa=0.001)
891/133: log._calculate_cost()
891/134: log.fit()
891/135:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.001, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-7
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}\n")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/136:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.001, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-9
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if self._verbose:
                print(f"COST: {initial_cost}")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/137: log = LogisticRegression(X, y, alfa=0.001)
891/138: log._calculate_cost()
891/139: log.fit()
891/140: log.thetas
891/141:
class LogisticRegression:
    def __init__(self, lr=0.01, num_iter=100000, fit_intercept=True, verbose=False):
        self.lr = lr
        self.num_iter = num_iter
        self.fit_intercept = fit_intercept
        self.verbose = verbose
    
    def __add_intercept(self, X):
        intercept = np.ones((X.shape[0], 1))
        return np.concatenate((intercept, X), axis=1)
    
    def __sigmoid(self, z):
        return 1 / (1 + np.exp(-z))
    def __loss(self, h, y):
        return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()
    
    def fit(self, X, y):
        if self.fit_intercept:
            X = self.__add_intercept(X)
        
        # weights initialization
        self.theta = np.zeros(X.shape[1])
        
        for i in range(self.num_iter):
            z = np.dot(X, self.theta)
            h = self.__sigmoid(z)
            gradient = np.dot(X.T, (h - y)) / y.size
            self.theta -= self.lr * gradient
            
            if(self.verbose == True and i % 10000 == 0):
                z = np.dot(X, self.theta)
                h = self.__sigmoid(z)
                print(f'loss: {self.__loss(h, y)} \t')
    
    def predict_prob(self, X):
        if self.fit_intercept:
            X = self.__add_intercept(X)
    
        return self.__sigmoid(np.dot(X, self.theta))
    
    def predict(self, X, threshold):
        return self.predict_prob(X) >= threshold
891/142:
log = LogisticRegression(lr=0.001, verbose = True)
log.fit(x, y)
891/143: log.theta
891/144:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.001, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-9
        for i in range(self._num_iter):
            initial_cost = self._calculate_cost()

            if (self._verbose) and (i % 10000 == 0):
                print(f"COST: {initial_cost}")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
891/145: log = LogisticRegression(X, y, alfa=0.001)
891/146: log._calculate_cost()
891/147: log.fit()
892/1:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.001, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-9
        for i in range(self._num_iter):
            #initial_cost = self._calculate_cost()

            if (self._verbose) and (i % 10000 == 0):
                print(f"COST: {self._calculate_cost()}")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            #final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
892/2:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
892/3:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")
#adding the constant column

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]
X = ex2data1[:, :2]
y = ex2data1[:, -1]
892/4:
# fig = plt.figure(figsize=(10,8))
# ax = fig.add_subplot(111)
# ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
# plt.xlabel("Exam 1 Score")
# plt.ylabel("Exam 2 Score")
# plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
892/5:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.001, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-9
        for i in range(self._num_iter):
            #initial_cost = self._calculate_cost()

            if (self._verbose) and (i % 10000 == 0):
                print(f"COST: {self._calculate_cost()}")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            #final_cost = self._calculate_cost()

            if np.abs(final_cost - initial_cost) < EPSILON:
                print("\nConverged!\n")
                break
892/6: log = LogisticRegression(X, y, alfa=0.001)
892/7: log._calculate_cost()
892/8: log.fit()
892/9:
class LogisticRegression:
    

    def __init__(self, X, y, alfa=0.001, num_iter=100000, fit_intercept=True, weights_to_initialise=0, verbose=True):
        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        e = np.exp(1)
        return (1 / (1 + e**-z))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        EPSILON = 1e-9
        for i in range(self._num_iter):
            #initial_cost = self._calculate_cost()

            if (self._verbose) and (i % 10000 == 0):
                print(f"COST: {self._calculate_cost()}")
                #print(f"Weights: {self.thetas}\n")

            self.thetas -= self._alfa * self._gradient()
            #final_cost = self._calculate_cost()

#             if np.abs(final_cost - initial_cost) < EPSILON:
#                 print("\nConverged!\n")
#                 break
892/10: log = LogisticRegression(X, y, alfa=0.001)
892/11: log._calculate_cost()
892/12: log.fit()
892/13: log = LogisticRegression(X, y, alfa=0.001, num_iter=10e10)
892/14: log._calculate_cost()
892/15: log.fit()
892/16: log = LogisticRegression(X, y, alfa=0.001, num_iter=10**10)
892/17: log._calculate_cost()
892/18: log.fit()
892/19:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
892/20: log = LogisticRegression(X, y, alfa=0.001, num_iter=10**8)
892/21: log._calculate_cost()
892/22: log.fit()
893/1:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
893/2: log = LogisticRegression(X, y, alfa=0.001, num_iter=10**8)
893/3:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
893/4:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")
#adding the constant column

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]
X = ex2data1[:, :2]
y = ex2data1[:, -1]
893/5:
# fig = plt.figure(figsize=(10,8))
# ax = fig.add_subplot(111)
# ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
# plt.xlabel("Exam 1 Score")
# plt.ylabel("Exam 2 Score")
# plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
893/6:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        return np.mean(-1 * (
            (self.y) * np.log(self._h() + epsilon)
            + (1 - self.y) * np.log(1 - self._h() + epsilon)
        ))


    def _gradient(self):
        return ((1 / self._m) * self.X.T @ (self._h() - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
893/7: log = LogisticRegression(X, y, alfa=0.001, num_iter=10**8)
893/8: log._calculate_cost()
893/9: log.fit()
893/10: log.thetas
893/11:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X, y, alfa=0.001, num_iter=10**8, weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716])
893/12:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X, y, alfa=0.001, num_iter=10**8, weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
893/13: log._calculate_cost()
893/14: log.fit()
894/1:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
894/2:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/3:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
894/4:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")
#adding the constant column

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]
X = ex2data1[:, :2]
y = ex2data1[:, -1]
894/5:
# fig = plt.figure(figsize=(10,8))
# ax = fig.add_subplot(111)
# ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
# plt.xlabel("Exam 1 Score")
# plt.ylabel("Exam 2 Score")
# plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
894/6:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
894/7:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/8: log._calculate_cost()
894/9: log.thetas
894/10: X
894/11: log.X
894/12: log.X[0]
894/13: log.X[0].shape[:]
894/14: log.X[0].reshape(-1, 1)
894/15: log.X[0].reshape(3, 1)
894/16: log.thetas.reshape(1,3)
894/17: log.thetas.reshape(1,3) @ log.X[0].reshape(3, 1)
894/18: log._sigmoid(log.thetas.reshape(1,3) @ log.X[0].reshape(3, 1))
894/19: log.X[0] @ log.thetas
894/20: log.X @ log.thetas
894/21: log._sigmoid(log.X @ log.thetas)
894/22: log._sigmoid(log.X @ log.thetas)*100
894/23:
for element in log._sigmoid(log.X @ log.thetas)*100:
    print(element/)
894/24:
for element in log._sigmoid(log.X @ log.thetas)*100:
    print(element)
894/25: check_specific_instance=(False,None)
894/26:
check_specific_instance=(False,None)
check_specific_instance == True
894/27:
check_specific_instance=(False,None)
check_specific_instance == False
894/28:
check_specific_instance=(False,None)
check_specific_instance.index(0)
894/29:
check_specific_instance=(False,None)
check_specific_instance[0]
894/30:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return prob_matrix[index]
        return prob_matrix
894/31:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return prob_matrix[index]
        return prob_matrix
894/32:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/33: log.predict_prob()
894/34: log.predict_prob((True, 5))
894/35: log.predict_prob
894/36: log.predict_prob()
894/37: log.predict_prob()[5~]
894/38: log.predict_prob()[5]
894/39:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return prob_matrix[index] * 100
        return prob_matrix
894/40:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/41: log._calculate_cost()
894/42: log.predict_prob((True, 5))
894/43:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return "Probability of Being Admitted %.3f" % (prob_matrix[index] * 100)
        return prob_matrix
894/44:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/45: log._calculate_cost()
894/46: log.predict_prob((True, 5))
894/47:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return "Probability of Being Admitted: %.3f%" % (prob_matrix[index] * 100)
        return prob_matrix
894/48:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/49: log._calculate_cost()
894/50: log.predict_prob((True, 5))
894/51:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return "Probability of Being Admitted: %.3f\%" % (prob_matrix[index] * 100)
        return prob_matrix
894/52:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/53: log._calculate_cost()
894/54: log.predict_prob((True, 5))
894/55:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return "Probability of Being Admitted: %.3f %" % (prob_matrix[index] * 100)
        return prob_matrix
894/56:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/57: log._calculate_cost()
894/58: log.predict_prob((True, 5))
894/59:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return "Probability of Being Admitted: %.3f %%" % (prob_matrix[index] * 100)
        return prob_matrix
894/60:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/61: log._calculate_cost()
894/62: log.predict_prob((True, 5))
894/63:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            return "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        return prob_matrix
894/64:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/65: log._calculate_cost()
894/66: log.predict_prob((True, 5))
894/67:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            exam_scores = f"Exam Score 1: {self.X[index, 1]}\nExam Score 2: {self.X[index, 2]}"
            probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        return prob_matrix
894/68:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/69: log._calculate_cost()
894/70: log.predict_prob((True, 5))
894/71:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            exam_scores = f"Exam Score 1: {self.X[index, 1]}\nExam Score 2: {self.X[index, 2]}"
            probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
            print(exam_scores, probability)
        return prob_matrix
894/72:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/73: log._calculate_cost()
894/74: log.predict_prob((True, 5))
894/75:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            exam_scores = f"Exam Score 1: {self.X[index, 1]}\nExam Score 2: {self.X[index, 2]}\n"
            probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
            print(exam_scores, probability)
        return prob_matrix
894/76:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/77: log._calculate_cost()
894/78: log.predict_prob((True, 5))
894/79:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            exam_scores = f"Exam Score 1: {self.X[index, 1]}\nExam Score 2: {self.X[index, 2]}\n"
            probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
            print(exam_scores)
            print(probability)
        return prob_matrix
894/80:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/81: log._calculate_cost()
894/82: log.predict_prob((True, 5))
894/83:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            exam_scores = f"Exam Score 1: {self.X[index, 1]}\nExam Score 2: {self.X[index, 2]}"
            probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
            print(exam_scores)
            print(probability)
        return prob_matrix
894/84:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/85: log._calculate_cost()
894/86: log.predict_prob((True, 5))
894/87:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            exam_scores = f"Exam Score 1: {self.X[index, 1]}\nExam Score 2: {self.X[index, 2]}"
            probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
            print(exam_scores); print(probability)
            return None
        return prob_matrix
894/88:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/89: log._calculate_cost()
894/90: log.predict_prob((True, 5))
894/91: log.predict_prob((True, 6))
894/92: log.predict_prob((True, 7))
894/93: log.predict_prob((True, 8))
894/94: log.predict_prob((True, 9))
894/95: log.predict_prob((True, 10))
894/96: log.predict_prob((True, 11))
894/97:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self, check_specific_instance=(False,None)):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        if check_specific_instance[0]:
            index = check_specific_instance[1]
            exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
            probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
            print(exam_scores); print(probability)
            return None
        return prob_matrix
894/98:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/99: log._calculate_cost()
894/100: log.predict_prob((True, 11))
894/101: log.predict_prob((True, 55))
894/102:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
894/103:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        pass
894/104: log.predict_prob_single_instance(55)
894/105:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        pass
894/106:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/107: log._calculate_cost()
894/108: log.predict_prob_single_instance(55)
894/109: log.predict_prob_single_instance(25)
894/110: log.predict_prob(25)
894/111: log.predict_prob()
894/112: log.predict_prob_single_instance()
894/113: log.predict_prob_single_instance(10)
894/114: log.predict_prob()
894/115: log.predict_prob() > 0.5
894/116: (log.predict_prob() > 0.5)
894/117:
def func(array):
    for element in array:
        if element: element = "Admitted"
        else:       element = "Not Admitted"
894/118: (log.predict_prob() > 0.5).map(func)
894/119: np.vectorize(func)((log.predict_prob() > 0.5))
894/120:
for element in (log.predict_prob() > 0.5):
    print(element)
894/121:
TF = (log.predict_prob() > 0.5)
for index, element in enumerate(TF):
    if element: TF[index] = "Admitted"
    else:       TF[index] = "Not Admitted"
894/122: TF
894/123:
TF = (log.predict_prob() > 0.5)
# for index, element in enumerate(TF):
#     if element: TF[index] = "Admitted"
#     else:       TF[index] = "Not Admitted"
894/124: TF
894/125:
TF = (log.predict_prob() > 0.5)
for index, element in enumerate(TF):
    if element is True: TF[index] = "Admitted"
    else:       TF[index] = "Not Admitted"
894/126: TF
894/127: .map(func)
894/128:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = "Admitted"
        probabilities[probabilities <= 0.5] = "Not Admitted"
        return probabilities
894/129:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/130: log.predict()
894/131:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = "Admitted"
        probabilities[probabilities <= 0.5] = "Not Admitted"
        return probabilities
894/132:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/133: log._calculate_cost()
894/134: log.predict()
894/135:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        probabilities = self.predict_prob()
        return probabilities
        probabilities[probabilities > 0.5] = "Admitted"
        probabilities[probabilities <= 0.5] = "Not Admitted"
        return probabilities
894/136: log._calculate_cost()
894/137: log.predict()
894/138:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        probabilities = self.predict_prob()
        return probabilities
        probabilities[probabilities > 0.5] = "Admitted"
        probabilities[probabilities <= 0.5] = "Not Admitted"
        return probabilities
894/139:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/140: log._calculate_cost()
894/141: log.predict()
894/142: probabilities = log.predict()
894/143: probabilities[probabilities > 0.5]
894/144: probabilities[probabilities > 0.5] = "Admitted"
894/145:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        probabilities = self.predict_prob()
        return probabilities
        probabilities[probabilities > 0.5] = 0
        probabilities[probabilities <= 0.5] = 1
        return probabilities
894/146:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/147: log._calculate_cost()
894/148: probabilities = log.predict()
894/149:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = 0
        probabilities[probabilities <= 0.5] = 1
        return probabilities
894/150:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/151: log._calculate_cost()
894/152: probabilities = log.predict()
894/153:
probabilities = log.predict()
probabilities
894/154:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        probabilities = self.predict_prob()
        return probabilities
        probabilities[probabilities > 0.5] = 0
        probabilities[probabilities <= 0.5] = 1
        return probabilities
894/155:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/156: log._calculate_cost()
894/157:
probabilities = log.predict()
probabilities
894/158:
probabilities = log.predict()
[probability = 1 if probability > 0.5 else probability = 0 for probability in probabilities]
894/159:
probabilities = log.predict()
[(probability = 1) if probability > 0.5 else (probability = 0) for probability in probabilities]
894/160: probabilities = log.predict()
894/161: probabilities
894/162: probabilities[probabilities > 0.5]
894/163: probabilities[probabilities > 0.5] = 0
894/164: probabilities
894/165:
probabilities[probabilities > 0.5] = 0
probabilities[probabilities <= 0.5] = 1
894/166: probabilities = log.predict()
894/167: probabilities
894/168:
probabilities[probabilities > 0.5] = 0
probabilities[probabilities <= 0.5] = 1
894/169: probabilities
894/170: probabilities = log.predict()
894/171:
probabilities[probabilities > 0.5] = 1
probabilities[probabilities <= 0.5] = 0
894/172: probabilities
894/173:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
894/174:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")
#adding the constant column

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]
X = ex2data1[:, :2]
y = ex2data1[:, -1]
894/175:
# fig = plt.figure(figsize=(10,8))
# ax = fig.add_subplot(111)
# ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
# plt.xlabel("Exam 1 Score")
# plt.ylabel("Exam 2 Score")
# plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
894/176:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)
                
    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)
    
    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)

    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = 1
        probabilities[probabilities <= 0.5] = 0
        return probabilities
894/177:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**8,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
894/178: log._calculate_cost()
894/179: probabilities = log.predict()
894/180: probabilities
896/1: from scipy import optimize
897/1:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
897/2:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]

X = ex2data1[:, :2]
y = ex2data1[:, -1]
897/3:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
897/4:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)


    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)


    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)


    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = 1
        probabilities[probabilities <= 0.5] = 0
        return probabilities
897/5:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**6,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
897/6: log._calculate_cost()
897/7: probabilities = log.predict()
897/8: log.fit()
901/1:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
901/2:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]

X = ex2data1[:, :2]
y = ex2data1[:, -1]
901/3:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
901/4:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)


    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)


    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)


    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = 1
        probabilities[probabilities <= 0.5] = 0
        return probabilities
901/5:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**6,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
901/6: log._calculate_cost()
901/7: probabilities = log.predict()
901/8:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
901/9: np.array([np.min(X[:,1]), np.max(X[:,1])])
901/10: boundary_ys = (-1/log.theta[2])*(log.theta[0] + log.theta[1]*boundary_xs)
901/11: boundary_ys = (-1/log.thetas[2])*(log.thetas[0] + log.thetas[1]*boundary_xs)
901/12: boundary_xs = np.array([np.min(X[:,1]), np.max(X[:,1])])
901/13: boundary_ys = (-1/log.thetas[2])*(log.thetas[0] + log.thetas[1]*boundary_xs)
901/14: boundary_ys
901/15: boundary_xs
901/16: plt.plot(boundary_xs,boundary_ys,'b-',label='Decision Boundary')
901/17:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted")
plt.plot(boundary_xs,boundary_ys,'b-',label='Decision Boundary');
901/18: boundary_xs = np.array([np.min(X[:,1]), np.max(X[:,1])])
901/19:
boundary_xs = np.array([np.min(X[:,1]), np.max(X[:,1])])
boundary_xs
901/20:
def graph(formula, x_range):  
    x = np.array(x_range)  
    y = eval(formula)
    plt.plot(x, y)  
    plt.show()
901/21: graph(0.206*log.X[:, 1] + 0.201*log.X[:, 2] - 25.161*log.X[:, 0], boundary_xs)
901/22: np.max(X[:,1]) - np.min(X[:,1])
901/23: graph(0.206*log.X[:, 1] + 0.201*log.X[:, 2] - 25.161*log.X[:, 0], 68.266172507926)
901/24: log.X[:, 1]
901/25: log.X[:, 2]
901/26: log.X[:, 0]
901/27:
def graph(formula, x_range):  
    x = np.array(x_range)  
    y = eval(str(formula))
    plt.plot(x, y)  
    plt.show()
901/28: graph(0.206*log.X[:, 1] + 0.201*log.X[:, 2] - 25.161*log.X[:, 0], 68.266172507926)
901/29:
def graph(formula, x_range):  
    x = np.array(x_range)  
    y = eval(formula)
    plt.plot(x, y)  
    plt.show()
901/30: graph(0.206*log.X[:, 1] + 0.201*log.X[:, 2] - 25.161*log.X[:, 0], 68.266172507926)
901/31:
import numpy as np  
import matplotlib.pyplot as plt  

def graph(formula, x_range):  
    x = np.array(x_range)  
    y = formula(x)  # <- note now we're calling the function 'formula' with x
    plt.plot(x, y)  
    plt.show()  

def my_formula(x):
    return 0.206*log.X[:, 1] + 0.201*log.X[:, 2] - 25.161*log.X[:, 0]
901/32: graph(my_formula, 68.266172507926)
901/33: graph(my_formula, np.linspace(0, 100, 100))
901/34:
xx, yy = np.mgrid[-5:5:.01, -5:5:.01]
grid = np.c_[xx.ravel(), yy.ravel()]
probs = clf.predict_proba(grid)[:, 1].reshape(xx.shape)
901/35:
xx, yy = np.mgrid[-5:5:.01, -5:5:.01]
grid = np.c_[xx.ravel(), yy.ravel()]
probs = probabilities = log.predict()
901/36: xx
901/37: yy
901/38:
f, ax = plt.subplots(figsize=(8, 6))
contour = ax.contourf(xx, yy, probs, 25, cmap="RdBu",
                      vmin=0, vmax=1)
901/39:
boundary_xs = np.array([np.min(X[:,1]), np.max(X[:,1])])
boundary_xs
901/40: np.max(X[:,1]) - np.min(X[:,1])
901/41: boundary_ys
901/42: boundary_xs
901/43: (-1/log.thetas[2])
901/44: (log.thetas[0] + log.thetas[1]*boundary_xs)
901/45: log.thetas[0]
901/46: log.thetas[1]*boundary_xs
901/47: boundary_ys = (-1/log.thetas[2])*(log.thetas[0] + log.thetas[1]*boundary_xs)
901/48: log.thetas[1]*boundary_xs
901/49: boundary_ys
901/50: boundary_xs
901/51:
def plot_decision_boundary(trues, falses):
    fig = plt.figure()
    ax = fig.add_subplot(111)

    no_of_preds = len(trues) + len(falses)

    ax.scatter([i for i in range(len(trues))], trues, s=25, c='b', marker="o", label='Trues')
    ax.scatter([i for i in range(len(falses))], falses, s=25, c='r', marker="s", label='Falses')

    plt.legend(loc='upper right');
    ax.set_title("Decision Boundary")
    ax.set_xlabel('N/2')
    ax.set_ylabel('Predicted Probability')
    plt.axhline(.5, color='black')
    plt.show()
901/52: log.predict()
901/53: predict = log.predict()
901/54: trues = predict[predict = 1]
901/55: trues = predict[predict = 1]
901/56: trues = predict[predict == 1]
901/57:
trues = predict[predict == 1]
falses = predict[predict == 0]
901/58: plot_decision_boundary(trues, falses)
901/59: plot_decision_boundary(self.X[:, 1], falses)
901/60: plot_decision_boundary(log.X[:, 1], falses)
901/61: plot_decision_boundary(log.X[:, 1], X[:, 2])
901/62: plot_decision_boundary(log.X[:, 1], log.X[:, 2])
901/63: (-log.thetas[0]/log.thetas[2])
901/64: (-log.thetas[0]/log.thetas[2]), (-log.thetas[0]/log.thetas[1])
901/65: boundary_xs = np.array([np.min(X[:,1]), np.max(X[:,1])])
901/66: x2 = -log.thetas[1]*log.X[:, 1]/log.thetas[2] - log.thetas[0]/log.thetas[2]
901/67:
x2 = -log.thetas[1]*log.X[:, 1]/log.thetas[2] - log.thetas[0]/log.thetas[2]x
x
901/68:
x2 = -log.thetas[1]*log.X[:, 1]/log.thetas[2] - log.thetas[0]/log.thetas[2]x
x2
901/69:
x2 = -log.thetas[1]*log.X[:, 1]/log.thetas[2] - log.thetas[0]/log.thetas[2]
x2
901/70: x1 = log.X[:, 1]
901/71:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted")
plt.plot(x1,x2,'b-',label='Decision Boundary');
901/72: log.X[:, 2]
901/73:
def calculate_decision_boundary_values(coefficients, X):
    x1 = X[:, 1]
    x2 = (-1/coefficients[2])*(coefficients[0] + coefficients[1]*x1)
    
    return x1, x2
901/74: calculate_decision_boundary_values(log.thetas, log.X)
901/75: x1, x2 = calculate_decision_boundary_values(log.thetas, log.X)
901/76:
def plot_decision_boundary(coefficients, X):
    x1, x2 = calculate_decision_boundary_values(coefficients, X)
    plt.plot(x1,x2,'r-',label='Decision Boundary');
901/77:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted")
plot_decision_boundary(log.thetas, log.X)
901/78:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
901/79:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]

X = ex2data1[:, :2]
y = ex2data1[:, -1]
902/1:
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
902/2:
ex2data1 = np.loadtxt("data/ex2data1.txt", delimiter=",")

exam_1_score = ex2data1[:, 0]
exam_2_score = ex2data1[:, 1]

X = ex2data1[:, :2]
y = ex2data1[:, -1]
902/3:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted");
902/4:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)


    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)


    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)


    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = 1
        probabilities[probabilities <= 0.5] = 0
        return probabilities


def calculate_decision_boundary_values(coefficients, X):
    x1 = X[:, 1]
    x2 = (-1/coefficients[2])*(coefficients[0] + coefficients[1]*x1)
    return x1, x2


def plot_decision_boundary(coefficients, X):
    x1, x2 = calculate_decision_boundary_values(coefficients, X)
    plt.plot(x1,x2,'r-',label='Decision Boundary');
902/5:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**6,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
902/6: log._calculate_cost()
902/7: log._calculate_cost()
902/8: probabilities = log.predict()
902/9: #log.fit()
902/10:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted")
plot_decision_boundary(log.thetas, log.X)
902/11:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                if i % 500000/0:
                    print(self.thetas)


    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)


    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)


    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = 1
        probabilities[probabilities <= 0.5] = 0
        return probabilities


def calculate_decision_boundary_values(coefficients, X):
    x1 = X[:, 1]
    x2 = (-1/coefficients[2])*(coefficients[0] + coefficients[1]*x1)
    return x1, x2


def plot_decision_boundary(coefficients, X):
    x1, x2 = calculate_decision_boundary_values(coefficients, X)
    plt.plot(x1,x2,'r-',label='Decision Boundary');
902/12:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**6,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
902/13: log._calculate_cost()
902/14: probabilities = log.predict()
902/15: log.fit()
902/16:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                if i % 500000 == 0:
                    print(self.thetas)


    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)


    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)


    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = 1
        probabilities[probabilities <= 0.5] = 0
        return probabilities


def calculate_decision_boundary_values(coefficients, X):
    x1 = X[:, 1]
    x2 = (-1/coefficients[2])*(coefficients[0] + coefficients[1]*x1)
    return x1, x2


def plot_decision_boundary(coefficients, X):
    x1, x2 = calculate_decision_boundary_values(coefficients, X)
    plt.plot(x1,x2,'r-',label='Decision Boundary');
902/17:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**6,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
902/18: log._calculate_cost()
902/19: probabilities = log.predict()
902/20: log.fit()
902/21:
fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111)
ax.scatter(exam_1_score, exam_2_score, c=ex2data1[:, -1], s=100)
plt.xlabel("Exam 1 Score")
plt.ylabel("Exam 2 Score")
plt.title("Exam Score 1 vs 2 - Coloured by Admitted-Not Admitted")
plot_decision_boundary(log.thetas, log.X)
902/22:
class LogisticRegression:
    

    def __init__(self,
                 X,
                 y,
                 alfa=0.001,
                 num_iter=100000,
                 fit_intercept=True,
                 weights_to_initialise=0,
                 verbose=True):

        self.X = X
        self.y = y.reshape(len(X), 1)

        self._fit_intercept = fit_intercept
        self._alfa = alfa
        self._num_iter = num_iter
        self._m = X.shape[0]
        self._n = (X.shape[1] + 1) if fit_intercept else len(X.shape[1])
        
        self.thetas = None
        self._temp_thetas = None
        self._verbose = verbose
        
        self._add_constant()
        self._initalise_θ(weights_to_initialise)
  

    def _add_constant(self):
        if self._fit_intercept:
            constants = np.ones((self._m, 1))
            self.X = np.concatenate((constants, self.X), axis = 1)


    def _initalise_θ(self, weight_to_initialise):
        self.thetas = np.zeros(
            self._n
        ) + weight_to_initialise
        self._temp_thetas = self.thetas


    def _sigmoid(self, z):
        return (1 / (1 + np.exp(-z)))


    def _h(self):
        z = (self.X @ self.thetas.reshape(-1, 1))
        return self._sigmoid(z)


    def _calculate_cost(self):
        epsilon = 1e-5 # to silence the "RuntimeWarning: divide by zero encountered in log" errors
        h = self._h()
        return np.mean(-1 * (
            (self.y) * np.log(h + epsilon)
            + (1 - self.y) * np.log(1 - h + epsilon)
        ))


    def _gradient(self):
        h = self._h()
        return ((1 / self._m) * self.X.T @ (h - self.y)).flatten()


    def fit(self):
        for i in range(self._num_iter):
            self.thetas -= self._alfa * self._gradient()
            if (self._verbose) and (i % 50000 == 0):
                print(f"COST: {self._calculate_cost()}")
                print(self.thetas)


    def predict_prob(self):
        return self._sigmoid(log.X @ log.thetas)


    def predict_prob_single_instance(self, index):
        prob_matrix = self._sigmoid(log.X @ log.thetas)
        
        exam_scores = f"Exam Score 1: %.3f\nExam Score 2: %.3f" % (self.X[index, 1], self.X[index, 2])
        probability = "Probability of Being Admitted: %.2f%%" % (prob_matrix[index] * 100)
        print(exam_scores); print(probability)


    def predict(self):
        probabilities = self.predict_prob()
        probabilities[probabilities > 0.5] = 1
        probabilities[probabilities <= 0.5] = 0
        return probabilities


def calculate_decision_boundary_values(coefficients, X):
    x1 = X[:, 1]
    x2 = (-1/coefficients[2])*(coefficients[0] + coefficients[1]*x1)
    return x1, x2


def plot_decision_boundary(coefficients, X):
    x1, x2 = calculate_decision_boundary_values(coefficients, X)
    plt.plot(x1,x2,'r-',label='Decision Boundary');
902/23:
#COST: 0.20348330288326974
#WEIGHTS: -25.16133356   0.20623171   0.2014716
log = LogisticRegression(X,
                         y,
                         alfa=0.001,
                         num_iter=10**6,
                         weights_to_initialise=np.array([-25.16133356, 0.20623171, 0.2014716]))
902/24: log._calculate_cost()
902/25: probabilities = log.predict()
902/26: log.fit()
905/1:
import numpy as np
import itertools
905/2:
i1 = 0.05
i2 = 0.10

b1 = 0.35

w1 = 0.15
w2 = 0.20
w3 = 0.25
w4 = 0.30

o1 = 0.01
o2 = 0.99

b2 = 0.60

w5 = 0.4
w6 = 0.45
w7 = 0.5
w8 = 0.55
905/3:
def sigmoid(z):
    return 1 / (1 + np.exp(-z))
905/4:
def calculate_weight_set_dimensions(dimensions):

    a, b = itertools.tee(dimensions[::-1])
    next(b, None)
    weight_set_dimensions = list(zip(a, b))[::-1]
    
    return weight_set_dimensions
905/5:
dimensions = [2,4,2]

calculate_weight_set_dimensions(dimensions)
905/6:
dimensions = [2,4,2]

calculate_weight_set_dimensions(dimensions)
905/7:
def initialise_weights(dimensions):
    
    # For single hidden layer neural network there will be 2 sets of weights;
    # 1- one set to hidden layer
    # 2- one set from hidden layer
    # number of weight sets = no_of_hidden_layers + 1
    
    weight_dims = calculate_weight_set_dimensions(dimensions)
    no_of_weight_sets = len(weight_dims)
    
    # W_set holds weight sets such as w1, w2, w3 etc.
    W = np.empty_like(range(no_of_weight_sets), dtype=object)
    B = np.empty_like(range(no_of_weight_sets), dtype=object)
    for index, (row, column) in enumerate(weight_dims):
        W[index] = np.random.rand(row, column)
        B[index] = np.random.rand()
    return W, B
905/8:
def forwardpass(input_vals, W, B):
    
    weight_dims = calculate_weight_set_dimensions(dimensions)
    no_of_weight_sets = len(weight_dims)
    
    Z = np.empty_like(range(no_of_weight_sets + 1), dtype=object)
    A = np.empty_like(range(no_of_weight_sets + 1), dtype=object)
    A[0] = input_vals
    Z[0] = None
    B[0] = 0.35
    B[1] = 0.6
    for index in range(no_of_weight_sets):
        Z[index + 1] = W[index] @ A[index] + B[index]
        A[index + 1] = sigmoid(Z[index + 1])
    return A, Z
905/9:
def calculate_error(y, y_hat):
    return 0.5 * np.square(y - y_hat)
905/10:
input_vals = np.array([0.05, 0.10]).reshape((dimensions[0], 1))
output_vals = np.array([0.01, 0.99]).reshape((dimensions[-1], 1))

W, B = initialise_weights(dimensions)

initial_weights = W[0]
initial_weights[0][0] = 0.15
initial_weights[0][1] = 0.2
initial_weights[1][0] = 0.25
initial_weights[1][1] = 0.30
B[0] = 0.35

second_set_of_weights = W[1]
second_set_of_weights[0][0] = 0.4
second_set_of_weights[0][1] = 0.45
second_set_of_weights[1][0] = 0.5
second_set_of_weights[1][1] = 0.55
B[1] = 0.6

A, Z = forwardpass(input_vals, W, B)
E = calculate_error(output_vals, A[-1])
905/11:
import numpy as np
import itertools
905/12:
i1 = 0.05
i2 = 0.10

b1 = 0.35

w1 = 0.15
w2 = 0.20
w3 = 0.25
w4 = 0.30

o1 = 0.01
o2 = 0.99

b2 = 0.60

w5 = 0.4
w6 = 0.45
w7 = 0.5
w8 = 0.55
905/13:
def sigmoid(z):
    return 1 / (1 + np.exp(-z))
905/14:
def calculate_weight_set_dimensions(dimensions):

    a, b = itertools.tee(dimensions[::-1])
    next(b, None)
    weight_set_dimensions = list(zip(a, b))[::-1]
    
    return weight_set_dimensions
905/15:
dimensions = [2,4,2]

calculate_weight_set_dimensions(dimensions)
905/16:
def initialise_weights(dimensions):
    
    # For single hidden layer neural network there will be 2 sets of weights;
    # 1- one set to hidden layer
    # 2- one set from hidden layer
    # number of weight sets = no_of_hidden_layers + 1
    
    weight_dims = calculate_weight_set_dimensions(dimensions)
    no_of_weight_sets = len(weight_dims)
    
    # W_set holds weight sets such as w1, w2, w3 etc.
    W = np.empty_like(range(no_of_weight_sets), dtype=object)
    B = np.empty_like(range(no_of_weight_sets), dtype=object)
    for index, (row, column) in enumerate(weight_dims):
        W[index] = np.random.rand(row, column)
        B[index] = np.random.rand()
    return W, B
905/17:
def forwardpass(input_vals, W, B):
    
    weight_dims = calculate_weight_set_dimensions(dimensions)
    no_of_weight_sets = len(weight_dims)
    
    Z = np.empty_like(range(no_of_weight_sets + 1), dtype=object)
    A = np.empty_like(range(no_of_weight_sets + 1), dtype=object)
    A[0] = input_vals
    Z[0] = None
    B[0] = 0.35
    B[1] = 0.6
    for index in range(no_of_weight_sets):
        Z[index + 1] = W[index] @ A[index] + B[index]
        A[index + 1] = sigmoid(Z[index + 1])
    return A, Z
905/18:
def calculate_error(y, y_hat):
    return 0.5 * np.square(y - y_hat)
905/19:
input_vals = np.array([0.05, 0.10]).reshape((dimensions[0], 1))
output_vals = np.array([0.01, 0.99]).reshape((dimensions[-1], 1))

W, B = initialise_weights(dimensions)

# initial_weights = W[0]
# initial_weights[0][0] = 0.15
# initial_weights[0][1] = 0.2
# initial_weights[1][0] = 0.25
# initial_weights[1][1] = 0.30
# B[0] = 0.35

# second_set_of_weights = W[1]
# second_set_of_weights[0][0] = 0.4
# second_set_of_weights[0][1] = 0.45
# second_set_of_weights[1][0] = 0.5
# second_set_of_weights[1][1] = 0.55
# B[1] = 0.6

A, Z = forwardpass(input_vals, W, B)
E = calculate_error(output_vals, A[-1])
905/20: E
905/21:
dimensions = [2,4,4,2]

calculate_weight_set_dimensions(dimensions)
905/22:
def initialise_weights(dimensions):
    
    # For single hidden layer neural network there will be 2 sets of weights;
    # 1- one set to hidden layer
    # 2- one set from hidden layer
    # number of weight sets = no_of_hidden_layers + 1
    
    weight_dims = calculate_weight_set_dimensions(dimensions)
    no_of_weight_sets = len(weight_dims)
    
    # W_set holds weight sets such as w1, w2, w3 etc.
    W = np.empty_like(range(no_of_weight_sets), dtype=object)
    B = np.empty_like(range(no_of_weight_sets), dtype=object)
    for index, (row, column) in enumerate(weight_dims):
        W[index] = np.random.rand(row, column)
        B[index] = np.random.rand()
    return W, B
905/23:
def forwardpass(input_vals, W, B):
    
    weight_dims = calculate_weight_set_dimensions(dimensions)
    no_of_weight_sets = len(weight_dims)
    
    Z = np.empty_like(range(no_of_weight_sets + 1), dtype=object)
    A = np.empty_like(range(no_of_weight_sets + 1), dtype=object)
    A[0] = input_vals
    Z[0] = None
    B[0] = 0.35
    B[1] = 0.6
    for index in range(no_of_weight_sets):
        Z[index + 1] = W[index] @ A[index] + B[index]
        A[index + 1] = sigmoid(Z[index + 1])
    return A, Z
905/24:
def calculate_error(y, y_hat):
    return 0.5 * np.square(y - y_hat)
905/25:
input_vals = np.array([0.05, 0.10]).reshape((dimensions[0], 1))
output_vals = np.array([0.01, 0.99]).reshape((dimensions[-1], 1))

W, B = initialise_weights(dimensions)

# initial_weights = W[0]
# initial_weights[0][0] = 0.15
# initial_weights[0][1] = 0.2
# initial_weights[1][0] = 0.25
# initial_weights[1][1] = 0.30
# B[0] = 0.35

# second_set_of_weights = W[1]
# second_set_of_weights[0][0] = 0.4
# second_set_of_weights[0][1] = 0.45
# second_set_of_weights[1][0] = 0.5
# second_set_of_weights[1][1] = 0.55
# B[1] = 0.6

A, Z = forwardpass(input_vals, W, B)
E = calculate_error(output_vals, A[-1])
905/26: E
906/1:
import numpy as np
import itertools
906/2:
def get_shapes(any_):
    for array in any_:
        try:
            print(array.shape)
        except:
            print("NONE")
    print("\n")
906/3:
# ============= ACTIVATION FUNCTIONS ===============#

def sigmoid(Z, prime=False):
    # np.
    if prime:
        return sigmoid(Z) * (1 - sigmoid(Z))
    return 1 / (1 + np.exp(-Z))


def linear(Z, prime=False):
    if prime:
        return np.ones_like(Z)
    return Z


def relu(Z, alpha=0, prime=False):
    if prime:
        Z_relu = np.ones_like(Z, dtype=np.float64)
        Z_relu[Z < 0] = alpha
        return Z_relu
    return np.where(Z < 0, alpha * Z, Z)


def tanh(Z, prime=False):
    # np.tanh() could be used directly to speed this up
    if prime:
        return 1 - np.power(tanh(Z), 2)
    return (2 / (1 + np.exp(-2 * Z))) - 1


def elu(Z, prime=False):
    # https://mlfromscratch.com/activation-functions-explained/#/
    alpha = 0.2
    if prime:
        return np.where(Z < 0, alpha * (np.exp(Z)),1)
    return np.where(Z < 0, alpha * (np.exp(Z) - 1), Z)


def softmax(Z, prime=False):
    if prime:
        return 1
    return np.exp(Z) / np.sum(np.exp(Z),axis=0)
906/4:
# ============== LOSS FUNCTIONS ===============#

def calculate_error(Y, Y_hat):
    m = Y.shape[1]
    return np.sum(0.5 * np.square(Y - Y_hat)) / m
906/5:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        alpha: float,
        no_of_iterations: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.alpha = alpha
        self.no_of_iterations = no_of_iterations
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        for iteration in range(self.no_of_iterations + 1):
            self.forwardpass(X)
            self.backpropagation(Y)
            if iteration % 2500 == 0 or iteration == self.no_of_iterations:
                print("iteration %s - loss %.20f" %(iteration, calculate_error(Y, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
906/6:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
906/7:
print(X.shape)
print(Y.shape)
906/8:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    alpha=0.5,
    no_of_iterations=50000
)

self.fit(X, Y)
906/9: self.predict(X) == np.argmax(Y, axis=0)
906/10:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
906/11:
from sklearn.datasets import make_moons
from sklearn import preprocessing

x,y =make_moons(n_samples=1500, noise=.05)
X = x.T
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
y_next = np.where(y==0,1,0)
Y = Y.T
Y = list(Y)
Y.append(y_next)
Y = np.array(Y)

print(X.shape)
print(Y.shape)
906/12:
model = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=2,
    alpha=0.5,
    no_of_iterations=50000
)

model.fit(X, Y)
906/13:
### Decision Boundaries
%matplotlib inline
import matplotlib.pyplot as plt
dt = x
x_min, x_max = dt[:, 0].min() - 0.5, dt[:, 0].max() + 0.5
y_min, y_max = dt[:, 1].min() - 0.5, dt[:, 1].max() + 0.5
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = model.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.title('Decision Boundaries')
906/14: model.B[3]
906/15:
ex2data2 = np.loadtxt("/home/cagri/Desktop/Google Drive/data/ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
906/16:
ex2data2 = np.loadtxt("/home/cagri/Desktop/Google Drive/data/ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/1: range(1,35, 16)
907/2: list(range(1,35, 16))
907/3:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/4: X
907/5: X.shape
907/6: idx = np.arange(0,X.shape[1])
907/7: import numpy as np
907/8: X.shape
907/9:
for epoch_no in range(1, 500):
    np.random.shuffle(idx)
    X = X[:,idx]
    y = y[:,idx]
    for i in range(0,M, self.batch_size):
        self.iter_no = self.iter_no + 1
        X_batch = X[:,i:i + self.batch_size]
        y_batch = y[:,i:i + self.batch_size]
907/10: idx = np.arange(0,X.shape[1])
907/11: idx
907/12: idx.shape
907/13: np.random.shuffle(idx)
907/14: idx
907/15: X = X[:,idx]
907/16: X
907/17:
for epoch_no in range(1, 500):
    np.random.shuffle(idx)
    X = X[:,idx]
    y = y[:,idx]
    for i in range(0,150, 16):
        X_batch = X[:,i:i + self.batch_size]
        print(X_batch.shape)
        y_batch = y[:,i:i + self.batch_size]
907/18: y
907/19: y.shaper
907/20: y.shape
907/21: y.shape.reshape(1, 150)
907/22: y.reshape(1, 150)
907/23: y = y.reshape(1, 150)
907/24:
for epoch_no in range(1, 500):
    np.random.shuffle(idx)
    X = X[:,idx]
    y = y[:,idx]
    for i in range(0,150, 16):
        X_batch = X[:,i:i + self.batch_size]
        print(X_batch.shape)
        y_batch = y[:,i:i + self.batch_size]
907/25:
for epoch_no in range(1, 500):
    np.random.shuffle(idx)
    X = X[:,idx]
    y = y[:,idx]
    for i in range(0,150, 16):
        X_batch = X[:,i:i + 16]
        print(X_batch.shape)
        y_batch = y[:,i:i + 16]
907/26:
for epoch_no in range(1, 500):
    np.random.shuffle(idx)
    X = X[:,idx]
    y = y[:,idx]
    for i in range(0,150, 16):
        X_batch = X[:,i:i + 16]
        print(i, X_batch.shape)
        y_batch = y[:,i:i + 16]
907/27: shuffled = np.arange(150)
907/28: shuffled
907/29: shuffled.shape
907/30: shuffled = np.arange(0, 150)
907/31: shuffled.shape
907/32: shuffled
907/33: shuffled = np.arange(150)
907/34: shuffled
907/35: shuffled = np.arange(150)
907/36: shuffled
907/37: shuffled = np.arange(150)
907/38: shuffled
907/39: shuffled = np.arange(0, 150)
907/40: shuffled = np.arange(20, 150)
907/41: shuffled
907/42: shuffled = np.arange(0, 150)
907/43: shuffled
907/44: shuffled = np.arange(150)
907/45:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch]
                Y_mini_batch = Y[:, i: i + self.mini_batch]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 5000 == 0:
                    print("iteration %s - loss %.20f" %(iteration, calculate_error(Y, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/46:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/47:
print(X.shape)
print(Y.shape)
907/48:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=50000
)

self.fit(X, Y)
907/49:
import numpy as np
import itertools
907/50:
def get_shapes(any_):
    for array in any_:
        try:
            print(array.shape)
        except:
            print("NONE")
    print("\n")
907/51:
# ============= ACTIVATION FUNCTIONS ===============#

def sigmoid(Z, prime=False):
    # np.
    if prime:
        return sigmoid(Z) * (1 - sigmoid(Z))
    return 1 / (1 + np.exp(-Z))


def linear(Z, prime=False):
    if prime:
        return np.ones_like(Z)
    return Z


def relu(Z, alpha=0, prime=False):
    if prime:
        Z_relu = np.ones_like(Z, dtype=np.float64)
        Z_relu[Z < 0] = alpha
        return Z_relu
    return np.where(Z < 0, alpha * Z, Z)


def tanh(Z, prime=False):
    # np.tanh() could be used directly to speed this up
    if prime:
        return 1 - np.power(tanh(Z), 2)
    return (2 / (1 + np.exp(-2 * Z))) - 1


def elu(Z, prime=False):
    # https://mlfromscratch.com/activation-functions-explained/#/
    alpha = 0.2
    if prime:
        return np.where(Z < 0, alpha * (np.exp(Z)),1)
    return np.where(Z < 0, alpha * (np.exp(Z) - 1), Z)


def softmax(Z, prime=False):
    if prime:
        return 1
    return np.exp(Z) / np.sum(np.exp(Z),axis=0)
907/52:
# ============== LOSS FUNCTIONS ===============#

def calculate_error(Y, Y_hat):
    m = Y.shape[1]
    return np.sum(0.5 * np.square(Y - Y_hat)) / m
907/53:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch]
                Y_mini_batch = Y[:, i: i + self.mini_batch]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 5000 == 0:
                    print("iteration %s - loss %.20f" %(iteration, calculate_error(Y, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/54:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/55:
print(X.shape)
print(Y.shape)
907/56:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=50000
)

self.fit(X, Y)
907/57:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, self.epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch]
                Y_mini_batch = Y[:, i: i + self.mini_batch]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 5000 == 0:
                    print("iteration %s - loss %.20f" %(iteration, calculate_error(Y, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/58:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/59:
print(X.shape)
print(Y.shape)
907/60:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=500
)

self.fit(X, Y)
907/61:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, self.epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch_size):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch_size]
                Y_mini_batch = Y[:, i: i + self.mini_batch_size]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 5000 == 0:
                    print("iteration %s - loss %.20f" %(iteration, calculate_error(Y, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/62:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/63:
print(X.shape)
print(Y.shape)
907/64:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=500
)

self.fit(X, Y)
907/65:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, self.epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch_size):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch_size]
                Y_mini_batch = Y[:, i: i + self.mini_batch_size]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 100 == 0:
                    print("iteration %s - loss %.20f" %(iteration, calculate_error(Y, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/66:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/67:
print(X.shape)
print(Y.shape)
907/68:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=500
)

self.fit(X, Y)
907/69: self.predict(X) == np.argmax(Y, axis=0)
907/70:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, self.epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch_size):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch_size]
                Y_mini_batch = Y[:, i: i + self.mini_batch_size]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 100 == 0:
                    print("iteration %s - loss %.20f" %(self.no_of_iterations, calculate_error(Y, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/71:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/72:
print(X.shape)
print(Y.shape)
907/73:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=500
)

self.fit(X, Y)
907/74:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, self.epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch_size):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch_size]
                Y_mini_batch = Y[:, i: i + self.mini_batch_size]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 100 == 0:
                    print("iteration %s - loss %.20f" %(self.no_of_iterations, calculate_error(Y_mini_batch, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/75:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/76:
print(X.shape)
print(Y.shape)
907/77:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=500
)

self.fit(X, Y)
907/78: self.predict(X) == np.argmax(Y, axis=0)
907/79:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/80:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=5000
)

self.fit(X, Y)
907/81: self.predict(X) == np.argmax(Y, axis=0)
907/82:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/83:
self = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "relu"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=5000
)

self.fit(X, Y)
907/84: self.predict(X) == np.argmax(Y, axis=0)
907/85:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/86:
self = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "relu"),(4, "sigmoid")],
    output_layer=3,
    batch_size=16,
    alpha=0.5,
    epoch=5000
)

self.fit(X, Y)
907/87: self.predict(X) == np.argmax(Y, axis=0)
907/88:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/89:
self = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "relu"),(4, "sigmoid")],
    output_layer=3,
    batch_size=150,
    alpha=0.5,
    epoch=5000
)

self.fit(X, Y)
907/90: self.predict(X) == np.argmax(Y, axis=0)
907/91:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/92:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=32,
    alpha=0.5,
    epoch=50000
)

self.fit(X, Y)
907/93: self.predict(X) == np.argmax(Y, axis=0)
907/94:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/95:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=150,
    alpha=0.5,
    epoch=50000
)

self.fit(X, Y)
907/96: self.predict(X) == np.argmax(Y, axis=0)
907/97:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/98:
import numpy as np
import itertools
907/99:
def get_shapes(any_):
    for array in any_:
        try:
            print(array.shape)
        except:
            print("NONE")
    print("\n")
907/100:
# ============= ACTIVATION FUNCTIONS ===============#

def sigmoid(Z, prime=False):
    # np.
    if prime:
        return sigmoid(Z) * (1 - sigmoid(Z))
    return 1 / (1 + np.exp(-Z))


def linear(Z, prime=False):
    if prime:
        return np.ones_like(Z)
    return Z


def relu(Z, alpha=0, prime=False):
    if prime:
        Z_relu = np.ones_like(Z, dtype=np.float64)
        Z_relu[Z < 0] = alpha
        return Z_relu
    return np.where(Z < 0, alpha * Z, Z)


def tanh(Z, prime=False):
    # np.tanh() could be used directly to speed this up
    if prime:
        return 1 - np.power(tanh(Z), 2)
    return (2 / (1 + np.exp(-2 * Z))) - 1


def elu(Z, prime=False):
    # https://mlfromscratch.com/activation-functions-explained/#/
    alpha = 0.2
    if prime:
        return np.where(Z < 0, alpha * (np.exp(Z)),1)
    return np.where(Z < 0, alpha * (np.exp(Z) - 1), Z)


def softmax(Z, prime=False):
    if prime:
        return 1
    return np.exp(Z) / np.sum(np.exp(Z),axis=0)
907/101:
# ============== LOSS FUNCTIONS ===============#

def calculate_error(Y, Y_hat):
    m = Y.shape[1]
    return np.sum(0.5 * np.square(Y - Y_hat)) / m
907/102:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, self.epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch_size):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch_size]
                Y_mini_batch = Y[:, i: i + self.mini_batch_size]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 5000 == 0:
                    print("iteration %s - loss %.20f" %(self.no_of_iterations, calculate_error(Y_mini_batch, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/103:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/104:
print(X.shape)
print(Y.shape)
907/105:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=64,
    alpha=0.5,
    epoch=5000
)

self.fit(X, Y)
907/106: self.predict(X) == np.argmax(Y, axis=0)
907/107:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/108: self.no_of_iterations
907/109:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=16,
    alpha=0.5,
    epoch=5000
)

self.fit(X, Y)
907/110: self.no_of_iterations
907/111: self.predict(X) == np.argmax(Y, axis=0)
907/112:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/113:
# References
# https://mc.ai/multilayered-neural-network-from-scratch-using-python/
# https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/
# https://www.coursera.org/learn/machine-learning/home/week/5
# https://www.coursera.org/specializations/deep-learning
# https://github.com/mnielsen/neural-networks-and-deep-learning/blob/master/src/network.py

class NeuralNetwork:
    

    def __init__(
        self,
        input_layer: tuple,
        hidden_layer: list, # list of tuples
        output_layer: int,
        batch_size: int,
        alpha: float,
        epoch: int,
    ):
        self.input_layer = input_layer
        self.hidden_layer = hidden_layer
        self.output_layer = output_layer
        self.mini_batch_size = batch_size
        self.alpha = alpha
        self.epoch = epoch
        
        self.m = X.shape[1] # where (no_of_features, no_of_training_examples)
        self.layers = len(self.weight_set_dimensions) + 1


    def calculate_delta_final(self, Y):
        final_act_func = self.activation_functions[-1]
        arg_to_pass_to_eval = "(self.Z[-1], prime=True)"
        
        return (self.A[-1] - Y) * eval(final_act_func + arg_to_pass_to_eval)


    def get_dimensions_and_activations(self):
        self.dimensions = []
        self.activation_functions = []
        
        self.dimensions.append(self.input_layer[0])
        self.activation_functions.append(self.input_layer[1])

        for dim, act_func in self.hidden_layer:
            self.dimensions.append(dim)
            self.activation_functions.append(act_func)

        self.dimensions.append(self.output_layer)

        
    @property
    def weight_set_dimensions(self):
        self.get_dimensions_and_activations()
        a, b = itertools.tee(self.dimensions[::-1])
        next(b, None)
        weight_set_dimensions = list(zip(a, b))[::-1]
        return weight_set_dimensions


    def initialise_weights(self):

        self.W = np.empty_like(range(self.layers), dtype=object)
        self.B = np.empty_like(range(self.layers), dtype=object)
        self.W[0] = None
        self.B[0] = None
        for layer, (y, x) in zip(range(1, self.layers), self.weight_set_dimensions):
            np.random.seed(42)
            self.W[layer] = np.random.rand(y, x)
            self.B[layer] = np.random.rand(y, 1)


    def forwardpass(self, X):
        self.Z = np.empty_like(range(self.layers), dtype=object)
        self.A = np.empty_like(range(self.layers), dtype=object)
        self.A[0] = X
        self.Z[0] = None
        for layer in range(1, self.layers):
            # activation_function starts from 0 whereas layer starts from 1
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer])"

            self.Z[layer] = self.W[layer] @ self.A[layer - 1] + self.B[layer]
            self.A[layer] = eval(active_function + arg_to_pass_to_eval)


    def backpropagation(self, Y):
        delta_final = self.calculate_delta_final(Y)
        self.delta = np.empty_like(range(self.layers), dtype=object)
        self.delta[0] = None
        self.delta[-1] = delta_final

        self.gradient_W = np.empty_like(range(self.layers), dtype=object)
        self.gradient_B = np.empty_like(range(self.layers), dtype=object)
        self.gradient_W[0] = None
        self.gradient_B[0] = None
        
        # We substract 1 here as delta_final is calculated seperately above
        for layer in reversed(range(1, self.layers - 1)):
            active_function = self.activation_functions[layer - 1]
            arg_to_pass_to_eval = "(self.Z[layer], prime=True)"

            self.delta[layer] = (
                self.W[layer + 1].T @ self.delta[layer + 1] *
                eval(active_function + arg_to_pass_to_eval)
            ) 
            # E.g. eval part might correspond to -> sigmoid(self.Z[layer], prime=True)

        # calculate the gradient
        for layer in range(1, self.layers):
            self.gradient_W[layer] = (self.delta[layer] @ self.A[layer - 1].T) / self.m
            self.gradient_B[layer] = np.sum(self.delta[layer], axis=1, keepdims=True) / self.m

        #update the weights
        for layer in range(1, self.layers):
            self.W[layer] -= self.alpha * self.gradient_W[layer]
            self.B[layer] -= self.alpha * self.gradient_B[layer]
            
            
    def fit(self, X, Y):
        self.initialise_weights()
        
        # By default the optimisation method is SGD(Stochastic Gradient Descent) if one  
        # desires to use the whole batch, simply pass the number of traning examples 
        # available as the batch size when instantiating the class.
        self.no_of_iterations = 0
        shuffled = np.arange(self.m)
        for epoch_no in range(1, self.epoch + 1):
            np.random.shuffle(shuffled)
            X = X[:, shuffled]
            Y = Y[:, shuffled]
            for i in range(0, self.m, self.mini_batch_size):
                self.no_of_iterations += 1
                X_mini_batch = X[:, i: i + self.mini_batch_size]
                Y_mini_batch = Y[:, i: i + self.mini_batch_size]
                self.forwardpass(X_mini_batch)
                self.backpropagation(Y_mini_batch)
                if self.no_of_iterations % 5000 == 0:
                    print("iteration %s - loss %.20f" %(self.no_of_iterations, calculate_error(Y_mini_batch, self.A[-1])))


    def predict(self, X):
        self.forwardpass(X)

        return np.argmax(self.A[-1].T, axis=1)
907/114:
from sklearn.datasets import load_iris
data = load_iris()
X = data.data[:,[0,2]].T
y = data.target
from sklearn import preprocessing
lb = preprocessing.LabelBinarizer()
Y = lb.fit_transform(y)
Y = Y.T
907/115:
print(X.shape)
print(Y.shape)
907/116:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=150,
    alpha=0.5,
    epoch=5000
)

self.fit(X, Y)
907/117:
self = NeuralNetwork(
    input_layer=(2, "tanh"),
    hidden_layer=[(6, "tanh"),(4, "sigmoid")],
    output_layer=3,
    batch_size=150,
    alpha=0.5,
    epoch=50000
)

self.fit(X, Y)
907/118: self.predict(X) == np.argmax(Y, axis=0)
907/119:
%matplotlib inline
import matplotlib.pyplot as plt
dt = data.data[:,[0,2]]
x_min, x_max = dt[:, 0].min() - 1, dt[:, 0].max() + 1
y_min, y_max = dt[:, 1].min() - 1, dt[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1),
                     np.arange(y_min, y_max, 0.1))

# here "model" is your model's prediction (classification) function
Z = self.predict(np.c_[xx.ravel(), yy.ravel()].T) 

# Put the result into a color plot
Z = Z.reshape(xx.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx, yy, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(dt[:, 0], dt[:, 1], c=y,s=20, edgecolor='k')
plt.xlabel('sepal length')
plt.ylabel('petal length')
907/120:
ex2data2 = np.loadtxt("/home/cagri/Desktop/Google Drive/data/ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/121:
ex2data2 = np.loadtxt("/home/cagri/Desktop/Google Drive/data/ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/122:
ex2data2 = np.loadtxt("C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt., delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/123:
ex2data2 = np.loadtxt("C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/124:
ex2data2 = np.loadtxt(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/125:
model = NeuralNetwork(
    input_layer=(2, "sigmoid"),
    hidden_layer=[(2, "sigmoid")],
    output_layer=2,
    alpha=0.5,
    no_of_iterations=150000
)

model.fit(X, Y)
907/126:
model = NeuralNetwork(
    input_layer=(2, "sigmoid"),
    hidden_layer=[(2, "sigmoid")],
    output_layer=2,
    batch_size=32,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/127:
### Decision Boundaries
%matplotlib inline
import matplotlib.pyplot as plt
X = ex2data2

x1_min, x1_max = X[:, 0].min() - 0.3, X[:, 0].max() + 0.3,
x2_min, x2_max = X[:, 1].min() - 0.3, X[:, 1].max() + 0.3,
xx1, xx2 = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))

# here "model" is your model's prediction (classification) function
Z = model.predict(np.c_[xx1.ravel(), xx2.ravel()].T) 

negatives = ex2data2[ex2data2[:, -1] == 0]
positives = ex2data2[ex2data2[:, -1] == 1]

# Put the result into a color plot
Z = Z.reshape(xx1.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx1, xx2, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(negatives[:, 0], negatives[:, 1],s=50, edgecolor='k')
plt.scatter(positives[:, 0], positives[:, 1],s=50, edgecolor='b')
plt.title('Decision Boundaries')

plt.contour(xx1, xx2, Z, [0.5], linewidths=2, colors="g")
907/128:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(2, "sigmoid")],
    output_layer=2,
    batch_size=32,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/129:
ex2data2 = np.loadtxt(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/130:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(2, "sigmoid")],
    output_layer=2,
    batch_size=32,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/131:
### Decision Boundaries
%matplotlib inline
import matplotlib.pyplot as plt
X = ex2data2

x1_min, x1_max = X[:, 0].min() - 0.3, X[:, 0].max() + 0.3,
x2_min, x2_max = X[:, 1].min() - 0.3, X[:, 1].max() + 0.3,
xx1, xx2 = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))

# here "model" is your model's prediction (classification) function
Z = model.predict(np.c_[xx1.ravel(), xx2.ravel()].T) 

negatives = ex2data2[ex2data2[:, -1] == 0]
positives = ex2data2[ex2data2[:, -1] == 1]

# Put the result into a color plot
Z = Z.reshape(xx1.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx1, xx2, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(negatives[:, 0], negatives[:, 1],s=50, edgecolor='k')
plt.scatter(positives[:, 0], positives[:, 1],s=50, edgecolor='b')
plt.title('Decision Boundaries')

plt.contour(xx1, xx2, Z, [0.5], linewidths=2, colors="g")
907/132:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "relu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=32,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/133:
ex2data2 = np.loadtxt(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/134:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "relu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=32,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/135:
### Decision Boundaries
%matplotlib inline
import matplotlib.pyplot as plt
X = ex2data2

x1_min, x1_max = X[:, 0].min() - 0.3, X[:, 0].max() + 0.3,
x2_min, x2_max = X[:, 1].min() - 0.3, X[:, 1].max() + 0.3,
xx1, xx2 = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))

# here "model" is your model's prediction (classification) function
Z = model.predict(np.c_[xx1.ravel(), xx2.ravel()].T) 

negatives = ex2data2[ex2data2[:, -1] == 0]
positives = ex2data2[ex2data2[:, -1] == 1]

# Put the result into a color plot
Z = Z.reshape(xx1.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx1, xx2, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(negatives[:, 0], negatives[:, 1],s=50, edgecolor='k')
plt.scatter(positives[:, 0], positives[:, 1],s=50, edgecolor='b')
plt.title('Decision Boundaries')

plt.contour(xx1, xx2, Z, [0.5], linewidths=2, colors="g")
907/136:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "relu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=8,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/137:
get_shapes(model.A)
get_shapes(model.A)
get_shapes(model.A)
get_shapes(model.A)
907/138:
get_shapes(model.A)
get_shapes(model.Z)
get_shapes(model.W)
get_shapes(model.B)
907/139: print
907/140: print(X.shape)
907/141:
ex2data2 = np.loadtxt(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/142:
print(X.shape)
print(Y.shape)
907/143:
ex2data2 = np.loadtxt(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/144:
print(X.shape)
print(Y.shape)
907/145:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "relu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=8,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/146:
### Decision Boundaries
%matplotlib inline
import matplotlib.pyplot as plt
X = ex2data2

x1_min, x1_max = X[:, 0].min() - 0.3, X[:, 0].max() + 0.3,
x2_min, x2_max = X[:, 1].min() - 0.3, X[:, 1].max() + 0.3,
xx1, xx2 = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))

# here "model" is your model's prediction (classification) function
Z = model.predict(np.c_[xx1.ravel(), xx2.ravel()].T) 

negatives = ex2data2[ex2data2[:, -1] == 0]
positives = ex2data2[ex2data2[:, -1] == 1]

# Put the result into a color plot
Z = Z.reshape(xx1.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx1, xx2, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(negatives[:, 0], negatives[:, 1],s=50, edgecolor='k')
plt.scatter(positives[:, 0], positives[:, 1],s=50, edgecolor='b')
plt.title('Decision Boundaries')

plt.contour(xx1, xx2, Z, [0.5], linewidths=2, colors="g")
907/147:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "elu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=16,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/148:
ex2data2 = np.loadtxt(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/149:
print(X.shape)
print(Y.shape)
907/150:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "elu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=16,
    alpha=0.5,
    epoch=50000
)

model.fit(X, Y)
907/151:
### Decision Boundaries
%matplotlib inline
import matplotlib.pyplot as plt
X = ex2data2

x1_min, x1_max = X[:, 0].min() - 0.3, X[:, 0].max() + 0.3,
x2_min, x2_max = X[:, 1].min() - 0.3, X[:, 1].max() + 0.3,
xx1, xx2 = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))

# here "model" is your model's prediction (classification) function
Z = model.predict(np.c_[xx1.ravel(), xx2.ravel()].T) 

negatives = ex2data2[ex2data2[:, -1] == 0]
positives = ex2data2[ex2data2[:, -1] == 1]

# Put the result into a color plot
Z = Z.reshape(xx1.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx1, xx2, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(negatives[:, 0], negatives[:, 1],s=50, edgecolor='k')
plt.scatter(positives[:, 0], positives[:, 1],s=50, edgecolor='b')
plt.title('Decision Boundaries')

plt.contour(xx1, xx2, Z, [0.5], linewidths=2, colors="g")
907/152:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "elu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=118,
    alpha=0.5,
    epoch=10000
)

model.fit(X, Y)
907/153:
ex2data2 = np.loadtxt(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/154:
print(X.shape)
print(Y.shape)
907/155:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "elu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=118,
    alpha=0.5,
    epoch=10000
)

model.fit(X, Y)
907/156:
### Decision Boundaries
%matplotlib inline
import matplotlib.pyplot as plt
X = ex2data2

x1_min, x1_max = X[:, 0].min() - 0.3, X[:, 0].max() + 0.3,
x2_min, x2_max = X[:, 1].min() - 0.3, X[:, 1].max() + 0.3,
xx1, xx2 = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))

# here "model" is your model's prediction (classification) function
Z = model.predict(np.c_[xx1.ravel(), xx2.ravel()].T) 

negatives = ex2data2[ex2data2[:, -1] == 0]
positives = ex2data2[ex2data2[:, -1] == 1]

# Put the result into a color plot
Z = Z.reshape(xx1.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx1, xx2, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(negatives[:, 0], negatives[:, 1],s=50, edgecolor='k')
plt.scatter(positives[:, 0], positives[:, 1],s=50, edgecolor='b')
plt.title('Decision Boundaries')

plt.contour(xx1, xx2, Z, [0.5], linewidths=2, colors="g")
907/157:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "elu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=118,
    alpha=0.5,
    epoch=150000
)

model.fit(X, Y)
907/158:
ex2data2 = np.loadtxt(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew NG Coursera\ex2\data\ex2data2.txt", delimiter=",")

X = ex2data2[:, :-1]
y = ex2data2[:, -1].reshape(-1, 1)

dt = np.c_[X, y]

X = X.T
Y = y.T
907/159:
print(X.shape)
print(Y.shape)
907/160:
model = NeuralNetwork(
    input_layer=(2, "relu"),
    hidden_layer=[(6, "elu"), (4, "sigmoid")],
    output_layer=2,
    batch_size=118,
    alpha=0.5,
    epoch=150000
)

model.fit(X, Y)
907/161:
### Decision Boundaries
%matplotlib inline
import matplotlib.pyplot as plt
X = ex2data2

x1_min, x1_max = X[:, 0].min() - 0.3, X[:, 0].max() + 0.3,
x2_min, x2_max = X[:, 1].min() - 0.3, X[:, 1].max() + 0.3,
xx1, xx2 = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))

# here "model" is your model's prediction (classification) function
Z = model.predict(np.c_[xx1.ravel(), xx2.ravel()].T) 

negatives = ex2data2[ex2data2[:, -1] == 0]
positives = ex2data2[ex2data2[:, -1] == 1]

# Put the result into a color plot
Z = Z.reshape(xx1.shape)
plt.figure(figsize=(12,8))
plt.contourf(xx1, xx2, Z,alpha=0.4)
#plt.axis('off')
plt.scatter(negatives[:, 0], negatives[:, 1],s=50, edgecolor='k')
plt.scatter(positives[:, 0], positives[:, 1],s=50, edgecolor='b')
plt.title('Decision Boundaries')

plt.contour(xx1, xx2, Z, [0.5], linewidths=2, colors="g")
907/162: self.no_of_iterations
907/163: model.no_of_iterations
911/1:
from job_application_filter import *
from bs4 import BeautifulSoup
911/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
911/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
912/1:
from job_application_filter import *
from bs4 import BeautifulSoup
912/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
913/1:
from job_application_filter import *
from bs4 import BeautifulSoup
913/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
913/3: login.SignIn()
913/4: navigate.clickJobs()
913/5: navigate.clickUKJuniorDataScientist()
913/6: scrape.retrieveInfo()
913/7:
from job_application_filter import *
from bs4 import BeautifulSoup
914/1:
from job_application_filter import *
from bs4 import BeautifulSoup
914/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
914/3: login.SignIn()
914/4: navigate.clickJobs()
914/5: navigate.clickUKJuniorDataScientist()
914/6: scrape.retrieveInfo()
914/7: scrape.dict_data_row
914/8: scrape.dict_html_content
914/9: scrape.dict_html_content[1]
914/10: scrape.lst_job_ads
914/11: len(scrape.lst_job_ads)
914/12: scrape.lst_job_ads
914/13: scrape.lst_job_ads[19]
914/14: scrape.lst_job_ads[20]
914/15: scrape.lst_job_ads[21]
914/16: scrape.lst_job_ads[189]
914/17: scrape.lst_job_ads[18]
914/18: soup = BeautifulSoup(self.driver.page_source, "html.parser")
914/19: soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
914/20: soup
914/21: self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
914/22: lst_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
914/23: lst_job_ads
914/24: lst_job_ads[19]
914/25: soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
914/26: lst_job_ads = scrape.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
914/27: lst_job_ads[19]
914/28: lst_job_ads[18]
914/29: lst_job_ads[25]
914/30: lst_job_ads[241]
914/31: lst_job_ads[24]
914/32: lst_job_ads[23]
914/33: lst_job_ads[22]
914/34: lst_job_ads[21]
914/35: lst_job_ads[20]
914/36: lst_job_ads[24]
914/37: lst_job_ads[20]
914/38:
def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data
914/39:
url = "https://www.linkedin.com/"

driver, data = InitialiseLinkedin(url)
914/40: login = Login(driver, data)
914/41: login = Login(driver, data)
914/42:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
916/1:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
916/2:
from job_application_filter import *
from bs4 import BeautifulSoup
916/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
916/4: login = Login(driver, data)
916/5:
login = Login(driver, data)
navigate = NavigateLinkedIn()
917/1:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
917/2:
login = Login(driver, data)
navigate = NavigateLinkedIn()
917/3:
from job_application_filter import *
from bs4 import BeautifulSoup
917/4:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
917/5:
login = Login(driver, data)
navigate = NavigateLinkedIn()
917/6: login.SignIn()
917/7: navigate.clickJobs()
917/8: navigate.clickUKJuniorDataScientist()
917/9: navigate.clickUKJuniorDataScientist()
917/10: soup = BeautifulSoup(driver.page_source, "html.parser")
917/11: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
917/12: lst_job_ads
917/13: lst_job_ads[20]
917/14: lst_job_ads[19]
917/15: lst_job_ads[18]
917/16: lst_job_ads[111]
917/17: lst_job_ads[11]
917/18: lst_job_ads[12]
917/19: lst_job_ads[13]
917/20: lst_job_ads[0]
917/21: lst_job_ads[1]
917/22: lst_job_ads[2]
917/23: lst_job_ads[3]
917/24: lst_job_ads[4]
917/25: lst_job_ads[5]
917/26: lst_job_ads[6]
917/27: lst_job_ads[7]
917/28: lst_job_ads[8]
917/29: lst_job_ads[9]
917/30: lst_job_ads[10]
917/31: lst_job_ads[11]
917/32: lst_job_ads[12]
917/33: lst_job_ads[13]
917/34: lst_job_ads[14]
917/35: lst_job_ads[15]
917/36: lst_job_ads[13]
917/37: lst_job_ads[14]
917/38: lst_job_ads[15]
917/39: scrape = ScrapeJobsPage()
917/40: scrape.scrollDowninSubWindow
917/41: scrape.scrollDowninSubWindow()
917/42: scrape.scrollDowninSubWindow()
917/43: lst_job_ads[15]
917/44: lst_job_ads[14]
917/45: soup = BeautifulSoup(driver.page_source, "html.parser")
917/46: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
917/47: lst_job_ads[15]
917/48: lst_job_ads[15]
917/49: lst_job_ads[16]
917/50: lst_job_ads[17]
917/51: lst_job_ads[18]
917/52: lst_job_ads[19]
917/53: lst_job_ads[20]
917/54: lst_job_ads[21]
917/55: lst_job_ads[22]
918/1:
from job_application_filter import *
from bs4 import BeautifulSoup
918/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
918/3: login.SignIn()
918/4: navigate.clickJobs()
918/5: navigate.clickUKJuniorDataScientist()
918/6: scrape.retrieveInfo()
919/1:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
919/2:
login = Login(driver, data)
navigate = NavigateLinkedIn()
919/3:
from job_application_filter import *
from bs4 import BeautifulSoup
919/4:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
919/5:
login = Login(driver, data)
navigate = NavigateLinkedIn()
919/6: login.SignIn()
919/7: navigate.clickJobs()
919/8: navigate.clickUKJuniorDataScientist()
919/9: soup = BeautifulSoup(driver.page_source, "html.parser")
919/10: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
919/11: lst_job_ads[15]
919/12: lst_job_ads[16]
919/13: lst_job_ads[15]
919/14: lst_job_ads[16]
919/15: lst_job_ads[17]
919/16: lst_job_ads[18]
919/17: scrape = ScrapeJobsPage()
919/18: scrape.scrollDowninSubWindow()
919/19: soup = BeautifulSoup(driver.page_source, "html.parser")
919/20: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
919/21: lst_job_ads[18]
920/1:
from job_application_filter import *
from bs4 import BeautifulSoup
920/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
920/3: login.SignIn()
920/4: navigate.clickJobs()
920/5: navigate.clickUKJuniorDataScientist()
920/6: scrape.retrieveInfo()
920/7: scrape.dict_html_content[1]
920/8: job_ad[24]
920/9: self.lst_job_ads[24]
920/10: scrape.lst_job_ads[24]
920/11: scrape.lst_job_ads[25]
920/12: scrape.retrieveFinalPageNumber()
921/1:
from job_application_filter import *
from bs4 import BeautifulSoup
921/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
921/3:
login = Login(driver, data)
navigate = NavigateLinkedIn()
921/4: login.SignIn()
921/5: navigate.clickJobs()
921/6: navigate.clickUKJuniorDataScientist()
921/7: soup = BeautifulSoup(driver.page_source, "html.parser")
921/8: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
921/9: lst_job_ads[18]
921/10: scrape = ScrapeJobsPage()
921/11: scrape.scrollDowninSubWindow()
921/12:
from selenium import webdriver

browser = webdriver.Chrome()
browser.set_window_size(1000, 1000)
922/1:
from job_application_filter import *
from bs4 import BeautifulSoup
922/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
922/3:
login = Login(driver, data)
navigate = NavigateLinkedIn()
922/4: login.SignIn()
922/5: navigate.clickJobs()
922/6: navigate.clickUKJuniorDataScientist()
922/7: scarpe.driver.set_window_size(1000, 1000)
922/8: scrape = ScrapeJobsPage()
922/9: scarpe.driver.set_window_size(1000, 1000)
922/10: scrape.driver.set_window_size(1000, 1000)
922/11: scrape.driver.set_window_size(500, 500)
922/12: scrape.driver.set_window_size(2000, 2000)
922/13: scrape.driver.set_window_size(1000, 1000)
922/14: scrape.driver.execute_script("$('#values').css('zoom', 5);")
922/15: scrape.driver.execute_script("document.body.style.zoom='zoom %'")
922/16: scrape.driver.execute_script("document.body.style.zoom='zoom 50'")
922/17: scrape.driver.execute_script("document.body.style.zoom='zoom 5'")
922/18:
scrape.driver.execute_script('document.body.style.MozTransform = "scale(0.2)";')
scrape.driver.execute_script('document.body.style.MozTransformOrigin = "0 0";')
922/19:
scrape.driver.execute_script('document.body.style.MozTransform = "scale(1.0)";')
scrape.driver.execute_script('document.body.style.MozTransformOrigin = "0 0";')
922/20: scrape.driver.execute_script('document.body.style.MozTransform = "scale(1.0)";')
922/21: scrape.driver.execute_script('document.body.style.MozTransformOrigin = "0 0";')
922/22: scrape.scrollDowninSubWindow()
922/23: scrape.driver.execute_script('document.body.style.MozTransform = "scale(1.0)";')
922/24: scrape.driver.execute_script('document.body.style.MozTransformOrigin = "0 0";')
924/1:
from job_application_filter import *
from bs4 import BeautifulSoup
924/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
924/3: login.SignIn()
924/4: navigate.clickJobs()
924/5: navigate.clickUKJuniorDataScientist()
925/1:
from job_application_filter import *
from bs4 import BeautifulSoup
925/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
925/3: login.SignIn()
925/4: navigate.clickJobs()
925/5: navigate.clickUKJuniorDataScientist()
925/6:
for i in range(3):
    scrape.driver.find_element_by_tag_name("html").send_keys(Keys.chord(Keys.CONTROL,Keys.SUBTRACT)).perform()
925/7:
for i in range(3):
    scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL,Keys.SUBTRACT).perform()
925/8:
for i in range(3):
    scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL,Keys.SUBTRACT)
925/9:
for i in range(3):
    scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL,Keys.SUBTRACT)
925/10:
for i in range(50):
    scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL,Keys.SUBTRACT)
925/11:
for i in range(3):
    scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL,Keys.SUBTRACT)
925/12: scrape.driver.find_element_by_tag_name("html")
925/13: scrape.driver.find_element_by_tag_name("html").send_keys(Keys.SPACE)
925/14: scrape.driver.find_element_by_tag_name("html").send_keys(Keys.SUBTRACT)
925/15: scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL, Keys.SUBTRACT)
925/16: scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL, Keys.SPACE)
925/17:
for i in range(3):
    scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL, Keys.SUBTRACT)
925/18: scrape.driver.find_element_by_tag_name("html").send_keys(Keys.SPACE)
925/19: scrape.driver.find_element_by_tag_name("html").send_keys(Keys.CONTROL, Keys.SPACE)
925/20: scrape.driver.find_element_by_tag_name("html").send_keys((Keys.CONTROL, Keys.SPACE))
925/21: scrape.driver.find_element_by_tag_name("html").send_keys((Keys.CONTROL, Keys.SUBSTRACT))
925/22: scrape.driver.find_element_by_tag_name("html").send_keys((Keys.CONTROL, Keys.SUBTRACT))
925/23: scrape.driver.find_element_by_tag_name("html").send_keys(Keys.SPACE)
925/24: ActionChains(scrape.driver).send_keys(Keys.CONTROL, Keys.SUBTRACT).perform()
925/25: from selenium.webdriver.common.action_chains import ActionChains
925/26: ActionChains(scrape.driver).send_keys(Keys.CONTROL, Keys.SUBTRACT).perform()
925/27: ActionChains(scrape.driver).send_keys(Keys.CONTROL, Keys.SUBTRACT).perform()
925/28: ActionChains(scrape.driver.find_element_by_tag_name("html")).send_keys(Keys.CONTROL, Keys.SUBTRACT).perform()
925/29: ActionChains(scrape.driver).send_keys(Keys.CONTROL, Keys.SUBTRACT).perform()
926/1:
from job_application_filter import *
from bs4 import BeautifulSoup
926/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
926/3: login.SignIn()
926/4: navigate.clickJobs()
926/5: navigate.clickUKJuniorDataScientist()
926/6: scrape.retrieveInfo()
927/1:
from job_application_filter import *
from bs4 import BeautifulSoup
927/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
927/3: login.SignIn()
927/4: navigate.clickJobs()
927/5: navigate.clickUKJuniorDataScientist()
927/6: scrape.retrieveInfo()
927/7:
from job_application_filter import *
from bs4 import BeautifulSoup
927/8:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
927/9:
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
927/10: login.SignIn()
927/11: navigate.clickJobs()
927/12: navigate.clickUKJuniorDataScientist()
927/13: soup = BeautifulSoup(driver.page_source, "html.parser")
927/14: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
927/15: lst_job_ads[18]
927/16: lst_job_ads[18]
927/17: soup = BeautifulSoup(driver.page_source, "html.parser")
927/18: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
927/19: lst_job_ads[18]
927/20:
for job_ad in lst_job_ads:
    reference_button = self.driver.find_element_by_id("{}".format(job_ID))
    self.clickElement(reference_button, 392, 18)
    self.passHTMLContenttoBeautifulSoup()
927/21: job_ad
927/22: lst_job_ads[0]
927/23: lst_job_ads[0].find("h3")["id"]
927/24: scrape
927/25: scrape.clickElement
927/26: scrape.driver.find_element_by_id("{}".format('ember1392'))
927/27: reference_button = scrape.driver.find_element_by_id("{}".format('ember1392'))
927/28: reference_button = scrape.driver.find_element_by_id("{}".format('ember1392'))
927/29: scrape.clickElement(reference_button)
927/30: scrape.clickElement(reference_button, 181,354)
927/31: scrape.clickElement(reference_button, 181,354)
927/32: scrape.clickElement(reference_button, 0,0)
927/33: scrape.clickElement(reference_button, 392,18)
928/1:
from job_application_filter import *
from bs4 import BeautifulSoup
928/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
928/3: login.SignIn()
928/4: navigate.clickJobs()
928/5: navigate.clickUKJuniorDataScientist()
928/6: scrape.retrieveInfo()
928/7:
from job_application_filter import *
from bs4 import BeautifulSoup
928/8:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
928/9:
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
928/10: login.SignIn()
928/11: navigate.clickJobs()
928/12: navigate.clickUKJuniorDataScientist()
928/13: navigate.clickUKJuniorDataScientist()
928/14: soup = BeautifulSoup(driver.page_source, "html.parser")
928/15: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
928/16: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
928/17: lst_job_ads[18]
928/18: lst_job_ads[18]
928/19: lst_job_ads[18]
928/20: soup = BeautifulSoup(driver.page_source, "html.parser")
928/21: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
928/22: lst_job_ads[18]
928/23: soup.find("svg")
928/24: scrape.driver.find_element_by_tag_name("svg")
928/25: scrape.driver.find_element_by_tag_name("svg").click()
928/26: lst_job_ads[0].find("h3")["id"]
928/27: scrape.driver.find_element_by_tag_name("svg").click()
928/28: scrape.driver.find_element_by_tag_name("svg")
928/29: scrape.driver.find_element_by_tag_name("svg")
928/30: scrape.driver.find_element_by_tag_name("li-icon")
928/31: scrape.driver.find_element_by_xpath('//li-icon[@type="cancel-icon"]')
928/32: scrape.driver.find_element_by_xpath('//li-icon[@type="cancel-icon"]').click()
928/33: scrape.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()
928/34: scrape.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()
929/1:
from job_application_filter import *
from bs4 import BeautifulSoup
929/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
929/3: login.SignIn()
929/4: navigate.clickJobs()
929/5: navigate.clickUKJuniorDataScientist()
929/6: scrape.retrieveInfo()
929/7:
from job_application_filter import *
from bs4 import BeautifulSoup
929/8:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
929/9:
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
929/10: login.SignIn()
929/11: navigate.clickJobs()
929/12: navigate.clickUKJuniorDataScientist()
929/13: soup = BeautifulSoup(driver.page_source, "html.parser")
929/14: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
929/15: lst_job_ads[18]
929/16: lst_job_ads[0].find("h3")["id"]
929/17:
company_name = job_ad.find("h4").text.strip()
company_name
929/18:
company_name = lst_job_ads[18].find("h4").text.strip()
company_name
929/19:
company_name = lst_job_ads[18].find("a").text.strip()
company_name
929/20:
company_name = lst_job_ads[18].find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
company_name
930/1:
from job_application_filter import *
from bs4 import BeautifulSoup
930/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
930/3:
from job_application_filter import *
from bs4 import BeautifulSoup
930/4:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
930/5: login.SignIn()
930/6: navigate.clickJobs()
930/7: navigate.clickUKJuniorDataScientist()
930/8: scrape.retrieveInfo()
931/1:
from job_application_filter import *
from bs4 import BeautifulSoup
931/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
931/3: login.SignIn()
931/4: navigate.clickJobs()
931/5: navigate.clickUKJuniorDataScientist()
931/6: navigate.clickUKJuniorDataScientist()
931/7: scrape.retrieveInfo()
932/1:
from job_application_filter import *
from bs4 import BeautifulSoup
932/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
932/3: login.SignIn()
932/4: navigate.clickJobs()
932/5: navigate.clickUKJuniorDataScientist()
932/6: navigate.clickJobs()
932/7: navigate.clickUKJuniorDataScientist()
932/8: scrape.retrieveInfo()
933/1:
from job_application_filter import *
from bs4 import BeautifulSoup
933/2:
from job_application_filter import *
from bs4 import BeautifulSoup
933/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
933/4: login.SignIn()
933/5: navigate.clickJobs()
933/6: navigate.clickUKJuniorDataScientist()
933/7: scrape.retrieveInfo()
933/8: scrape.initialiseCrawler()
934/1:
from job_application_filter import *
from bs4 import BeautifulSoup
934/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
934/3: login.SignIn()
934/4: navigate.clickJobs()
934/5: navigate.clickUKJuniorDataScientist()
934/6: scrape.initialiseCrawler()
935/1:
from job_application_filter import *
from bs4 import BeautifulSoup
935/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
935/3: login.SignIn()
935/4: navigate.clickJobs()
935/5: navigate.clickUKJuniorDataScientist()
935/6: scrape.initialiseCrawler()
936/1:
from job_application_filter import *
from bs4 import BeautifulSoup
936/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
937/1:
from job_application_filter import *
from bs4 import BeautifulSoup
937/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
937/3: login.SignIn()
937/4: navigate.clickJobs()
937/5: navigate.clickUKJuniorDataScientist()
937/6: scrape.initialiseCrawler()
938/1:
from job_application_filter import *
from bs4 import BeautifulSoup
938/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
938/3: login.SignIn()
938/4: navigate.clickJobs()
938/5: navigate.clickUKJuniorDataScientist()
938/6: scrape.initialiseCrawler()
939/1:
from job_application_filter import *
from bs4 import BeautifulSoup
939/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
939/3: login.SignIn()
939/4: navigate.clickJobs()
939/5: navigate.clickUKJuniorDataScientist()
939/6: scrape.initialiseCrawler()
940/1:
from job_application_filter import *
from bs4 import BeautifulSoup
940/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
940/3: login.SignIn()
940/4: navigate.clickJobs()
941/1:
from job_application_filter import *
from bs4 import BeautifulSoup
941/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
941/3: login.SignIn()
941/4: navigate.clickJobs()
941/5: navigate.clickUKJuniorDataScientist()
941/6: scrape.initialiseCrawler()
941/7: scrape.df
941/8: scrape.df.to_csv("job_scraped.csv")
941/9: scrape.df
942/1:
from job_application_filter import *
from bs4 import BeautifulSoup
942/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
942/3: login.SignIn()
942/4: navigate.clickJobs()
942/5: navigate.clickJobs()
942/6: navigate.clickUKJuniorDataScientist()
942/7: navigate.clickUKJuniorDataScientist()
942/8: scrape.initialiseCrawler()
943/1:
from job_application_filter import *
from bs4 import BeautifulSoup
943/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
943/3:
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
943/4: login.SignIn()
943/5: navigate.clickJobs()
943/6: navigate.clickUKJuniorDataScientist()
943/7: navigate.clickUKJuniorDataScientist()
943/8: soup = BeautifulSoup(driver.page_source, "html.parser")
943/9: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
943/10: lst_job_ads[18]
943/11: lst_job_ads[0]
943/12: scrape.retrieveJobAdID(lst_job_ads[0])
943/13: scrape.retrievePositionLevelandApplicantCount()
943/14: soup.find("div", class_ = "pr2").text.strip()
943/15: soup.find("div", class_ = "pr2").text.strip()
943/16: soup.find("div", class_ = "pr2").text.strip()
943/17: scrape.retrievePositionLevelandApplicantCount()
943/18: soup
943/19: soup.find("div", class_ = "pr2")
943/20: soup.find("div", class_ = "pr2").text.strip()
943/21: scrape.retrievePositionLevelandApplicantCount()
944/1:
from job_application_filter import *
from bs4 import BeautifulSoup
944/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
944/3: login.SignIn()
944/4: login.SignIn()
944/5: login.SignIn()
945/1:
from job_application_filter import *
from bs4 import BeautifulSoup
945/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
945/3: login.SignIn()
946/1:
from job_application_filter import *
from bs4 import BeautifulSoup
946/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
946/3: login.SignIn()
946/4: navigate.clickJobs()
946/5: navigate.clickUKJuniorDataScientist()
946/6: scrape.initialiseCrawler()
947/1:
from job_application_filter import *
from bs4 import BeautifulSoup
947/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
947/3: login.SignIn()
947/4: navigate.clickJobs()
947/5: navigate.clickUKJuniorDataScientist()
947/6: scrape.initialiseCrawler()
947/7: scrape.df
948/1:
from job_application_filter import *
from bs4 import BeautifulSoup
948/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
948/3: login.SignIn()
948/4: navigate.clickJobs()
948/5: navigate.clickUKJuniorDataScientist()
948/6: scrape.initialiseCrawler()
948/7: scrape.df
949/1:
from job_application_filter import *
from bs4 import BeautifulSoup
949/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
949/3: login.SignIn()
949/4: navigate.clickJobs()
949/5: navigate.clickUKJuniorDataScientist()
949/6: scrape.initialiseCrawler()
949/7: scrape.df
950/1:
from job_application_filter import *
from bs4 import BeautifulSoup
950/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
950/3: login.SignIn()
950/4: navigate.clickJobs()
950/5: navigate.clickUKJuniorDataScientist()
950/6: scrape.initialiseCrawler()
951/1:
from job_application_filter import *
from bs4 import BeautifulSoup
952/1:
from job_application_filter import *
from bs4 import BeautifulSoup
952/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
952/3: login.SignIn()
952/4: navigate.clickJobs()
952/5: navigate.clickUKJuniorDataScientist()
952/6: scrape.initialiseCrawler()
952/7: scrape.df
953/1:
from job_application_filter import *
from bs4 import BeautifulSoup
953/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
953/3: login.SignIn()
953/4: navigate.clickJobs()
953/5: navigate.clickUKJuniorDataScientist()
953/6: scrape.initialiseCrawler()
953/7: scrape.df
953/8: scrape.df["company_name"] == "-"
953/9: (scrape.df["company_name"] == "-").sum
953/10: (scrape.df["company_name"] == "-").sum()
953/11: scrape.df["company_name"]
953/12: scrape.df
954/1:
from job_application_filter import *
from bs4 import BeautifulSoup
954/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
954/3:
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
954/4: login.SignIn()
954/5: navigate.clickJobs()
954/6: navigate.clickUKJuniorDataScientist()
954/7: soup = BeautifulSoup(driver.page_source, "html.parser")
954/8: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
954/9: soup = BeautifulSoup(driver.page_source, "html.parser")
954/10: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
954/11: lst_job_ads[0]
954/12: lst_job_ads[0].find("div", {"id": "ember1635"})
954/13: lst_job_ads[0].find("div")
954/14: soup.find("div", {"id":"ember1635"})
954/15: soup.find("div", {"class":"jobs-description-details"})
954/16: soup.find("div", {"class":"jobs-description-details"})["h3"]
954/17: soup.find("div", {"class":"jobs-description-details"}).findAll("h3")
954/18: soup.find("div", {"class":"jobs-description-details"})
954/19: soup.find("div", {"class":"jobs-description-details"}).findAll("p")
954/20: soup.find("div", {"class":"jobs-description-details"})
954/21: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")
954/22: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0]
954/23: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0]["li"]
954/24: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0]
954/25: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].li
954/26: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0]
954/27: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findall("li")
954/28: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li")
954/29:
initial_text = ""

for text in soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li").text:
    initial_text +=text
954/30:
initial_text = ""

for text in soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li").text():
    initial_text +=text
954/31: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li")[0]
954/32: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li")[0].text
954/33:
initial_text = ""

for part_industry in soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li"):
    initial_text += part_industry.text
954/34: initial_text
954/35:
initial_text = ""

for part_industry in soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li"):
    initial_text += " " + part_industry.text
954/36: initial_text
954/37:
initial_text = ""

for part_industry in soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li"):
    initial_text += part_industry.text + " "
954/38: initial_text
954/39:
initial_text = ""

for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    for part_information in job_description_detail.findall("li"):
        initial_text += part_information.text + " "
    print(initial_text)
954/40:
initial_text = ""

for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    print(job_description_detail)
    for part_information in job_description_detail.findall("li"):
        initial_text += part_information.text + " "
    print(initial_text)
954/41:
initial_text = ""

for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    print(job_description_detail)
    for part_information in job_description_detail.findAll("li"):
        initial_text += part_information.text + " "
    print(initial_text)
954/42:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += part_information.text + " "
    print(initial_text)
954/43: soup = BeautifulSoup(driver.page_source, "html.parser")
954/44: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
954/45:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += part_information.text + " "
    print(initial_text)
954/46:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += part_information.text + "-"
    print(initial_text)
954/47:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "-"+part_information.text
    print(initial_text)
954/48:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "-" + part_information.text
    initial_text += "-"
954/49: initial_text
954/50:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "-" + part_information.text
    initial_text += "-"
954/51: initial_text
954/52:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "-" + part_information.text
    initial_text += "-"
954/53: initial_text
954/54:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "-" + part_information.text
954/55: initial_text
954/56: soup = BeautifulSoup(driver.page_source, "html.parser")
954/57: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
954/58: soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li")[0]
954/59:


for part_industry in soup.find("div", {"class":"jobs-description-details"}).findAll("ul")[0].findAll("li"):
    initial_text += part_industry.text + " "
954/60:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "-" + part_information.text
954/61: initial_text
954/62:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "-" + part_information.text
    print(initial_text + "-")
954/63:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text = initial_text + "-" + part_information.text
    print(initial_text)
954/64:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        if initial_text != "":
            initial_text = initial_text + "-" + part_information.text
    print(initial_text)
954/65:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text = initial_text + "-" + part_information.text
    print(initial_text)
954/66:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "-" + part_information.text
    print(initial_text)
954/67:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "/n" + part_information.text
    print(initial_text)
954/68:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    print(initial_text)
954/69:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    print(initial_text.strip())
954/70:
for job_description_detail in soup.find("div", {"class":"jobs-description-details"}).findAll("ul"):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    print(initial_text.strip())
    print("\n")
954/71:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    print("\n")
954/72: dict_job_details
954/73:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
954/74: dict_job_details
954/75: soup = BeautifulSoup(driver.page_source, "html.parser")
954/76:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
954/77: dict_job_details
954/78: job_description_details
954/79: soup.find("div", {"class":"jobs-description-details"}).
954/80: soup.find("div", {"class":"jobs-description-details"})
954/81: soup.find("div", {"class":"jobs-description-details"}).p3
954/82: soup.find("div", {"class":"jobs-description-details"}).
954/83: soup.find("div", {"class":"jobs-description-details"})
954/84: soup.find("div", {"class":"jobs-description-details"}).p
954/85: soup.find("div", {"class":"jobs-description-details"})
954/86: soup.find("div", {"class":"jobs-description-details"}).p
954/87:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p
dict_job_details["seniority_level"] = seniority_level
954/88: dict_job_details
954/89:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
954/90: dict_job_details
955/1:
from job_application_filter import *
from bs4 import BeautifulSoup
955/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
956/1:
from job_application_filter import *
from bs4 import BeautifulSoup
956/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
956/3: login.SignIn()
956/4: navigate.clickJobs()
956/5: navigate.clickUKJuniorDataScientist()
956/6: navigate.clickUKJuniorDataScientist()
956/7: scrape.initialiseCrawler()
957/1:
from job_application_filter import *
from bs4 import BeautifulSoup
957/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
957/3: login.SignIn()
957/4: navigate.clickJobs()
957/5: navigate.clickUKJuniorDataScientist()
957/6: scrape.initialiseCrawler()
957/7: soup = BeautifulSoup(driver.page_source, "html.parser")
957/8:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
957/9: dict_job_details
957/10: soup.find("div", {"class":"jobs-description-details"}).p.text
957/11: soup = BeautifulSoup(driver.page_source, "html.parser")
957/12:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
957/13: dict_job_details
957/14: soup = BeautifulSoup(driver.page_source, "html.parser")
957/15:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
957/16: dict_job_details
957/17: soup = BeautifulSoup(driver.page_source, "html.parser")
957/18:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
957/19: dict_job_details
957/20: soup = BeautifulSoup(driver.page_source, "html.parser")
957/21:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
957/22: dict_job_details
958/1:
from job_application_filter import *
from bs4 import BeautifulSoup
958/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
958/3:
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
958/4: login.SignIn()
958/5: navigate.clickJobs()
958/6: navigate.clickUKJuniorDataScientist()
958/7: soup = BeautifulSoup(driver.page_source, "html.parser")
958/8:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
958/9: dict_job_details
958/10: soup = BeautifulSoup(driver.page_source, "html.parser")
958/11:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
958/12: dict_job_details
958/13: soup = BeautifulSoup(driver.page_source, "html.parser")
958/14:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
958/15: dict_job_details
959/1:
from job_application_filter import *
from bs4 import BeautifulSoup
959/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
959/3: login.SignIn()
959/4: navigate.clickJobs()
959/5: navigate.clickUKJuniorDataScientist()
959/6: scrape.initialiseCrawler()
959/7: scrape.df
959/8: scrape.soup.find("div", {"class":"jobs-description-details"}).p.text
959/9: scrape.soup.find("div", {"class":"jobs-description-details"})
959/10: scrape.driver.send_keys(Keys.BACKSPACE)
959/11: scrape.driver.(Keys.BACKSPACE)
959/12: scrape.driver.sendKeys(Keys.BACKSPACE)
959/13: scrape.driver.execute_script("window.scrollTo(0, Y)")
959/14: scrape.driver.execute_script("window.scrollTo(0, 50)")
959/15: scrape.driver.execute_script("window.scrollTo(0, 50)")
959/16: scrape.driver.execute_script("window.scrollTo(0, 1500)")
959/17: scrape.driver.execute_script("window.scrollTo(0, 1500)")
959/18: scrape.dict_html_content[1]
959/19: scrape.driver.execute_script("window.scrollTo(0, 1500)")
959/20: scrape.driver.execute_script("window.scrollTo(0, 1500)")
959/21: scrape.driver.execute_script("window.scrollTo(0, 1500)")
959/22: scrape.driver.execute_script("window.scrollTo(0, 50000)")
959/23: scrape.driver.execute_script("window.scrollTo(0, 50000)")
959/24: scrape.driver.execute_script("window.scrollTo(0, 1)")
959/25:
from selenium.webdriver.common.keys import Keys
html = browser.find_element_by_tag_name('html')
html.send_keys(Keys.END)
959/26:
from selenium.webdriver.common.keys import Keys
html = scraper.driver.find_element_by_tag_name('html')
html.send_keys(Keys.END)
959/27:
from selenium.webdriver.common.keys import Keys
html = scrape.driver.find_element_by_tag_name('html')
html.send_keys(Keys.END)
960/1:
from job_application_filter import *
from bs4 import BeautifulSoup
960/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
960/3: login.SignIn()
960/4: navigate.clickJobs()
960/5: navigate.clickUKJuniorDataScientist()
960/6: scrape.initialiseCrawler()
961/1:
from job_application_filter import *
from bs4 import BeautifulSoup
961/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
961/3: login.SignIn()
961/4: navigate.clickJobs()
961/5: navigate.clickUKJuniorDataScientist()
961/6: navigate.clickUKJuniorDataScientist()
961/7: scrape.initialiseCrawler()
962/1:
from job_application_filter import *
from bs4 import BeautifulSoup
962/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
962/3: login.SignIn()
962/4: navigate.clickJobs()
962/5: navigate.clickUKJuniorDataScientist()
962/6: scrape.initialiseCrawler()
962/7: scrape.soup.find("div", {"class":"jobs-description-details"}).p.text
962/8: scrape.soup.find("div", {"class":"jobs-description-details"})
962/9: scrape.soup.find("div", {"class":"jobs-description-details"}).p.text
962/10: scrape.soup.find("div", {"class":"jobs-description-details"})
963/1:
from job_application_filter import *
from bs4 import BeautifulSoup
963/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
963/3:
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
963/4: login.SignIn()
963/5: navigate.clickJobs()
963/6: navigate.clickUKJuniorDataScientist()
963/7: soup = BeautifulSoup(driver.page_source, "html.parser")
963/8:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
963/9: dict_job_details
963/10: scrape.scrollDowninMainWindow()
963/11: dict_job_details
963/12: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
963/13: scrape.retrieveJobAdID(job_ad)
963/14: scrape.retrieveJobAdID(lst_job_ads[0])
963/15: scrape.retrieveJobAdID(lst_job_ads[1])
963/16:
reference_button = scrape.driver.find_element_by_id("{}".format('ember1454'))
scrape.clickElement(reference_button, 0, 0)
scrape.passHTMLContenttoBeautifulSoup()
964/1:
from job_application_filter import *
from bs4 import BeautifulSoup
964/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
964/3: login.SignIn()
964/4: navigate.clickJobs()
964/5: navigate.clickUKJuniorDataScientist()
964/6: navigate.clickUKJuniorDataScientist()
964/7: scrape.initialiseCrawler()
964/8:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
964/9: soup = BeautifulSoup(driver.page_source, "html.parser")
964/10: lst_job_ads = soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
964/11:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
964/12: dict_job_details
964/13: scrape.scrollDowninMainWindow()
964/14: scrape.retrieveJobAdID(lst_job_ads[1])
964/15:
reference_button = scrape.driver.find_element_by_id("{}".format(job_id))
scrape.clickElement(reference_button, 0, 0)
scrape.passHTMLContenttoBeautifulSoup()
964/16: job_id = scrape.retrieveJobAdID(lst_job_ads[1])
964/17:
reference_button = scrape.driver.find_element_by_id("{}".format(job_id))
scrape.clickElement(reference_button, 0, 0)
scrape.passHTMLContenttoBeautifulSoup()
964/18: job_id = scrape.retrieveJobAdID(lst_job_ads[2])
964/19:
reference_button = scrape.driver.find_element_by_id("{}".format(job_id))
scrape.clickElement(reference_button, 0, 0)
scrape.passHTMLContenttoBeautifulSoup()
964/20: job_id = scrape.retrieveJobAdID(lst_job_ads[2])
964/21:
reference_button = scrape.driver.find_element_by_id("{}".format(job_id))
scrape.clickElement(reference_button, 0, 0)
scrape.scrollDowninMainWindow()
scrape.passHTMLContenttoBeautifulSoup()
964/22:
reference_button = scrape.driver.find_element_by_id("{}".format(job_id))
scrape.clickElement(reference_button, 0, 0)
scrape.scrollDowninMainWindow()
scrape.passHTMLContenttoBeautifulSoup()
964/23: scrape.driver.execute_script("scroll(0, 250);");
964/24: scrape.driver.execute_script("scroll(0, 250);");
964/25: scrape.driver.execute_script("scroll(0, 500);");
964/26: scrape.driver.execute_script("scroll(0, 500);");
964/27: scrape.driver.execute_script("scroll(0, 500);");
964/28: scrape.driver.execute_script("scroll(0, 2000);");
964/29: element=scrape.driver.find_element_by_xpath('//div[@class="job-description-details"]')
964/30: element=scrape.driver.find_element_by_xpath('//div[@class="job-description"]')
964/31: element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
964/32:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view
964/33:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view
964/34:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view
964/35: soup = BeautifulSoup(driver.page_source, "html.parser")
964/36:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view
964/37:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view
964/38:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view()
964/39:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view
964/40:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view
964/41:
element=scrape.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
element.location_once_scrolled_into_view
965/1:
from job_application_filter import *
from bs4 import BeautifulSoup
965/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
965/3: login.SignIn()
965/4: navigate.clickJobs()
965/5: navigate.clickUKJuniorDataScientist()
965/6: scrape.initialiseCrawler()
966/1: login.SignIn()
966/2:
from job_application_filter import *
from bs4 import BeautifulSoup
966/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
966/4: login.SignIn()
966/5: navigate.clickJobs()
966/6: navigate.clickUKJuniorDataScientist()
966/7: scrape.initialiseCrawler()
967/1:
from job_application_filter import *
from bs4 import BeautifulSoup
967/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
967/3: login.SignIn()
967/4: navigate.clickJobs()
967/5: navigate.clickUKJuniorDataScientist()
967/6: scrape.initialiseCrawler()
967/7: scrape.df
967/8: soup = BeautifulSoup(driver.page_source, "html.parser")
967/9:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
967/10: dict_job_details
967/11:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
967/12: dict_job_details
967/13: soup = BeautifulSoup(driver.page_source, "html.parser")
967/14:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
967/15: dict_job_details
967/16:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
967/17: dict_job_details
967/18: soup = BeautifulSoup(driver.page_source, "html.parser")
967/19:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
967/20: dict_job_details
967/21: soup = BeautifulSoup(driver.page_source, "html.parser")
967/22:
dict_job_details = {}
information_order = ["industry","job_function"]
job_description_details = soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

for job_description_detail, io in zip(job_description_details , information_order):
    initial_text = ""
    for part_information in job_description_detail.findAll("li"):
        initial_text += "\n" + part_information.text
    dict_job_details[io] = initial_text.strip()
    
seniority_level = soup.find("div", {"class":"jobs-description-details"}).p.text
dict_job_details["seniority_level"] = seniority_level
967/23: dict_job_details
967/24: scrape.soup.find("div", {"class":"jobs-description-details"}).p.text
967/25: scrape.soup.find("div", {"class":"jobs-description-details"})
967/26: scrape.soup
967/27: scrape.soup.find("div")
967/28: scrape.soup.find("div", {"class":"jobs-description-details"})
967/29: scrape.soup.find("div", {"class":"jobs-description-details pt4 pt4 ember-view"})
967/30:
scrape.passHTMLContenttoBeautifulSoup()
scrape.soup.find("div", {"class":"jobs-description-details pt4 pt4 ember-view"})
967/31:
scrape.passHTMLContenttoBeautifulSoup()
scrape.soup.find("div", {"class":"jobs-description-details pt4 pt4 ember-view"})
967/32:
scrape.passHTMLContenttoBeautifulSoup()
scrape.soup.find("div", {"class":"jobs-box__group
                         "})
967/33:
scrape.passHTMLContenttoBeautifulSoup()
scrape.soup.find("div", {"class":"jobs-box__group"})
967/34: scrape.dict_html_content[1]
967/35: scrape.dict_html_content[1].find("div", {"class":"jobs-box__group"})
967/36: scrape.dict_html_content[1]
967/37: soup(scrape.dict_html_content[1])
967/38: scrape.dict_html_content[1]
967/39:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        element=self.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
        element.location_once_scrolled_into_view


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                self.retrieveInText_Industry_JobFunction_Seniority()

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                print(data_to_add)

                time.sleep(0.5)

            # if page == 6:
            #     return None
967/40:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        element=self.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
        element.location_once_scrolled_into_view


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                self.retrieveInText_Industry_JobFunction_Seniority()

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                print(data_to_add)

                time.sleep(0.5)
967/41:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
scrape = ScrapeJobsPage()
967/42: login.SignIn()
967/43: navigate.clickJobs()
967/44: navigate.clickUKJuniorDataScientist()
967/45: scrape.initialiseCrawler()
967/46: scrape.text
967/47: scrape.soup
967/48: scrape.soup.find("div", {"class":"jobs-description-details"})
967/49: scrape.soup.find("div", {"class":"jobs-box__group"})
967/50: scrape.soup.find("div", {"class":"jobs-box__group"})
967/51: scrape.soup.find("div", {"class":"jobs-box__group"})
967/52: scrape.soup.find("div", {"class":"jobs-box__group"})
967/53: scrape.soup.find("div", {"class":"jobs-box__group"}).p
967/54: scrape.soup.find("div", {"class":"jobs-box__group"})
967/55: scrape.soup.find("p", {"class":"jobs-box__group"})
967/56: scrape.soup.find("p", {"class":"jobs-box__body js-formatted-exp-body
967/57: scrape.soup.find("p", {"class":"jobs-box__body js-formatted-exp-body})
967/58: scrape.soup.find("p", {"class":"jobs-box__body js-formatted-exp-body"})
967/59:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        element=self.driver.find_element_by_xpath('//div[@class="jobs-description-details pt4 pt4 ember-view"]')
        element.location_once_scrolled_into_view


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                self.retrieveInText_Industry_JobFunction_Seniority()

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                print(data_to_add)

                time.sleep(0.5)
967/60: scrape.initialiseCrawler()
967/61: scrape = ScrapeJobsPage()
967/62: login.SignIn()
967/63: scrape.initialiseCrawler()
967/64: scrape.soup
967/65: scrape.soup.find("p", {"class":"jobs-box__body js-formatted-exp-body"})
967/66: scrape.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")
967/67: scrape.soup.find("div", {"class":"jobs-details-job-summary__list jobs-details-job-summary__list--divider pr2 ml5"})
967/68: scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
967/69:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                self.retrieveInText_Industry_JobFunction_Seniority()

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                print(data_to_add)

                time.sleep(0.5)
967/70: scrape = ScrapeJobsPage()
967/71: scrape.scrollDowninRightSubWindow()
967/72: scrape.scrollDowninRightSubWindow()
967/73: scrape.scrollDowninRightSubWindow()
967/74:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(1):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                self.retrieveInText_Industry_JobFunction_Seniority()

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                print(data_to_add)

                time.sleep(0.5)
967/75: scrape.scrollDowninRightSubWindow()
967/76:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(1):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                self.retrieveInText_Industry_JobFunction_Seniority()

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                print(data_to_add)

                time.sleep(0.5)
967/77: scrape = ScrapeJobsPage()
967/78: scrape.initialiseCrawler()
967/79: dict_ = {'company_name': 'Bridebook.co.uk', 'company_size': '2-10', 'company_sector': '', 'company_sector_in_text': 'Marketing & Advertising', 'job_title': 'Junior Data Scientist, Product', 'position_level': '', 'seniority_level_in_text': 'Associate', 'job_function_in_text': 'Product Management\nAnalyst\nStrategy/Planning', 'applicant_count': '65', 'job_location': 'London, England, United Kingdom', 'job_post_date': datetime.datetime(2020, 1, 13, 0, 0), 'days_since_posted': 6, 'job_href': 'www.linkedin.com/jobs/view/1639084500/?eBP=CwEAAAFvvYiP4tpZfOkFHn9X2usqusoBUvn-ju4P50JTYtY0qLORI0GSvgIHapmD_y8qQPl09UN-sIW4EApLGk_aEwO5EENf-f8LYFuLcBuemscSRLgTNsspu3W0ajb8uL31_Ma4FPMMn7FLWbhXObfbSJS_ggOln1S2C4mnfpDyqOVZeVB5xKPs1SjMcz_ptlafR_HiqmlAeYcLcR9SZRKukNNyNPOuIrBDpRVImdBwkZGhgszLDNZnU-u0ZhURmuSJv6O2azZU0a86ROnpmzzXmJBlPxs2zXCxKAHnKepk9Oz4ffhqn2F3Q_9y5QABinx8wsp0_5dL4KZER3YEhqRnGmQBNvFc5ajHp-1ZBLCpJhr443Hqw3rsWOmTqID4OHny7Wl-UH9iDnR5YB4iXoiqxvaQfsn6AwN-hnvRj-RG&refId=b77e5c70-fd98-4fb8-995f-af00da100e9a&spSrc=CwEAAAFvvYiP_kYBRaBsRFq6oBS8_8BpavY0duQ0fgyjnsPlbDKixwsXS-X67XuLr_by-9zPDtaIe0JaAGTuGlgcCZs&trk=d_flagship3_search_srp_jobs'}
967/80: dict_ = {'company_name': 'Bridebook.co.uk', 'company_size': '2-10', 'company_sector': '', 'company_sector_in_text': 'Marketing & Advertising', 'job_title': 'Junior Data Scientist, Product', 'position_level': '', 'seniority_level_in_text': 'Associate', 'job_function_in_text': 'Product Management\nAnalyst\nStrategy/Planning', 'applicant_count': '65', 'job_location': 'London, England, United Kingdom', 'job_post_date': "13/01/2020", 'days_since_posted': 6, 'job_href': 'www.linkedin.com/jobs/view/1639084500/?eBP=CwEAAAFvvYiP4tpZfOkFHn9X2usqusoBUvn-ju4P50JTYtY0qLORI0GSvgIHapmD_y8qQPl09UN-sIW4EApLGk_aEwO5EENf-f8LYFuLcBuemscSRLgTNsspu3W0ajb8uL31_Ma4FPMMn7FLWbhXObfbSJS_ggOln1S2C4mnfpDyqOVZeVB5xKPs1SjMcz_ptlafR_HiqmlAeYcLcR9SZRKukNNyNPOuIrBDpRVImdBwkZGhgszLDNZnU-u0ZhURmuSJv6O2azZU0a86ROnpmzzXmJBlPxs2zXCxKAHnKepk9Oz4ffhqn2F3Q_9y5QABinx8wsp0_5dL4KZER3YEhqRnGmQBNvFc5ajHp-1ZBLCpJhr443Hqw3rsWOmTqID4OHny7Wl-UH9iDnR5YB4iXoiqxvaQfsn6AwN-hnvRj-RG&refId=b77e5c70-fd98-4fb8-995f-af00da100e9a&spSrc=CwEAAAFvvYiP_kYBRaBsRFq6oBS8_8BpavY0duQ0fgyjnsPlbDKixwsXS-X67XuLr_by-9zPDtaIe0JaAGTuGlgcCZs&trk=d_flagship3_search_srp_jobs'}
967/81:
for key,value in dict_.items():
    print(key, value)
967/82:
for key,value in dict_.items():
    print(key+":", value)
967/83:
for key,value in dict_.items():
    if not key "job_href":
        print(key+":", value)
967/84:
for key,value in dict_.items():
    if key != "job_href":
        print(key+":", value)
967/85:
for key,value in dict_.items():
    if key != "job_href":
        print(key+":", value)
print("\n")
967/86:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def displayInformation(self, dict_):
        for key,value in dict_.items():
            if key != "job_href":
            print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                try:
                    self.retrieveInText_Industry_JobFunction_Seniority()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
967/87:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def displayInformation(self, dict_):
        for key,value in dict_.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                try:
                    self.retrieveInText_Industry_JobFunction_Seniority()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
967/88: scrape = ScrapeJobsPage()
967/89: scrape.initialiseCrawler()
967/90: scrape.job_href
967/91: scrape.df
968/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
        self.clickSignIn()
        self.email.send_keys(list(self.data.values())[0])
        self.password.send_keys(list(self.data.values())[1])
        self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                try:
                    self.retrieveInText_Industry_JobFunction_Seniority()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
968/3: login.SignIn()
968/4: scrape = ScrapeJobsPage()
968/5: navigate.clickJobs()
968/6: navigate.clickUKJuniorDataScientist()
968/7: scrape.initialiseCrawler()
968/8: scrape.job_href
968/9: scrape.df
968/10: scrape.df.iloc[0, -1]
968/11: scrape = ScrapeJobsPage()
968/12:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                try:
                    self.retrieveInText_Industry_JobFunction_Seniority()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                print(data_to_add)

                time.sleep(0.5)
968/13: scrape = ScrapeJobsPage()
968/14: scrape.initialiseCrawler()
968/15:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, dict_):
        for key,value in dict_.items():
            if key != "job_href":
            print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                try:
                    self.retrieveInText_Industry_JobFunction_Seniority()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/16:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                try:
                    self.retrieveInText_Industry_JobFunction_Seniority()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/17:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                try:
                    self.retrieveInText_Industry_JobFunction_Seniority()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/18: scrape.initialiseCrawler()
968/19:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInText_Industry_JobFunction_Seniority(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]


    def retrieveInformation(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformation(job_ad)
                except Exception as error:
                    self.company_name = "-"
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.job_title = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error

                try:
                    self.retrieveInText_Industry_JobFunction_Seniority()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/20: scrape = ScrapeJobsPage()
968/21: scrape.initialiseCrawler()
968/22: scrape.df
968/23:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector': [],
                                'company_sector_in_text': [],
                                'job_title': [],
                                'position_level': [],
                                'seniority_level_in_text': [],
                                'job_function_in_text': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })


    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


    def retrieveJobTitle(self, job_ad):
        try:
            job_title = (job_ad.find("h3").text.strip())
            job_title = re.sub(r"\n|Promoted","", job_title).strip()
            return job_title
        except AttributeError:
            return ""


    def retrieveCompanyName(self, job_ad):
        try:
            company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
            return company_name
        except AttributeError:
            return ""


    def retrieveJobAdID(self, job_ad):
        job_ID = job_ad.find("h3")["id"]
        return job_ID


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            job_location = self.soup.find(id=id_loc).text.strip()
        except:
            job_location = ""
        
        if "applicant" in job_location:
            job_location = ""

        return job_location


    def retrieveJobHREF(self, job_ad):
        job_href = job_ad.a["href"]
        job_href = "www.linkedin.com" + job_href
        return job_href


    def retrieveCompanySizeandCompanySector(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            company_sector = re.search(r"employees? (.+)", company_text)
            if company_sector:
                company_sector = company_sector.group(1)
            else:
                company_sector = ""
            company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            company_sector = ""
            company_size = ""

        return company_size, company_sector


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            position_level = re.search(r" (.+ level)", job_text)
            position_level = position_level.group(1)
        else:
            position_level = ""

        if "applicant" in job_text:
            applicant_count = re.search(r" (\d+) applicants?", job_text)
            applicant_count = applicant_count.group(1)
        else:
            applicant_count = -1

        return position_level, applicant_count
    

    def retrieveJobPostDate(self, job_ad):
        job_post_date = job_ad.find("time")["datetime"]
        return job_post_date


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()
        
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level

        self.company_sector_in_text = dict_job_details["industry"]
        self.job_function_in_text = dict_job_details["job_function"]
        self.seniority_level_in_text = dict_job_details["seniority_level"]

        self.company_size, self.company_sector = self.retrieveCompanySizeandCompanySector()
        self.position_level, self.applicant_count = self.retrievePositionLevelandApplicantCount()


    def retrieveInformationLeftSubWindow(self, job_ad):
        today = datetime.today()
        self.company_name = self.retrieveCompanyName(job_ad)
        self.job_title = self.retrieveJobTitle(job_ad)
        self.job_ID = self.retrieveJobAdID(job_ad)
        self.job_location = self.retrieveJobLocation(self.job_ID)
        self.job_href = self.retrieveJobHREF(job_ad)
        self.job_post_date = self.retrieveJobPostDate(job_ad)

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass

        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')
        self.days_since_posted = (today - self.job_post_date).days


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_in_text = "-"
                    self.job_function_in_text = "-"
                    self.seniority_level_in_text = error2
                    self.company_size = "-"
                    self.company_sector = "-"
                    self.position_level = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector': self.company_sector,
                                'company_sector_in_text': self.company_sector_in_text,
                                'job_title': self.job_title,
                                'position_level': self.position_level,
                                'seniority_level_in_text': self.seniority_level_in_text,
                                'job_function_in_text': self.job_function_in_text,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/24: scrape = ScrapeJobsPage()
968/25: scrape.initialiseCrawler()
968/26: scrape.df.iloc[0, -1]
968/27:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level = re.search(r" (.+ level)", job_text)
            self.position_level = position_level.group(1)
        else:
            self.position_level = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level
        self.position_level_BOTTOM = dict_job_details["seniority_level"]


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted(job_ad)

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/28: scrape = ScrapeJobsPage()
968/29: scrape.initialiseCrawler()
968/30: scrape.df.iloc[0, -1]
968/31:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self, job_ID):
        id_h3 = re.search(r"\d+", job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level = re.search(r" (.+ level)", job_text)
            self.position_level = position_level.group(1)
        else:
            self.position_level = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level
        self.position_level_BOTTOM = dict_job_details["seniority_level"]


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted(job_ad)

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/32: scrape = ScrapeJobsPage()
968/33: scrape.initialiseCrawler()
968/34: scrape.df.iloc[0, -1]
968/35:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level = re.search(r" (.+ level)", job_text)
            self.position_level = position_level.group(1)
        else:
            self.position_level = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level
        self.position_level_BOTTOM = dict_job_details["seniority_level"]


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted(job_ad)

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/36: scrape = ScrapeJobsPage()
968/37: scrape.initialiseCrawler()
968/38: scrape.df.iloc[0, -1]
968/39:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level = re.search(r" (.+ level)", job_text)
            self.position_level = position_level.group(1)
        else:
            self.position_level = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level
        self.position_level_BOTTOM = dict_job_details["seniority_level"]


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted(job_ad)

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/40: scrape = ScrapeJobsPage()
968/41: scrape.initialiseCrawler()
968/42: scrape.df.iloc[0, -1]
968/43:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level = re.search(r" (.+ level)", job_text)
            self.position_level = position_level.group(1)
        else:
            self.position_level = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level
        self.position_level_BOTTOM = dict_job_details["seniority_level"]


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted(job_ad)

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/44: scrape = ScrapeJobsPage()
968/45: scrape.initialiseCrawler()
968/46: scrape.df.iloc[0, -1]
968/47:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level = re.search(r" (.+ level)", job_text)
            self.position_level = position_level.group(1)
        else:
            self.position_level = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        dict_job_details["seniority_level"] = seniority_level
        self.position_level_BOTTOM = dict_job_details["seniority_level"]


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/48: scrape = ScrapeJobsPage()
968/49: scrape.initialiseCrawler()
968/50: scrape.scrollDowninRightSubWindow()
968/51: scrape.retrieveInformationRightSubWindow()
968/52:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level = re.search(r" (.+ level)", job_text)
            self.position_level = position_level.group(1)
        else:
            self.position_level = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/53: scrape = ScrapeJobsPage()
968/54: scrape.scrollDowninRightSubWindow()
968/55: scrape.retrieveInformationRightSubWindow()
968/56:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/57: scrape = ScrapeJobsPage()
968/58: scrape.scrollDowninRightSubWindow()
968/59: scrape.retrieveInformationRightSubWindow()
968/60:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/61: scrape = ScrapeJobsPage()
968/62: scrape.retrieveInformationRightSubWindow()
968/63: scrape.position_level_TOP
968/64: scrape.position_level_BOTTON
968/65: scrape.position_level_BOTTOM
968/66: scrape.initialiseCrawler()
968/67: scrape.retrieveInformationRightSubWindow()
968/68:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector = re.search(r"employees? (.+)", company_text)
            if self.company_sector:
                self.company_sector = self.company_sector.group(1)
            else:
                self.company_sector = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector = ""
            self.company_size = ""

        if "," in self.company_sector:
            if not "&" in self.company_sector:
                self.company_sector = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/69: scrape = ScrapeJobsPage()
968/70: scrape.retrieveInformationRightSubWindow()
968/71: scrape.initialiseCrawler()
968/72:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 92, 54)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/73: scrape = ScrapeJobsPage()
968/74: scrape.initialiseCrawler()
968/75: scrape.retrieveInformationRightSubWindow()
968/76:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()
        self.passHTMLContenttoBeautifulSoup()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/77: scrape = ScrapeJobsPage()
968/78: scrape.initialiseCrawler()
968/79:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):

    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):

        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):

         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action

    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************

    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')

    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************

    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1
            
            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
968/80: scrape = ScrapeJobsPage()
968/81: scrape.initialiseCrawler()
968/82: scrape.df
968/83: scrape.df.to_csv("job_scraped.csv")
969/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
969/3: scrape = ScrapeJobsPage()
969/4: login.SignIn()
969/5:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()



    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/6:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
969/7: scrape = ScrapeJobsPage()
969/8: login.SignIn()
969/9: login.SignIn()
969/10: login.SignIn()
969/11: navigate.clickUKJuniorDataScientist()
969/12: navigate.clickJobs()
969/13: navigate.clickUKJuniorDataScientist()
969/14: scrape.initialiseCrawler()
969/15: scrape.initialiseCrawler("ul", class_ = "salary-main-rail__data-list pb3")
969/16: scrape.initialiseCrawler("ul", "class":"salary-main-rail__data-list pb3")
969/17: scrape.initialiseCrawler("ul", {}"class":"salary-main-rail__data-list pb3"})
969/18: scrape.initialiseCrawler("ul", {"class":"salary-main-rail__data-list pb3"})
969/19: scrape.soup.find("ul", {"class":"salary-main-rail__data-list pb3"})
969/20: scrape.soup.find("ul", {"class":"salary-main-rail__data-list"})
969/21: scrape.soup.find("div", {"class":"salary-main-rail__main-details-container display-flex"})
969/22: scrape.soup.find("div")
969/23: scrape.soup.find("div", class_="salary-main-rail__content-container")
969/24: soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
969/25: soup.find("div", class_="salary-main-rail__content-container")
969/26: soup.find("ul", class_="salary-main-rail__data-list pb3 flex-grow-1  ")
969/27: soup.find("ul", class_="salary-main-rail__data-list pb3 flex-grow-1=")
969/28: soup.find("ul", class_="salary-main-rail__data-list pb3 flex-grow-1")
969/29: soup.find("div", class_="salary-main-rail__data-container")
969/30: soup.find("div", class_="salary-main-rail__data-container").[]
969/31: soup.find("div", class_="salary-main-rail__data-container").p
969/32: soup.find("div", class_="salary-main-rail__data-container").p.text
969/33: soup.find("div", class_="salary-main-rail__data-container")
969/34: soup.find("div", class_="salary-main-rail__data-container").findAll("p")
969/35:
salary_holder = soup.find("div", class_="salary-main-rail__data-container").findAll("p")

for salary_html in salary_holder:
    print(salary_html.p.text)
969/36:
salary_holder = soup.find("div", class_="salary-main-rail__data-container").findAll("p")

for salary_html in salary_holder:
    print(salary_html.p)
969/37:
salary_holder = soup.find("div", class_="salary-main-rail__data-container").findAll("p")

for salary_html in salary_holder:
    print(salary_html)
969/38:
salary_holder = soup.find("div", class_="salary-main-rail__data-container").findAll("p")

for salary_html in salary_holder:
    print(salary_html.text)
969/39:
salary_holder = soup.find("div", class_="salary-main-rail__data-container").findAll("p")

for salary_html in salary_holder:
    test = salary_html.text
969/40: test
969/41: test.strip()
969/42:
salary_holder = soup.find("div", class_="salary-main-rail__data-container").findAll("p")

for salary_html in salary_holder:
    test = salary_html.text
    print(test)
969/43:
salary_holder = soup.find("div", class_="salary-main-rail__data-container").find("p")

for salary_html in salary_holder:
    test = salary_html.text
    print(test)
969/44:
salary_holder = soup.find("div", class_="salary-main-rail__data-container").find("p")

salary_holder.text
969/45:
salary_holder = soup.findAll("div", class_="salary-main-rail__data-container").find("p")

salary_holder
969/46:
salary_holder = soup.find("div", class_="salary-main-rail__data-container")
salary_holder
969/47:
salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
salary_holder
969/48:
salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary in salary_holder:
    print(salar.find("p"))
969/49:
salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary in salary_holder:
    print(salary.find("p"))
969/50:
salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary in salary_holder:
    print(salary.find("p").text)
969/51:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text
969/52: dict_salary_holder
969/53:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text.strip()
969/54: dict_salary_holder
969/55: dict_salary_holder[base_salary]
969/56: dict_salary_holder["base_salary"]
969/57:
to_replace = ["£", ",", "/yr"]

for replace in to_replace:
    dict_salary_holder["base_salary"] = dict_salary_holder["base_salary"].replace(replace, "")
969/58: dict_salary_holder["base_salary"]
969/59:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text.strip()
    
to_replace = ["£", ",", "/yr"]

for replace, salary_type in zip(to_replace, salary_types):
    dict_salary_holder[salary_type] = dict_salary_holder[salary_type].replace(replace, "")
969/60: dict_salary_holder
969/61:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text.strip()
    
to_replace = ["£", ",", "/yr"]

for replace, salary_type in zip(to_replace, salary_types):
    dict_salary_holder[salary_type] = dict_salary_holder[salary_type].replace(replace, "")
969/62: dict_salary_holder
969/63: dict_salary_holder["base_salary"]
969/64:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text.strip()
    
to_replace = ["£", ",", "/yr"]

for replace, salary_type in zip(to_replace, salary_types):
    dict_salary_holder[salary_type] = dict_salary_holder[salary_type].replace(replace, "")
    print(dict_salary_holder
969/65:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text.strip()
    
to_replace = ["£", ",", "/yr"]

for replace, salary_type in zip(to_replace, salary_types):
    dict_salary_holder[salary_type] = dict_salary_holder[salary_type].replace(replace, "")
    print(dict_salary_holder)
969/66: dict_salary_holder["total_compensation"].replace(replace, "")
969/67: dict_salary_holder["total_compensation"].replace("£", "")
969/68:
import re

pattern_to_replace = r"£,/yr"
re.sub(pattern_to_replace, dict_salary_holder["total_compensation"]
969/69:
import re

pattern_to_replace = r"£,/yr"
re.sub(pattern_to_replace, dict_salary_holder["total_compensation"])
969/70:
import re

pattern_to_replace = r"£,/yr"
re.sub(pattern_to_replace, dict_salary_holder["total_compensation"], "")
969/71:
import re

pattern_to_replace = re.compile("£,/yr")
re.sub(pattern_to_replace, dict_salary_holder["total_compensation"], "")
969/72:
import re

pattern_to_replace = re.compile("£,/yr")
re.sub(pattern_to_replace, dict_salary_holder["total_compensation"], "")
969/73:
import re

pattern_to_replace = re.compile("£|,|/yr")
re.sub(pattern_to_replace, dict_salary_holder["total_compensation"], "")
969/74:
import re

pattern_to_replace = re.compile("[£,/yr]")
re.sub(pattern_to_replace, dict_salary_holder["total_compensation"], "")
969/75: dict_salary_holder["total_compensation"]
969/76:
import re

pattern_to_replace = re.compile("[£,/yr]")
re.sub(pattern_to_replace, "", dict_salary_holder["total_compensation"])
969/77:
import re

pattern_to_replace = re.compile("£,/yr")
re.sub(pattern_to_replace, "", dict_salary_holder["total_compensation"])
969/78:
import re

pattern_to_replace = re.compile("[£,/yr]")
re.sub(pattern_to_replace, "", dict_salary_holder["total_compensation"])
969/79:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text.strip()
    
pattern_to_replace = re.compile("[£,/yr]")

for replace, salary_type in zip(to_replace, salary_types):
    dict_salary_holder[salary_type] = sub(pattern_to_replace, "", dict_salary_holder[salary_type])
969/80:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text.strip()
    
pattern_to_replace = re.compile("[£,/yr]")

for replace, salary_type in zip(to_replace, salary_types):
    dict_salary_holder[salary_type] = re.(pattern_to_replace, "", dict_salary_holder[salary_type])
969/81:
salary_types = ["base_salary", "total_compensation"]
dict_salary_holder = {}

salary_holder = soup.findAll("div", class_="salary-main-rail__data-container")
for salary, salary_type in zip(salary_holder, salary_types):
    dict_salary_holder[salary_type] = salary.find("p").text.strip()
    
pattern_to_replace = re.compile("[£,/yr]")

for replace, salary_type in zip(to_replace, salary_types):
    dict_salary_holder[salary_type] = re.sub(pattern_to_replace, "", dict_salary_holder[salary_type])
969/82: dict_salary_holder["total_compensation"\
969/83: dict_salary_holder["total_compensation"]
969/84: dict_salary_holder["base_salary"]
969/85:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': []
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}
        try:
            salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
            for salary, salary_type in zip(salary_holder, salary_types):
                dict_salary_holder[salary_type] = salary.find("p").text.strip()
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""

        pattern_to_replace = re.compile("[£,/yr]")

        for salary_type in salary_types:
            dict_salary_holder[salary_type] = re.sub(pattern_to_replace, "", dict_salary_holder[salary_type])
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/86:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}
        try:
            salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
            for salary, salary_type in zip(salary_holder, salary_types):
                dict_salary_holder[salary_type] = salary.find("p").text.strip()
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""

        pattern_to_replace = re.compile("[£,/yr]")

        for salary_type in salary_types:
            dict_salary_holder[salary_type] = re.sub(pattern_to_replace, "", dict_salary_holder[salary_type])
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/87: scrape = ScrapeJobsPage()
969/88: scrape.initialiseCrawler()
969/89: scrape.df
969/90: scrape.df["position_level_BOTTOM"]
969/91: scrape.df["position_level_BOTTOM"][0]
969/92:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}
        try:
            salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
            for salary, salary_type in zip(salary_holder, salary_types):
                dict_salary_holder[salary_type] = salary.find("p").text.strip()
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""

        pattern_to_replace = re.compile("[£,/yr]")

        for salary_type in salary_types:
            dict_salary_holder[salary_type] = re.sub(pattern_to_replace, "", dict_salary_holder[salary_type])
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/93: scrape = ScrapeJobsPage()
969/94: scrape.initialiseCrawler()
969/95: scrape.df["position_level_BOTTOM"][0]
969/96: scrape.df["position_level_BOTTOM"][1]
969/97: scrape.df["position_level_BOTTOM"][2]
969/98:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}
        try:
            salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
            for salary, salary_type in zip(salary_holder, salary_types):
                dict_salary_holder[salary_type] = salary.find("p").text.strip()
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""

        pattern_to_replace = re.compile("[£,/yr]")

        for salary_type in salary_types:
            dict_salary_holder[salary_type] = re.sub(pattern_to_replace, "", dict_salary_holder[salary_type])
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                # try:
                self.retrieveInformationRightSubWindow()
                # except Exception as error2:
                #     self.company_sector_BOTTOM = "-"
                #     self.job_function = "-"
                #     self.position_level_BOTTOM = error2
                #     self.company_size = "-"
                #     self.company_sector_TOP = "-"
                #     self.position_level_TOP = "-"
                #     self.applicant_count = "-"
                #     self.base_salary = "-"
                #     self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/99: scrape = ScrapeJobsPage()
969/100: scrape.initialiseCrawler()
969/101:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        self.company_sector_BOTTOM = dict_job_details["industry"]
        self.job_function = dict_job_details["job_function"]

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = re.sub(pattern_to_replace, "", dict_salary_holder[salary_type])
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""

            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                # try:
                self.retrieveInformationRightSubWindow()
                # except Exception as error2:
                #     self.company_sector_BOTTOM = "-"
                #     self.job_function = "-"
                #     self.position_level_BOTTOM = error2
                #     self.company_size = "-"
                #     self.company_sector_TOP = "-"
                #     self.position_level_TOP = "-"
                #     self.applicant_count = "-"
                #     self.base_salary = "-"
                #     self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/102: scrape = ScrapeJobsPage()
969/103: scrape.initialiseCrawler()
969/104:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = (self.today - self.job_post_date).days


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = re.sub(pattern_to_replace, "", dict_salary_holder[salary_type])
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
    

                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/105: scrape.df
969/106: scrape.df.to_csv("jobs_scraped.csv")
969/107: scrape.df["total_compensation"].sort_values
969/108: scrape.df["total_compensation"].sort_values()
969/109: scrape.df["total_compensation"].sort_values(ascending=False)
969/110: scrape.df.iloc[41, :]
969/111: scrape.df
969/112: scrape.df
969/113:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/114: scrape = ScrapeJobsPage()
969/115: scrape.retrieveSalary()
969/116: soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
969/117: scrape.soup = BeautifulSoup(scrape.driver.page_source, "html.parser")
969/118: scrape.retrieveSalary()
969/119: scrape.base_salary
969/120: type(scrape.base_salary)
969/121: scrape.df["company_sector_TOP"]
969/122: scrape.df["total_compensation"].sort_values(ascending=False)
969/123: scrape.df["company_sector_TOP"]
969/124: df = pd.DataFrame("jobs_scraped.csv")
969/125: df = pd.DataFrame(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\jobs_scraped.csv")
969/126: df = pd.DataFrame(eval("jobs_scraped.csv"))
969/127: df = pd.DataFrame("jobs_scraped.csv")
969/128:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except AttributeError:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/129:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
969/130: scrape = ScrapeJobsPage()
969/131: login.SignIn()
969/132: navigate.clickJobs()
969/133: navigate.clickUKJuniorDataScientist()
969/134: navigate.clickUKJuniorDataScientist()
969/135: scrape.initialiseCrawler()
969/136: scrape.df
969/137:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/138: scrape.initialiseCrawler()
969/139:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                # try:
                self.retrieveInformationRightSubWindow()
                # except Exception as error2:
                #     self.company_sector_BOTTOM = "-"
                #     self.job_function = "-"
                #     self.position_level_BOTTOM = error2
                #     self.company_size = "-"
                #     self.company_sector_TOP = "-"
                #     self.position_level_TOP = "-"
                #     self.applicant_count = "-"
                #     self.base_salary = "-"
                #     self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/140: scrape = ScrapeJobsPage()
969/141: scrape.initialiseCrawler()
969/142:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/143: scrape = ScrapeJobsPage()
969/144: scrape.initialiseCrawler()
969/145: scrape.df
969/146: scrape.df.to_csv("jobs_scraped.csv")
969/147:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
969/148: scrape = ScrapeJobsPage()
969/149: scrape.initialiseCrawler()
970/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
970/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
970/3: scrape = ScrapeJobsPage()
970/4: login.SignIn()
970/5: navigate.clickJobs()
970/6: navigate.clickUKJuniorDataScientist()
970/7: scrape.initialiseCrawler()
970/8: scrape.df.to_csv("jobs_scraped.csv")
970/9: scrape.df.to_csv("jobs_scraped.csv")
971/1:
# from job_application_filter import *
# from bs4 import BeautifulSoup
971/2:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
971/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
971/4: scrape.initialiseCrawler()
971/5: scrape = ScrapeJobsPage()
971/6: scrape.initialiseCrawler()
971/7:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
971/8: scrape = ScrapeJobsPage()
971/9: scrape.initialiseCrawler()
971/10:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
971/11: scrape = ScrapeJobsPage()
971/12: scrape.initialiseCrawler()
972/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
972/2: scrape = ScrapeJobsPage()
972/3:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
972/4:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
972/5: scrape = ScrapeJobsPage()
972/6: scrape.initialiseCrawler()
972/7: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li", class_ = "result-card job-result-card result-card--with-hover-state")
972/8: scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").find_all("li", class_ = "result-card job-result-card result-card--with-hover-state")
972/9: scrape.lst_job_ads
972/10: len(scrape.lst_job_ads)
972/11: len(scrape.lst_job_ads)
972/12: scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").find_all("li", class_ = "result-card job-result-card")
972/13: len(scrape.lst_job_ads)
972/14: scrape = ScrapeJobsPage()
972/15: scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").find_all("li", class_ = "result-card job-result-card")
972/16: scrape.passHTMLContenttoBeautifulSoup()
972/17: scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").find_all("li", class_ = "result-card job-result-card")
972/18: len(scrape.lst_job_ads)
972/19:
scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").\
find_all("li", {"class":"result-card job-result-card"})
972/20: result-card job-result-card result-card--with-hover-state job-card__contents--active
972/21: len(scrape.lst_job_ads)
972/22:
scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").\
find_all("li", {"class":"result-card job-result-card result-card--with-hover-state job-card__contents--active"})
972/23: result-card job-result-card result-card--with-hover-state job-card__contents--active
972/24: len(scrape.lst_job_ads)
972/25:
scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").\
find_all("li", {"class":"result-card job-result-card"})
972/26: len(scrape.lst_job_ads)
972/27: scrape.passHTMLContenttoBeautifulSoup()
972/28:
scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").\
find_all("li", {"class":"result-card job-result-card"})
972/29: len(scrape.lst_job_ads)
972/30:
scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").\
find_all("li", {"class":"result-card job-result-card "})
972/31: len(scrape.lst_job_ads)
972/32:
scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").\
find_all("li", {"class":"result-card job-result-card result-card--with-hover-state"})
972/33: len(scrape.lst_job_ads)
972/34:
scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").\
find_all("li")
972/35: len(scrape.lst_job_ads)
972/36: scrape.lst_job_ads = scrape.soup.find("ul", "jobs-search__results-list").find_all("li")
972/37: len(scrape.lst_job_ads)
972/38: self.passHTMLContenttoBeautifulSoup()
972/39: self = ScrapeJobsPage()
972/40: #self.initialiseCrawler()
972/41: self.passHTMLContenttoBeautifulSoup()
972/42: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
972/43: len(scrape.lst_job_ads)
972/44: scrape.lst_job_ads[0]
972/45: scrape.lst_job_ads[0].find("h4")
972/46: scrape.lst_job_ads[0].find("h4").find("a")
972/47: scrape.lst_job_ads[0].find("h4").find("a").text
972/48:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip
        except AttributeError:
            self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
972/49: self = ScrapeJobsPage()
972/50: self.passHTMLContenttoBeautifulSoup()
972/51: self.retrieve
972/52:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
972/53: self.passHTMLContenttoBeautifulSoup()
972/54: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
972/55: self.lst_job_ads
972/56:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
972/57:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
972/58: self.passHTMLContenttoBeautifulSoup()
972/59: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
972/60:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
972/61:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
972/62: self = ScrapeJobsPage()
972/63: self.passHTMLContenttoBeautifulSoup()
972/64: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
972/65:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
972/66:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            self.company_name = job_ad.find("h4").text.strip()
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
972/67: self = ScrapeJobsPage()
972/68: self.passHTMLContenttoBeautifulSoup()
972/69: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
972/70:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
972/71:
try:
    1/0
except ZeroDivisionError:
    print("zde")
else:
    print("else")
972/72:
try:
    1/"0"
except ZeroDivisionError:
    print("zde")
else:
    print("else")
972/73:
try:
    1/1
except ZeroDivisionError:
    print("zde")
else:
    print("else")
972/74:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
972/75: self = ScrapeJobsPage()
972/76: self.passHTMLContenttoBeautifulSoup()
972/77: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
972/78:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
972/79:
for page in range(0, int(40)-1):
    print(page)
971/13: self.driver
972/80:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
972/81: self = ScrapeJobsPage()
972/82: self.passHTMLContenttoBeautifulSoup()
972/83: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
972/84:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
972/85: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
972/86: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
972/87: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
972/88: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
972/89: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
972/90: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
972/91: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
973/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            # self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
973/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
973/3: self = ScrapeJobsPage()
973/4: self.initialiseCrawler()
973/5: self.passHTMLContenttoBeautifulSoup()
973/6: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/7:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
973/8: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
973/9: scrape.lst_job_ads[0].find("h4").find("a").text
973/10: self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
973/11:
for page in range(40):
    self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
973/12:
for page in range(40):
    self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
    time.sleep(0.3)
973/13:
for page in range(40):
    self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
    time.sleep(1)
973/14:
for page in range(40):
    self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
    time.sleep(1)
973/15:
for page in range(40):
    self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]').click()
    time.sleep(1)
973/16: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/17:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
973/18: self.passHTMLContenttoBeautifulSoup()
973/19: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/20:
for job_ad in self.lst_job_ads:
    self.retrieveCompanyName(job_ad)
973/21:
for job_ad in self.lst_job_ads:
    self.retrieveJobTitle(job_ad)
973/22:
for job_ad in self.lst_job_ads:
    print(self.retrieveJobTitle(job_ad))
973/23: self.passHTMLContenttoBeautifulSoup()
973/24: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/25: len(scrape.lst_job_ads)
973/26: len(self.lst_job_ads)
973/27: self.lst_job_ads[0]
973/28: self.lst_job_ads[0].find("div", {"class":"result-card__contents job-result-card__contents"})
973/29: self.lst_job_ads[0].find("div", {"class":"result-card__contents job-result-card__contents"}).h3
973/30: self.lst_job_ads[0].find("div", {"class":"result-card__contents job-result-card__contents"}).h3.text
973/31:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("div", {"class":"result-card__contents job-result-card__contents"}).h3.text
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
973/32:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("div", {"class":"result-card__contents job-result-card__contents"}).h3.text
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
        for job_ad in self.lst_job_ads:

            try:
                self.retrieveInformationLeftSubWindow(job_ad)
            except Exception as error1:
                self.company_name = "-"
                self.job_title = "-"
                self.job_location = "-"
                self.job_post_date = "-"
                self.days_since_posted = "-"
                self.job_href = error1

            try:
                self.retrieveInformationRightSubWindow()
            except Exception as error2:
                self.company_sector_BOTTOM = "-"
                self.job_function = "-"
                self.position_level_BOTTOM = error2
                self.company_size = "-"
                self.company_sector_TOP = "-"
                self.position_level_TOP = "-"
                self.applicant_count = "-"
                self.base_salary = "-"
                self.total_compensation = "-"

            data_to_add = {'company_name': self.company_name,
                           'company_size': self.company_size,
                            'company_sector_TOP': self.company_sector_TOP,
                            'company_sector_BOTTOM': self.company_sector_BOTTOM,
                            'job_title': self.job_title,
                            'position_level_TOP': self.position_level_TOP,
                            'position_level_BOTTOM': self.position_level_BOTTOM,
                            'job_function': self.job_function,
                            'applicant_count' : self.applicant_count,
                            'job_location': self.job_location,
                            'job_post_date': self.job_post_date,
                            'days_since_posted': self.days_since_posted,
                            'base_salary': self.base_salary,
                            'total_compensation': self.total_compensation,
                            'job_href': self.job_href}

            self.df = self.df.append(data_to_add,
                                     ignore_index=True)


            self.displayInformation(data_to_add)

            time.sleep(0.5)
973/33: self = ScrapeJobsPage()
973/34: self.passHTMLContenttoBeautifulSoup()
973/35: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/36:
for job_ad in self.lst_job_ads:
    pself.retrieveJobTitle(job_ad)
973/37:
for job_ad in self.lst_job_ads:
    print(self.retrieveJobTitle(job_ad))
973/38:
def retrieveJobTitle(job_ad):
    job_title = job_ad.find("div", {"class":"result-card__contents job-result-card__contents"}).h3.text
    print(job_title)
973/39:
for job_ad in self.lst_job_ads:
    print(retrieveJobTitle(job_ad))
973/40:
def retrieveJobTitle(job_ad):
    job_title = job_ad.\
    find("div", {"class":"result-card__contents job-result-card__contents"}).\
    find("h3", {"class": "result-card__title job-result-card__title"}).text
    print(job_title)
973/41:
for job_ad in self.lst_job_ads:
    print(retrieveJobTitle(job_ad))
973/42:
def retrieveJobTitle(job_ad):
    job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
    print(job_title)
973/43:
for job_ad in self.lst_job_ads:
    print(retrieveJobTitle(job_ad))
973/44:
count = []

def retrieveJobTitle(job_ad):
    job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
    count.append(job_title)
973/45:
for job_ad in self.lst_job_ads:
    retrieveJobTitle(job_ad)
973/46: count
973/47: len(count)
973/48:
for job_ad in self.lst_job_ads:
    job_title = retrieveJobTitle(job_ad)
    print(job_title)
973/49:

def retrieveJobTitle(job_ad):
    job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
    return job_title
973/50:
for job_ad in self.lst_job_ads:
    job_title = retrieveJobTitle(job_ad)
    print(job_title)
973/51:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
        for job_ad in self.lst_job_ads:

            try:
                self.retrieveInformationLeftSubWindow(job_ad)
            except Exception as error1:
                self.company_name = "-"
                self.job_title = "-"
                self.job_location = "-"
                self.job_post_date = "-"
                self.days_since_posted = "-"
                self.job_href = error1

            try:
                self.retrieveInformationRightSubWindow()
            except Exception as error2:
                self.company_sector_BOTTOM = "-"
                self.job_function = "-"
                self.position_level_BOTTOM = error2
                self.company_size = "-"
                self.company_sector_TOP = "-"
                self.position_level_TOP = "-"
                self.applicant_count = "-"
                self.base_salary = "-"
                self.total_compensation = "-"

            data_to_add = {'company_name': self.company_name,
                           'company_size': self.company_size,
                            'company_sector_TOP': self.company_sector_TOP,
                            'company_sector_BOTTOM': self.company_sector_BOTTOM,
                            'job_title': self.job_title,
                            'position_level_TOP': self.position_level_TOP,
                            'position_level_BOTTOM': self.position_level_BOTTOM,
                            'job_function': self.job_function,
                            'applicant_count' : self.applicant_count,
                            'job_location': self.job_location,
                            'job_post_date': self.job_post_date,
                            'days_since_posted': self.days_since_posted,
                            'base_salary': self.base_salary,
                            'total_compensation': self.total_compensation,
                            'job_href': self.job_href}

            self.df = self.df.append(data_to_add,
                                     ignore_index=True)


            self.displayInformation(data_to_add)

            time.sleep(0.5)
973/52: self = ScrapeJobsPage()
973/53: self = ScrapeJobsPage()
973/54: self.passHTMLContenttoBeautifulSoup()
973/55: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/56:
for job_ad in self.lst_job_ads:
    self.retrieveJobTitle(job_ad)
973/57: self.retrieveJobTitle
973/58: self.job_title
973/59: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]')
973/60: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').click()
973/61: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location?
973/62: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location
973/63: self.passHTMLContenttoBeautifulSoup()
973/64: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location
973/65: self.passHTMLContenttoBeautifulSoup()
973/66: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location
973/67: self.driver.get_screenshot_as_png
973/68: self.driver.get_screenshot_as_png()
973/69: self.driver
973/70: url_to_launch = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=3&pageNum=0&currentJobId=1699410754"
973/71: self.driver.get(url_to_launch)
973/72:

self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location
973/73: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location
973/74: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').size
973/75: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location
973/76: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location
973/77: url_to_launch = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId=1532984689"
973/78: self.driver.get(url_to_launch)
973/79: self.driver.find_element_by_xpath('//h3[@class="result-card__title job-result-card__title"]').location
973/80: self.lst_job_ads[0
973/81: self.lst_job_ads[0]
973/82: self.lst_job_ads[0].id
973/83: self.lst_job_ads[0]
973/84: self.lst_job_ads[0]["data-id"]
973/85: url_to_launch = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId=1698684665"
973/86: self.driver.get(url_to_launch)
973/87: url_to_launch = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId=1699408761"
973/88: self.driver.get(url_to_launch)
973/89: self.lst_job_ads[0]["data-id"]
973/90:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        url_to_launch = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId={}"\
        .format(self.job_id)
        self.driver.get(url_to_launch)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad["data-id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
#         self.retrieveJobLocation()
#         self.retrieveJobHREF(job_ad)
#         self.retrieveJobPostDate(job_ad)
#         self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
        for job_ad in self.lst_job_ads:

            try:
                self.retrieveInformationLeftSubWindow(job_ad)
            except Exception as error1:
                self.company_name = "-"
                self.job_title = "-"
                self.job_location = "-"
                self.job_post_date = "-"
                self.days_since_posted = "-"
                self.job_href = error1

            try:
                self.retrieveInformationRightSubWindow()
            except Exception as error2:
                self.company_sector_BOTTOM = "-"
                self.job_function = "-"
                self.position_level_BOTTOM = error2
                self.company_size = "-"
                self.company_sector_TOP = "-"
                self.position_level_TOP = "-"
                self.applicant_count = "-"
                self.base_salary = "-"
                self.total_compensation = "-"

            data_to_add = {'company_name': self.company_name,
                           'company_size': self.company_size,
                            'company_sector_TOP': self.company_sector_TOP,
                            'company_sector_BOTTOM': self.company_sector_BOTTOM,
                            'job_title': self.job_title,
                            'position_level_TOP': self.position_level_TOP,
                            'position_level_BOTTOM': self.position_level_BOTTOM,
                            'job_function': self.job_function,
                            'applicant_count' : self.applicant_count,
                            'job_location': self.job_location,
                            'job_post_date': self.job_post_date,
                            'days_since_posted': self.days_since_posted,
                            'base_salary': self.base_salary,
                            'total_compensation': self.total_compensation,
                            'job_href': self.job_href}

            self.df = self.df.append(data_to_add,
                                     ignore_index=True)


            self.displayInformation(data_to_add)

            time.sleep(0.5)
973/91: self = ScrapeJobsPage()
973/92:
for job_ad in self.lst_job_ads:
    self.retrieveInformationLeftSubWindow()
973/93: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/94: self.passHTMLContenttoBeautifulSoup()
973/95: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/96:
for job_ad in self.lst_job_ads:
    self.retrieveInformationLeftSubWindow()
973/97:
for job_ad in self.lst_job_ads:
    self.retrieveInformationLeftSubWindow(job_ad)
973/98:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        url_to_launch = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId={}"\
        .format(self.job_ID)
        self.driver.get(url_to_launch)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad["data-id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
#         self.retrieveJobLocation()
#         self.retrieveJobHREF(job_ad)
#         self.retrieveJobPostDate(job_ad)
#         self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
        for job_ad in self.lst_job_ads:

            try:
                self.retrieveInformationLeftSubWindow(job_ad)
            except Exception as error1:
                self.company_name = "-"
                self.job_title = "-"
                self.job_location = "-"
                self.job_post_date = "-"
                self.days_since_posted = "-"
                self.job_href = error1

            try:
                self.retrieveInformationRightSubWindow()
            except Exception as error2:
                self.company_sector_BOTTOM = "-"
                self.job_function = "-"
                self.position_level_BOTTOM = error2
                self.company_size = "-"
                self.company_sector_TOP = "-"
                self.position_level_TOP = "-"
                self.applicant_count = "-"
                self.base_salary = "-"
                self.total_compensation = "-"

            data_to_add = {'company_name': self.company_name,
                           'company_size': self.company_size,
                            'company_sector_TOP': self.company_sector_TOP,
                            'company_sector_BOTTOM': self.company_sector_BOTTOM,
                            'job_title': self.job_title,
                            'position_level_TOP': self.position_level_TOP,
                            'position_level_BOTTOM': self.position_level_BOTTOM,
                            'job_function': self.job_function,
                            'applicant_count' : self.applicant_count,
                            'job_location': self.job_location,
                            'job_post_date': self.job_post_date,
                            'days_since_posted': self.days_since_posted,
                            'base_salary': self.base_salary,
                            'total_compensation': self.total_compensation,
                            'job_href': self.job_href}

            self.df = self.df.append(data_to_add,
                                     ignore_index=True)


            self.displayInformation(data_to_add)

            time.sleep(0.5)
973/99: self = ScrapeJobsPage()
973/100: self.passHTMLContenttoBeautifulSoup()
973/101: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/102:
for job_ad in self.lst_job_ads:
    self.retrieveInformationLeftSubWindow(job_ad)
973/103: self.passHTMLContenttoBeautifulSoup()
973/104: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/105: self.lst_job_ads[0]
973/106: self.lst_job_ads[0].find("span", {"class": "job-result-card__location"})
973/107: self.lst_job_ads[0].find("span", {"class": "job-result-card__location"}).text
973/108: self.lst_job_ads[0].find("time", {"class": "datetime"})
973/109: self.lst_job_ads[0].find("time", {"class": "job-result-card__listdate"})
973/110: self.lst_job_ads[0].find("time", {"class": "job-result-card__listdate"})["datetime"]
973/111:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        self.job_HREF = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId={}"\
        .format(self.job_ID)
        self.driver.get(self.job_HREF)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad["data-id"]


    def retrieveJobLocation(self):
        try:
            self.job_location = job_ad.find("span", {"class": "job-result-card__location"}).text.strip()
        except:
            self.job_location = ""


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
        for job_ad in self.lst_job_ads:

            try:
                self.retrieveInformationLeftSubWindow(job_ad)
            except Exception as error1:
                self.company_name = "-"
                self.job_title = "-"
                self.job_location = "-"
                self.job_post_date = "-"
                self.days_since_posted = "-"
                self.job_href = error1

            try:
                self.retrieveInformationRightSubWindow()
            except Exception as error2:
                self.company_sector_BOTTOM = "-"
                self.job_function = "-"
                self.position_level_BOTTOM = error2
                self.company_size = "-"
                self.company_sector_TOP = "-"
                self.position_level_TOP = "-"
                self.applicant_count = "-"
                self.base_salary = "-"
                self.total_compensation = "-"

            data_to_add = {'company_name': self.company_name,
                           'company_size': self.company_size,
                            'company_sector_TOP': self.company_sector_TOP,
                            'company_sector_BOTTOM': self.company_sector_BOTTOM,
                            'job_title': self.job_title,
                            'position_level_TOP': self.position_level_TOP,
                            'position_level_BOTTOM': self.position_level_BOTTOM,
                            'job_function': self.job_function,
                            'applicant_count' : self.applicant_count,
                            'job_location': self.job_location,
                            'job_post_date': self.job_post_date,
                            'days_since_posted': self.days_since_posted,
                            'base_salary': self.base_salary,
                            'total_compensation': self.total_compensation,
                            'job_href': self.job_href}

            self.df = self.df.append(data_to_add,
                                     ignore_index=True)


            self.displayInformation(data_to_add)

            time.sleep(0.5)
973/112: self = ScrapeJobsPage()
973/113: self.passHTMLContenttoBeautifulSoup()
973/114:
for job_ad in self.lst_job_ads:
    self.retrieveInformationLeftSubWindow(job_ad)
973/115: self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
973/116:
for job_ad in self.lst_job_ads:
    self.retrieveInformationLeftSubWindow(job_ad)
973/117:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        self.job_HREF = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId={}"\
        .format(self.job_ID)
        self.driver.get(self.job_HREF)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""
        
        print(self.company_name)


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad["data-id"]


    def retrieveJobLocation(self):
        try:
            self.job_location = job_ad.find("span", {"class": "job-result-card__location"}).text.strip()
        except:
            self.job_location = ""


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        # self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
        for job_ad in self.lst_job_ads:

            try:
                self.retrieveInformationLeftSubWindow(job_ad)
            except Exception as error1:
                self.company_name = "-"
                self.job_title = "-"
                self.job_location = "-"
                self.job_post_date = "-"
                self.days_since_posted = "-"
                self.job_href = error1

#             try:
#                 self.retrieveInformationRightSubWindow()
#             except Exception as error2:
            self.company_sector_BOTTOM = "-"
            self.job_function = "-"
            self.position_level_BOTTOM = error2
            self.company_size = "-"
            self.company_sector_TOP = "-"
            self.position_level_TOP = "-"
            self.applicant_count = "-"
            self.base_salary = "-"
            self.total_compensation = "-"

            data_to_add = {'company_name': self.company_name,
                           'company_size': self.company_size,
                            'company_sector_TOP': self.company_sector_TOP,
                            'company_sector_BOTTOM': self.company_sector_BOTTOM,
                            'job_title': self.job_title,
                            'position_level_TOP': self.position_level_TOP,
                            'position_level_BOTTOM': self.position_level_BOTTOM,
                            'job_function': self.job_function,
                            'applicant_count' : self.applicant_count,
                            'job_location': self.job_location,
                            'job_post_date': self.job_post_date,
                            'days_since_posted': self.days_since_posted,
                            'base_salary': self.base_salary,
                            'total_compensation': self.total_compensation,
                            'job_href': self.job_href}

#             self.df = self.df.append(data_to_add,
#                                      ignore_index=True)


            self.displayInformation(data_to_add)

            # time.sleep(0.5)
973/118: self = ScrapeJobsPage()
973/119: self.initialiseCrawler()
973/120:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        self.job_HREF = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId={}"\
        .format(self.job_ID)
        self.driver.get(self.job_HREF)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad["data-id"]


    def retrieveJobLocation(self):
        try:
            self.job_location = job_ad.find("span", {"class": "job-result-card__location"}).text.strip()
        except:
            self.job_location = ""


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        # self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
        for job_ad in self.lst_job_ads:

            try:
                self.retrieveInformationLeftSubWindow(job_ad)
            except Exception as error1:
                self.company_name = "-"
                self.job_title = "-"
                self.job_location = "-"
                self.job_post_date = "-"
                self.days_since_posted = "-"
                self.job_href = error1

#             try:
#                 self.retrieveInformationRightSubWindow()
#             except Exception as error2:
            self.company_sector_BOTTOM = "-"
            self.job_function = "-"
            self.position_level_BOTTOM = "-"
            self.company_size = "-"
            self.company_sector_TOP = "-"
            self.position_level_TOP = "-"
            self.applicant_count = "-"
            self.base_salary = "-"
            self.total_compensation = "-"

            data_to_add = {'company_name': self.company_name,
                           'company_size': self.company_size,
                            'company_sector_TOP': self.company_sector_TOP,
                            'company_sector_BOTTOM': self.company_sector_BOTTOM,
                            'job_title': self.job_title,
                            'position_level_TOP': self.position_level_TOP,
                            'position_level_BOTTOM': self.position_level_BOTTOM,
                            'job_function': self.job_function,
                            'applicant_count' : self.applicant_count,
                            'job_location': self.job_location,
                            'job_post_date': self.job_post_date,
                            'days_since_posted': self.days_since_posted,
                            'base_salary': self.base_salary,
                            'total_compensation': self.total_compensation,
                            'job_href': self.job_href}

#             self.df = self.df.append(data_to_add,
#                                      ignore_index=True)


            self.displayInformation(data_to_add)

            # time.sleep(0.5)
973/121: self = ScrapeJobsPage()
973/122: self.initialiseCrawler()
973/123:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        self.job_href = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=4&pageNum=0&currentJobId={}"\
        .format(self.job_ID)
        self.driver.get(self.job_href)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = job_ad.find("h3", {"class":"result-card__title job-result-card__title"}).text
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("h4").find("a").text.strip()
        except AttributeError:
            try:
                self.company_name = job_ad.find("h4").text.strip()
            except:
                self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad["data-id"]


    def retrieveJobLocation(self):
        try:
            self.job_location = job_ad.find("span", {"class": "job-result-card__location"}).text.strip()
        except:
            self.job_location = ""


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()

        
    def get_all_jobs(self):
        for page in range(40):
            see_more_jobs_button = self.driver.find_element_by_xpath('//button[@data-tracking-control-name="guest_job_search_see-more-jobs"]')
            see_more_jobs_button.click()
            time.sleep(1)


    def initialiseCrawler(self):
        # last_page = self.retrieveFinalPageNumber()
        url = "https://uk.linkedin.com/jobs/junior-data-scientist-jobs?position=1&pageNum=0"
        self.driver.get(url)
        
        # self.get_all_jobs()
        self.passHTMLContenttoBeautifulSoup()

        self.lst_job_ads = self.soup.find("ul", "jobs-search__results-list").find_all("li")
        for job_ad in self.lst_job_ads:

            try:
                self.retrieveInformationLeftSubWindow(job_ad)
            except Exception as error1:
                self.company_name = "-"
                self.job_title = "-"
                self.job_location = "-"
                self.job_post_date = "-"
                self.days_since_posted = "-"
                self.job_href = error1

#             try:
#                 self.retrieveInformationRightSubWindow()
#             except Exception as error2:
            self.company_sector_BOTTOM = "-"
            self.job_function = "-"
            self.position_level_BOTTOM = "-"
            self.company_size = "-"
            self.company_sector_TOP = "-"
            self.position_level_TOP = "-"
            self.applicant_count = "-"
            self.base_salary = "-"
            self.total_compensation = "-"

            data_to_add = {'company_name': self.company_name,
                           'company_size': self.company_size,
                            'company_sector_TOP': self.company_sector_TOP,
                            'company_sector_BOTTOM': self.company_sector_BOTTOM,
                            'job_title': self.job_title,
                            'position_level_TOP': self.position_level_TOP,
                            'position_level_BOTTOM': self.position_level_BOTTOM,
                            'job_function': self.job_function,
                            'applicant_count' : self.applicant_count,
                            'job_location': self.job_location,
                            'job_post_date': self.job_post_date,
                            'days_since_posted': self.days_since_posted,
                            'base_salary': self.base_salary,
                            'total_compensation': self.total_compensation,
                            'job_href': self.job_href}

#             self.df = self.df.append(data_to_add,
#                                      ignore_index=True)


            self.displayInformation(data_to_add)

            # time.sleep(0.5)
973/124: self = ScrapeJobsPage()
973/125: self.initialiseCrawler()
974/1: import ai_version_3
974/2: from ai_version_3 import neural_network
975/1: from ai_version_3 import neural_network
975/2:
from scipy.io import loadmat
data = loadmat('../ex3/data/ex3data1.mat')
data.keys()
975/3:
from scipy.io import loadmat
data = loadmat("C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
975/4:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
975/5:
x = data["X"]
y = data["y"]
y[y==10] = 0
975/6:
from ai_version_3 import neural_network

from utility_functions import (calculate_model_performance,
                               plot_ROC,
                               one_hot_encode,
                               split_data_as,
                               grid_search,
                               shuffled,
                               timeit)
975/7:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
975/8:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
975/9:
x = data["X"]
y = data["y"]
y[y==10] = 0
975/10:
dataset_test, dataset_train = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = one_hot_encode(dataset_train[:, -1]).T

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
975/11: X_train
975/12: X_train.shape
975/13:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = one_hot_encode(dataset_train[:, -1]).T

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
975/14: X_train.shape
975/15:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1]
Y_train = one_hot_encode(dataset_train[:, -1])

X_test = dataset_test[:, :-1]
Y_test = one_hot_encode(dataset_test[:, -1])
975/16: X_train
975/17: X_train.shape
975/18: X_train
975/19: list(X_train)
975/20: neural_network(X_train, Y_train)
975/21: np.ones((4, 1), dtype=float)
975/22: import numpy as np
975/23: np.ones((4, 1), dtype=float)
975/24: np.ones((10, 3), dtype=float)
975/25:
def neural_network(x, y):
    fw["a0"] = x
    """ a0 vektörünün tipi diğerlerine uymadı. Ben de tip uyusumu icin
    her elemanı 1 olam bir vektörle çarptım. """
    fw['a0']=np.multiply(fw['a0'],np.ones((10, 3), dtype=float))

    """ w ve b için random sayılar atadım """

    fw['w1']=np.random.randn(3,4) * 0.1
    fw['b1']=np.random.randn(3,1) * 0.1
    fw['w2']=np.random.randn(5,3) * 0.1
    fw['b2']=np.random.randn(5,1) * 0.1
    fw['w3']=np.random.randn(2,5) * 0.1
    fw['b3']=np.random.randn(2,1) * 0.1

    """ Cost'un w ve b ye göre türevi için döngüye girmeden önce
    elemanları sıfır olan matrisler atadım. """ 

    backw['dw1']=np.zeros([3, 4], dtype = float)
    backw['db1']=np.zeros([3, 1], dtype = float)
    backw['dw2']=np.zeros([5, 3], dtype = float)
    backw['db2']=np.zeros([5, 1], dtype = float)
    backw['dw3']=np.zeros([2, 5], dtype = float)
    backw['db3']=np.zeros([2, 1], dtype = float)


    for x in range(100):

     """ w ve b güncellemesini döngünün başına koydum. Türevlerin değerleri başlangıçda
     sıfır olduğundan ilk düzeltmeikinci tekrarda olacak """
        
     fw['w1']=fw['w1']-alfa*backw['dw1']
     fw['b1']=fw['b1']-alfa*backw['db1']
     fw['w2']=fw['w2']-alfa*backw['dw2']
     fw['b2']=fw['b2']-alfa*backw['db2']
     fw['w3']=fw['w3']-alfa*backw['dw3']
     fw['b3']=fw['b3']-alfa*backw['db3']

     """ forward propagation
     sadece a ları değil, daha sonra gerekeceğinden z nin a ya göre 
     türevini de (dg1,dg2,dg3)hesaplattırıyorum """

     z1=np.add(np.dot(fw['w1'],fw['a0']),fw['b1'])
     fw['a1'] = 1/(1 + np.exp(-z1))
     fw['dg1']=fw['a1']*(1-fw['a1'])
     
     z2=np.add(np.dot(fw['w2'],fw['a1']),fw['b2'])
     fw['a2'] = 1/(1 + np.exp(-z2))
     fw['dg2']=fw['a2']*(1-fw['a2'])

     z3=np.add(np.dot(fw['w3'],fw['a2']),fw['b3'])
     fw['a3'] = 1/(1 + np.exp(-z3))
     fw['dg3']=fw['a3']*(1-fw['a3'])

     """ Cost function hesaplama """

     c=(1/2)*np.multiply((fw['a3']-y),(fw['a3']-y))

     """ backward propagation. (dw ve db değerlerinin hesaplatılması)"""

     backw={}
     backw['da3']=fw['a3']-y

     backw['dz3']=np.multiply(backw['da3'],fw['dg3'])
     backw['dz2']=np.multiply(np.dot(np.transpose(fw['w3']),backw['dz3']),fw['dg2'])
     backw['dz1']=np.multiply(np.dot(np.transpose(fw['w2']),backw['dz2']),fw['dg1'])


     backw['dw3']=np.dot(backw['dz3'],fw['a2'].T)
     backw['dw2']=np.dot(backw['dz2'],fw['a1'].T)
     backw['dw1']=np.dot(backw['dz1'],fw['a0'].T)

     backw['db3']=backw['dz3']
     backw['db2']=backw['dz2']
     backw['db1']=backw['dz1']
     
     """ görmek için Cost vektörünü bastırıyorum """
     print(c)
     
     """ for döngüsünün başına """
     
     """ Kod bu kadar. kodda sadece backpropagation var. Ayrıca bir eksik var:
         Cost değerinin 1/m ile çarpılması gerekiyor. benim kodumda yok. Birşeyleri
         tam anlayamadığım için onu henüz koymadım. Ayrıca Cost function logaritmik
         olan değil. kareli olan. Bir üçüncü tüm aktivasyonlar sigmoid. logaritmik 
         ve sigmoid konusun sonraya bırakabiliriz. zaten basit. """
975/26:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
975/27:
def neural_network(x, y):
    fw["a0"] = x
    """ a0 vektörünün tipi diğerlerine uymadı. Ben de tip uyusumu icin
    her elemanı 1 olam bir vektörle çarptım. """
    fw['a0']=np.multiply(fw['a0'],np.ones((10, 3), dtype=float))

    """ w ve b için random sayılar atadım """

    fw['w1']=np.random.randn(3,4) * 0.1
    fw['b1']=np.random.randn(3,1) * 0.1
    fw['w2']=np.random.randn(5,3) * 0.1
    fw['b2']=np.random.randn(5,1) * 0.1
    fw['w3']=np.random.randn(2,5) * 0.1
    fw['b3']=np.random.randn(2,1) * 0.1

    """ Cost'un w ve b ye göre türevi için döngüye girmeden önce
    elemanları sıfır olan matrisler atadım. """ 

    backw['dw1']=np.zeros([3, 4], dtype = float)
    backw['db1']=np.zeros([3, 1], dtype = float)
    backw['dw2']=np.zeros([5, 3], dtype = float)
    backw['db2']=np.zeros([5, 1], dtype = float)
    backw['dw3']=np.zeros([2, 5], dtype = float)
    backw['db3']=np.zeros([2, 1], dtype = float)


    for x in range(100):

     """ w ve b güncellemesini döngünün başına koydum. Türevlerin değerleri başlangıçda
     sıfır olduğundan ilk düzeltmeikinci tekrarda olacak """
        
     fw['w1']=fw['w1']-alfa*backw['dw1']
     fw['b1']=fw['b1']-alfa*backw['db1']
     fw['w2']=fw['w2']-alfa*backw['dw2']
     fw['b2']=fw['b2']-alfa*backw['db2']
     fw['w3']=fw['w3']-alfa*backw['dw3']
     fw['b3']=fw['b3']-alfa*backw['db3']

     """ forward propagation
     sadece a ları değil, daha sonra gerekeceğinden z nin a ya göre 
     türevini de (dg1,dg2,dg3)hesaplattırıyorum """

     z1=np.add(np.dot(fw['w1'],fw['a0']),fw['b1'])
     fw['a1'] = 1/(1 + np.exp(-z1))
     fw['dg1']=fw['a1']*(1-fw['a1'])
     
     z2=np.add(np.dot(fw['w2'],fw['a1']),fw['b2'])
     fw['a2'] = 1/(1 + np.exp(-z2))
     fw['dg2']=fw['a2']*(1-fw['a2'])

     z3=np.add(np.dot(fw['w3'],fw['a2']),fw['b3'])
     fw['a3'] = 1/(1 + np.exp(-z3))
     fw['dg3']=fw['a3']*(1-fw['a3'])

     """ Cost function hesaplama """

     c=(1/2)*np.multiply((fw['a3']-y),(fw['a3']-y))

     """ backward propagation. (dw ve db değerlerinin hesaplatılması)"""

     backw={}
     backw['da3']=fw['a3']-y

     backw['dz3']=np.multiply(backw['da3'],fw['dg3'])
     backw['dz2']=np.multiply(np.dot(np.transpose(fw['w3']),backw['dz3']),fw['dg2'])
     backw['dz1']=np.multiply(np.dot(np.transpose(fw['w2']),backw['dz2']),fw['dg1'])


     backw['dw3']=np.dot(backw['dz3'],fw['a2'].T)
     backw['dw2']=np.dot(backw['dz2'],fw['a1'].T)
     backw['dw1']=np.dot(backw['dz1'],fw['a0'].T)

     backw['db3']=backw['dz3']
     backw['db2']=backw['dz2']
     backw['db1']=backw['dz1']
     
     """ görmek için Cost vektörünü bastırıyorum """
     print(c)
     
     """ for döngüsünün başına """
     
     """ Kod bu kadar. kodda sadece backpropagation var. Ayrıca bir eksik var:
         Cost değerinin 1/m ile çarpılması gerekiyor. benim kodumda yok. Birşeyleri
         tam anlayamadığım için onu henüz koymadım. Ayrıca Cost function logaritmik
         olan değil. kareli olan. Bir üçüncü tüm aktivasyonlar sigmoid. logaritmik 
         ve sigmoid konusun sonraya bırakabiliriz. zaten basit. """
975/28:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
975/29:
x = data["X"]
y = data["y"]
y[y==10] = 0
975/30:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1]
Y_train = one_hot_encode(dataset_train[:, -1])

X_test = dataset_test[:, :-1]
Y_test = one_hot_encode(dataset_test[:, -1])
975/31: X_train.shape
975/32: neural_network(X_train, Y_train)
975/33:
def neural_network(x, y):
    fw = {}; fw["a0"] = x
    """ a0 vektörünün tipi diğerlerine uymadı. Ben de tip uyusumu icin
    her elemanı 1 olam bir vektörle çarptım. """
    fw['a0']=np.multiply(fw['a0'],np.ones((10, 3), dtype=float))

    """ w ve b için random sayılar atadım """

    fw['w1']=np.random.randn(3,4) * 0.1
    fw['b1']=np.random.randn(3,1) * 0.1
    fw['w2']=np.random.randn(5,3) * 0.1
    fw['b2']=np.random.randn(5,1) * 0.1
    fw['w3']=np.random.randn(2,5) * 0.1
    fw['b3']=np.random.randn(2,1) * 0.1

    """ Cost'un w ve b ye göre türevi için döngüye girmeden önce
    elemanları sıfır olan matrisler atadım. """ 

    backw['dw1']=np.zeros([3, 4], dtype = float)
    backw['db1']=np.zeros([3, 1], dtype = float)
    backw['dw2']=np.zeros([5, 3], dtype = float)
    backw['db2']=np.zeros([5, 1], dtype = float)
    backw['dw3']=np.zeros([2, 5], dtype = float)
    backw['db3']=np.zeros([2, 1], dtype = float)


    for x in range(100):

     """ w ve b güncellemesini döngünün başına koydum. Türevlerin değerleri başlangıçda
     sıfır olduğundan ilk düzeltmeikinci tekrarda olacak """
        
     fw['w1']=fw['w1']-alfa*backw['dw1']
     fw['b1']=fw['b1']-alfa*backw['db1']
     fw['w2']=fw['w2']-alfa*backw['dw2']
     fw['b2']=fw['b2']-alfa*backw['db2']
     fw['w3']=fw['w3']-alfa*backw['dw3']
     fw['b3']=fw['b3']-alfa*backw['db3']

     """ forward propagation
     sadece a ları değil, daha sonra gerekeceğinden z nin a ya göre 
     türevini de (dg1,dg2,dg3)hesaplattırıyorum """

     z1=np.add(np.dot(fw['w1'],fw['a0']),fw['b1'])
     fw['a1'] = 1/(1 + np.exp(-z1))
     fw['dg1']=fw['a1']*(1-fw['a1'])
     
     z2=np.add(np.dot(fw['w2'],fw['a1']),fw['b2'])
     fw['a2'] = 1/(1 + np.exp(-z2))
     fw['dg2']=fw['a2']*(1-fw['a2'])

     z3=np.add(np.dot(fw['w3'],fw['a2']),fw['b3'])
     fw['a3'] = 1/(1 + np.exp(-z3))
     fw['dg3']=fw['a3']*(1-fw['a3'])

     """ Cost function hesaplama """

     c=(1/2)*np.multiply((fw['a3']-y),(fw['a3']-y))

     """ backward propagation. (dw ve db değerlerinin hesaplatılması)"""

     backw={}
     backw['da3']=fw['a3']-y

     backw['dz3']=np.multiply(backw['da3'],fw['dg3'])
     backw['dz2']=np.multiply(np.dot(np.transpose(fw['w3']),backw['dz3']),fw['dg2'])
     backw['dz1']=np.multiply(np.dot(np.transpose(fw['w2']),backw['dz2']),fw['dg1'])


     backw['dw3']=np.dot(backw['dz3'],fw['a2'].T)
     backw['dw2']=np.dot(backw['dz2'],fw['a1'].T)
     backw['dw1']=np.dot(backw['dz1'],fw['a0'].T)

     backw['db3']=backw['dz3']
     backw['db2']=backw['dz2']
     backw['db1']=backw['dz1']
     
     """ görmek için Cost vektörünü bastırıyorum """
     print(c)
     
     """ for döngüsünün başına """
     
     """ Kod bu kadar. kodda sadece backpropagation var. Ayrıca bir eksik var:
         Cost değerinin 1/m ile çarpılması gerekiyor. benim kodumda yok. Birşeyleri
         tam anlayamadığım için onu henüz koymadım. Ayrıca Cost function logaritmik
         olan değil. kareli olan. Bir üçüncü tüm aktivasyonlar sigmoid. logaritmik 
         ve sigmoid konusun sonraya bırakabiliriz. zaten basit. """
975/34:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
975/35:
x = data["X"]
y = data["y"]
y[y==10] = 0
975/36:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1]
Y_train = one_hot_encode(dataset_train[:, -1])

X_test = dataset_test[:, :-1]
Y_test = one_hot_encode(dataset_test[:, -1])
975/37: X_train.shape
975/38: neural_network(X_train, Y_train)
977/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
977/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
977/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
977/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1]
Y_train = one_hot_encode(dataset_train[:, -1])

X_test = dataset_test[:, :-1]
Y_test = one_hot_encode(dataset_test[:, -1])
977/5: X_train.shape
977/6: neural_network(X_train, Y_train)
978/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
978/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
978/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
978/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1]
Y_train = one_hot_encode(dataset_train[:, -1])

X_test = dataset_test[:, :-1]
Y_test = one_hot_encode(dataset_test[:, -1])
978/5: X_train.shape
978/6: neural_network(X_train, Y_train)
979/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
979/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
979/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
979/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1]
Y_train = one_hot_encode(dataset_train[:, -1])

X_test = dataset_test[:, :-1]
Y_test = one_hot_encode(dataset_test[:, -1])
979/5: X_train.shape
979/6: neural_network(X_train, Y_train)
979/7: neural_network(X_train, Y_train, 0.1)
980/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
980/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
980/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
980/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1]
Y_train = one_hot_encode(dataset_train[:, -1])

X_test = dataset_test[:, :-1]
Y_test = one_hot_encode(dataset_test[:, -1])
980/5: X_train.shape
980/6: neural_network(X_train, Y_train, 0.1)
980/7:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
980/8:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
980/9:
x = data["X"]
y = data["y"]
y[y==10] = 0
980/10:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = one_hot_encode(dataset_train[:, -1]).T

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
980/11: X_train.shape
980/12: neural_network(X_train, Y_train, 0.1)
981/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
981/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
981/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
981/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = one_hot_encode(dataset_train[:, -1]).T

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
981/5: X_train.shape
981/6: neural_network(X_train, Y_train, 0.1)
982/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
982/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
982/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
982/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = one_hot_encode(dataset_train[:, -1]).T

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
982/5: X_train.shape
982/6: neural_network(X_train, Y_train, 0.1)
983/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
983/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
983/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
983/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = one_hot_encode(dataset_train[:, -1]).T

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
983/5: X_train.shape
983/6: neural_network(X_train, Y_train, 0.1)
984/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
984/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
984/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
984/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = one_hot_encode(dataset_train[:, -1]).T

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
984/5: X_train.shape
984/6: neural_network(X_train, Y_train, 0.1)
984/7: neural_network(X_train, Y_train, 1)
985/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
985/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
985/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
985/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = dataset_train[:, -1]

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
985/5: X_train.shape
985/6: neural_network(X_train, Y_train, 1)
985/7: Y_train
985/8: Y_train.shape
985/9:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = dataset_train[:, -1].reshape(-1, 1)

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
985/10: Y_train.shape
985/11: Y_train
985/12: Y_train
985/13: X_train.shape
985/14: neural_network(X_train, Y_train, 1)
985/15:
from sklearn.datasets import load_iris
data = load_iris()

x = data.data[:,[0,2]]
y = data.target

X = x.T
Y = one_hot_encode(y).T
985/16:
from sklearn.datasets import load_iris
data = load_iris()

x = data.data[:,[0,2]]
y = data.target

X = x.T
Y = one_hot_encode(y).T
985/17: X
985/18: X.shape
985/19: Y.shape
985/20:
from sklearn.datasets import load_iris
data = load_iris()

x = data.data[:,[0,2]]
y = data.target

X = x.T
Y = y.T
985/21: X.shape
985/22: Y.shape
986/1:
from ai_version_3 import neural_network

from utility_functions import (one_hot_encode,
                               split_data_as)
import numpy as np
986/2:
from scipy.io import loadmat
data = loadmat(r"C:\Users\Cagri\Google Drive\Python_Projects\Andrew-NG-Coursera\ex3\data\ex3data1.mat")
data.keys()
986/3:
x = data["X"]
y = data["y"]
y[y==10] = 0
986/4:
dataset_train, dataset_test = split_data_as(x, y, train=0.9, test=0.1)
X_train = dataset_train[:, :-1].T
Y_train = dataset_train[:, -1].reshape(-1, 1)

X_test = dataset_test[:, :-1].T
Y_test = one_hot_encode(dataset_test[:, -1]).T
986/5: Y_train
986/6: X_train.shape
986/7:
from sklearn.datasets import load_iris
data = load_iris()

x = data.data[:,[0,2]]
y = data.target

X = x.T
Y = y.T
986/8: X.shape
986/9: Y.shape
986/10: neural_network(X, Y, 1)
986/11:
from sklearn.datasets import load_iris
data = load_iris()

x = data.data[:,[0,2]]
y = data.target

X = x.T
Y = (y.T).reshape(-1, 1)
986/12: X.shape
986/13: Y.shape
986/14: neural_network(X, Y, 1)
986/15:
from sklearn.datasets import load_iris
data = load_iris()

x = data.data[:,[0,2]]
y = data.target

X = x.T
Y = (y.T)
986/16: X.shape
986/17: Y.shape
986/18: neural_network(X, Y, 1)
986/19: X
986/20: Y
987/1: import pandas as pd
987/2:
path = r"D:\Downloads__\tbliste.xls"

df = pd.DataFrame(path)
987/3:
path = r"D:\Downloads__\tbliste.xls"

df = pd.read_csv(path)
987/4:
path = r"D:\Downloads__\tbliste.xls"

df = pd.read_excel(path)
987/5: df
987/6: df.columns
987/7: df["'ISIN Kodu\nISIN Code'"]
987/8: df['ISIN Kodu\nISIN Code']
987/9: df['ISIN Kodu\nISIN Code'][-50:]
987/10: df['ISIN Kodu\nISIN Code'][-50:-15]
987/11: df['ISIN Kodu\nISIN Code'][-150:-15]
987/12:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np
987/13: url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
987/14: ISIN = "TRFFNBK22025"
987/15: url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
987/16: url
987/17: url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
987/18:
page  = requests.get(url).text
soup_expatistan = BeautifulSoup(page)
987/19:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np
import requests
987/20:
page  = requests.get(url).text
soup_expatistan = BeautifulSoup(page)
987/21: soup_expatistan
987/22: soup_expatistan.find("div", {"class": "paging"})
987/23: soup_expatistan.find("div", {"class": "paging"}).findall("a")
987/24: soup_expatistan.find("div", {"class": "paging"}).findAll("a")
987/25:
def get_last_page(url):
    pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
    return pages[-1].text
987/26: get_last_page(url)
987/27:
def launch_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return  page
987/28: last_page = get_last_page(ISIN)
987/29: last_page
987/30: launch_last_page(last_page, ISIN)
987/31: last_page_html = launch_last_page(last_page, ISIN)
987/32: last_page_html.find("div", {"class": "w-container middle-container"})
987/33: last_page_html
987/34: type(last_page_html)
987/35:
def launch_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/36: last_page = get_last_page(ISIN)
987/37: last_page_html = launch_last_page(last_page, ISIN)
987/38: last_page_html.find("div", {"class": "w-container middle-container"})
987/39: last_page_html.find("div", {"class": "w-container middle-container"})[-1]
987/40: last_page_html.find("div", {"class": "w-container middle-container"})
987/41: last_page_html.find("div", {"class": "w-container middle-container"}).find_all("div")
987/42: last_page_html.find("div", {"class": "w-container middle-container"})
987/43: list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
987/44: list_of_items.findAll("div", {"class":"searchResult disclosure"})
987/45: len(list_of_items.findAll("div", {"class":"searchResult disclosure"}))
987/46: list_of_items.findAll("div", {"class":"searchResult disclosure"})
987/47: list_of_items.findAll("div", {"class":"searchResult disclosure"})[0]
987/48: list_of_items.findAll("div", {"class":"searchResult disclosure"})[0].a
987/49: list_of_items.findAll("div", {"class":"searchResult disclosure"})[0].a.text
987/50: list_of_items.findAll("div", {"class":"searchResult disclosure"})[0].a.text.strip()
987/51:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
    return pages[-1].text
987/52:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/53: last_page = get_last_page(ISIN)
987/54: last_page_html = get_content_last_page(last_page, ISIN)
987/55: list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
987/56: list_of_items.findAll("div", {"class":"searchResult disclosure"})
987/57: list_of_items.findAll("div", {"class":"searchResult disclosure"})[0].a.href
987/58: list_of_items.findAll("div", {"class":"searchResult disclosure"})
987/59: list_of_items.findAll("div", {"class":"searchResult disclosure"})[0].a.href
987/60: list_of_items.findAll("div", {"class":"searchResult disclosure"})[0].a
987/61: list_of_items.findAll("div", {"class":"searchResult disclosure"})[0].a["href"]
987/62:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    for item in items:
        if pay in item.a.text.strip().lower():
            term_sheet =  item.a["href"]
    return term_sheet
987/63: get_full_terms(last_page_html)
987/64:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet =  item.a["href"]
    return term_sheet
987/65: get_full_terms(last_page_html)
987/66:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr/" + item.a["href"]
        else:
            term_sheet_url = "N/A"
    return term_sheet_url
987/67: get_full_terms(last_page_html)
987/68: term_sheet_url = get_full_terms(last_page_html)
987/69:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/70: get_content_term_sheet_url("term_sheet_url")
987/71:
term_sheet_url = get_full_terms(last_page_html)
term_sheet_url
987/72:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"]
        else:
            term_sheet_url = "N/A"
    return term_sheet_url
987/73:
term_sheet_url = get_full_terms(last_page_html)
term_sheet_url
987/74:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
        else:
            term_sheet_url = "N/A"
    return term_sheet_url
987/75:
term_sheet_url = get_full_terms(last_page_html)
term_sheet_url
987/76:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/77: get_content_term_sheet_url("term_sheet_url")
987/78: term_sheet_content = get_content_term_sheet_url("term_sheet_url")
987/79: pd.read_html(term_sheet_content)
987/80: pd.read_html(term_sheet_url)
987/81: len(pd.read_html(term_sheet_url))
987/82: pd.read_html(term_sheet_url)
987/83: df1, df2, df3, df4 = pd.read_html(term_sheet_url)
987/84: df1
987/85: df2
987/86: df3
987/87: df4
987/88: ISIN = "TRFGDKM22013"
987/89:
page  = requests.get(url).text
soup_expatistan = BeautifulSoup(page)
987/90:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
    return pages[-1].text
987/91:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/92: last_page = get_last_page(ISIN)
987/93: last_page_html = get_content_last_page(last_page, ISIN)
987/94:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
        else:
            term_sheet_url = "N/A"
    return term_sheet_url
987/95:
term_sheet_url = get_full_terms(last_page_html)
term_sheet_url
987/96:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/97: term_sheet_content = get_content_term_sheet_url("term_sheet_url")
987/98: df1, df2, df3, df4 = pd.read_html(term_sheet_url)
987/99: df1
987/100: df = pd.read_html(term_sheet_url)[-1]
987/101: df
987/102: ISIN = "TRFGDKM22013"
987/103:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
    return pages[-1].text
987/104:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/105:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
        else:
            term_sheet_url = "N/A"
    return term_sheet_url
987/106:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/107:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
term_sheet_content = get_content_term_sheet_url("term_sheet_url")
987/108: df = pd.read_html(term_sheet_url)[-1]
987/109: df
987/110: ISIN = "TRFFIBA22018"
987/111:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
    return pages[-1].text
987/112:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/113:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
        else:
            term_sheet_url = "N/A"
    return term_sheet_url
987/114:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/115:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
term_sheet_content = get_content_term_sheet_url("term_sheet_url")
987/116: df
987/117:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
987/118:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
987/119:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
term_sheet_content = get_content_term_sheet_url("term_sheet_url")
987/120: df = pd.read_html(term_sheet_url)[-1]
987/121:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
# term_sheet_url = get_full_terms(last_page_html)
# term_sheet_content = get_content_term_sheet_url("term_sheet_url")
987/122: last_page_html
987/123: list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
987/124: list_of_items
987/125: items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
987/126: items
987/127: list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
987/128: last_page_html
987/129: list_of_items = last_page_html.findAll("div", {"class": "w-container middle-container"})
987/130: last_page_html
987/131: list_of_items
987/132: list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
987/133: list_of_items
987/134: list_of_items = last_page_html.find("div", {"class": "searchResults"})
987/135: list_of_items
987/136: list_of_items = last_page_html.findAll("div", {"class": "searchResults"})
987/137: list_of_items
987/138: list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
987/139: list_of_items
987/140: list_of_items.div
987/141: list_of_items
987/142: last_page
988/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np
import requests
988/2:
path = r"D:\Downloads__\tbliste.xls"

df = pd.read_excel(path)
988/3: df['ISIN Kodu\nISIN Code'][-150:-15]
988/4: ISIN = "TRFFNBK22025"
988/5: ISIN = "TRFFIBA22018"
988/6:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
    return pages[-1].text
988/7:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/8:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/9:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/10:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
# term_sheet_url = get_full_terms(last_page_html)
# term_sheet_content = get_content_term_sheet_url("term_sheet_url")
988/11:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
    return pages[-1].text
988/12:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/13:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/14:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/15:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
# term_sheet_url = get_full_terms(last_page_html)
# term_sheet_content = get_content_term_sheet_url("term_sheet_url")
988/16:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/17:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/18:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/19:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/20:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
# term_sheet_url = get_full_terms(last_page_html)
# term_sheet_content = get_content_term_sheet_url("term_sheet_url")
988/21: last_page
988/22: list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
988/23: list_of_items
988/24: ISIN = "TRFFIBA22018"
988/25:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/26:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/27:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/28:
def get_content_term_sheet_url(term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/29:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
term_sheet_content = get_content_term_sheet_url("term_sheet_url")
988/30:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/31:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/32:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/33:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url)[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/34: df
988/35: ISIN = "TRFHYTV22019"
988/36:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/37:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/38:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/39:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/40:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url)[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/41: df
988/42: ISIN = "TRFDRFN32017"
988/43:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/44:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/45:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/46:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/47:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url)[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/48: df
988/49: term_sheet_url
988/50:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, thousands=',')[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/51: df
988/52:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, decimal=',')[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/53: df
988/54:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, decimal=',', thousands='.')[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/55: df
988/56:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, decimal=',')[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/57: df
988/58:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/59: df
988/60: ISIN = "TRFFNBK32024"
988/61:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/62:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/63:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/64:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/65:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/66: df
988/67: ISIN = "TRFFNBK22074"
988/68:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/69:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/70:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/71:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/72:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/73: df
988/74: ISIN = "TRFNURLK2010"
988/75:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/76:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/77:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/78:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/79:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/80: df
988/81: term_sheet_url
988/82: ISIN = "TRFGKYH42017"
988/83:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/84:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/85:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/86:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/87:
last_page = get_last_page(ISIN)
last_page_html = get_content_last_page(last_page, ISIN)
term_sheet_url = get_full_terms(last_page_html)
df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
988/88: df
988/89:
def retrieve_term_shee(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    
    return df
988/90:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    
    return df
988/91: df = retrieve_term_sheet(ISIN)
988/92: df
988/93: ISIN = "TRFGKYH42017"
988/94:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    
    return df
988/95: df = retrieve_term_sheet(ISIN)
988/96: df
988/97: df, term_sheet_content = retrieve_term_sheet(ISIN)
988/98: df
988/99:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    
    return df, term_sheet_content
988/100: df, term_sheet_content = retrieve_term_sheet(ISIN)
988/101: df
988/102: term_sheet_content
988/103: term_sheet_content.find("div", {"class":"type-medium type-bold bi-sky-black"})
988/104: term_sheet_content.find("div", {"class":"type-medium type-bold bi-sky-black"}).text
988/105:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    issuer = retrieve_issuer_name(term_sheet_content)
    
    return df, term_sheet_content
988/106:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    issuer = retrieve_issuer_name(term_sheet_content)
    
    return df, term_sheet_content, issuer
988/107: df, term_sheet_content, issuer = retrieve_term_sheet(ISIN)
988/108:
def retrieve_issuer_name(term_sheet_content):
    return term_sheet_content.find("div", {"class":"type-medium type-bold bi-sky-black"}).text
988/109: ISIN = "TRFGKYH42017"
988/110:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    issuer = retrieve_issuer_name(term_sheet_content)
    
    return df, term_sheet_content, issuer
988/111: df, term_sheet_content, issuer = retrieve_term_sheet(ISIN)
988/112: df
988/113: issuer
988/114: df.insert(0, {'issuer': issuer})
988/115:
df.loc[-1] = ["issuer", issuer]  # adding a row
df.index = df.index + 1  # shifting index
df.sort_index(inplace=True)
988/116: df
988/117:
def append_issuer_name_to_df(issuer, df):
    df.loc[-1] = ["issuer", issuer]  # adding a row
    df.index = df.index + 1  # shifting index
    df = df.sort_index()
    
    return df
988/118:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    issuer = retrieve_issuer_name(term_sheet_content)
    
    return df, term_sheet_content, issuer
988/119:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/120:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/121:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/122:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/123:
def retrieve_issuer_name(term_sheet_content):
    return term_sheet_content.find("div", {"class":"type-medium type-bold bi-sky-black"}).text
988/124:
def append_issuer_name_to_df(issuer, df):
    df.loc[-1] = ["issuer", issuer]  # adding a row
    df.index = df.index + 1  # shifting index
    df = df.sort_index()
    
    return df
988/125: ISIN = "TRFGKYH42017"
988/126:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    issuer = retrieve_issuer_name(term_sheet_content)
    df = append_issuer_name_to_df(issuer, df)
    
    return df
988/127: df= retrieve_term_sheet(ISIN)
988/128: df
988/129: ISIN = "TRFVKFB42026"
988/130:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    issuer = retrieve_issuer_name(term_sheet_content)
    df = append_issuer_name_to_df(issuer, df)
    
    return df
988/131: df= retrieve_term_sheet(ISIN)
988/132: df
988/133: ISIN = "TRPAK9E92117"
988/134:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
    term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
    issuer = retrieve_issuer_name(term_sheet_content)
    df = append_issuer_name_to_df(issuer, df)
    
    return df
988/135: df= retrieve_term_sheet(ISIN)
988/136:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df
988/137: df= retrieve_term_sheet(ISIN)
988/138: df
988/139: ISIN = "TRFYKYM42028"
988/140:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df
988/141: df= retrieve_term_sheet(ISIN)
988/142: df
988/143:
ISIN = "TRFAKBK32013"
df = retrieve_term_sheet(ISIN)
988/144:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        # df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df
988/145:
ISIN = "TRFAKBK32013"
df = retrieve_term_sheet(ISIN)
988/146: df
988/147:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        # df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/148:
ISIN = "TRFAKBK32013"
df, term_sheet_url = retrieve_term_sheet(ISIN)
988/149: term_sheet_url
988/150:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-2]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        # df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/151:
ISIN = "TRFAKBK32013"
df, term_sheet_url = retrieve_term_sheet(ISIN)
988/152: df
988/153:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        df = pd.read_html(term_sheet_url, decimal=',', thousands="")[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        # df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/154:
ISIN = "TRFAKBK32013"
df, term_sheet_url = retrieve_term_sheet(ISIN)
988/155: df
988/156: "Principal" in df.values
988/157: "Principal" in df.values()
988/158: "Principal" in df.values
988/159: df.values
988/160:
for element in df.values:
    print("Principal" in element)
988/161:
for row in df.values:
    for element in row: 
        print("Principal" in row)
988/162:
for row in df.values:
    for element in row: 
        print(row)
988/163:
for row in df.values:
    for element in row: 
        print(element)
988/164:
for row in df.values:
    for element in row: 
        print("principal" in element.lower())
988/165:
for row in df.values:
    for element in row: 
        print("principal" in element.lower
988/166:
for row in df.values:
    for element in row: 
        print("principal" in element.lower)
988/167:
for row in df.values:
    for element in row: 
        print("principal" in element.lower())
988/168:
for row in df.values:
    for element in row: 
        print("Principal" in element)
988/169:
for row in df.values:
    for element in row: 
        print("Principal" in element)
988/170:
for row in df.values:
    for element in row:
        try:
            print("Principal" in element)
        except TypeError:
            pass
988/171:
bottom_table_check = []

for row in df.values:
    for element in row:
        try:
            bottom_table_check.append("Principal" in element)
        except TypeError:
            pass
        
any(bottom_table_check)
988/172:
bottom_table_check = []

for row in df.values:
    for element in row:
        try:
            bottom_table_check.append("Principal" in element)
        except TypeError:
            pass
        
bottom_table_exists = any(bottom_table_check)
988/173:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = df[-2]
        else:
            df = df[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/174:
ISIN = "TRFAKBK32013"
df, term_sheet_url = retrieve_term_sheet(ISIN)
988/175:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = df[-2]
        else:
            df = df[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/176:
ISIN = "TRFAKBK32013"
df, term_sheet_url = retrieve_term_sheet(ISIN)
988/177:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        return dfs
        if bottom_table_exists(dfs[-1]):
            df = df[-2]
        else:
            df = df[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/178:
ISIN = "TRFAKBK32013"
df, term_sheet_url = retrieve_term_sheet(ISIN)
988/179:
ISIN = "TRFAKBK32013"
df = retrieve_term_sheet(ISIN)
988/180: df
988/181: df[-1]
988/182: bottom_table_exists(df[-1]0
988/183: bottom_table_exists(df[-1])
988/184:
def bottom_table_exists(df):
    
    bottom_table_check = []

    for row in df.values:
        for element in row:
            try:
                bottom_table_check.append("Principal" in element)
            except TypeError:
                pass

    return any(bottom_table_check)
988/185:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        return dfs
        if bottom_table_exists(dfs[-1]):
            df = df[-2]
        else:
            df = df[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/186:
ISIN = "TRFAKBK32013"
df = retrieve_term_sheet(ISIN)
988/187: bottom_table_exists(df[-1])
988/188:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = df[-2]
        else:
            df = df[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/189:
ISIN = "TRFAKBK32013"
df = retrieve_term_sheet(ISIN)
988/190:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_url
988/191:
ISIN = "TRFAKBK32013"
df = retrieve_term_sheet(ISIN)
988/192: bottom_table_exists(df[-1])
988/193: df
988/194:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df
988/195:
ISIN = "TRFAKBK32013"
df = retrieve_term_sheet(ISIN)
988/196: df
988/197:
ISIN = "TRFGRAN32011"
df = retrieve_term_sheet(ISIN)
988/198: df
988/199: term_sheet_url
988/200:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_content
988/201:
ISIN = "TRFGRAN32011"
df = retrieve_term_sheet(ISIN)
988/202: df
988/203:
ISIN = "TRFGRAN32011"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/204: df
988/205: "TLREF" in term_sheet_content
988/206: term_sheet_content
988/207:
ISIN = "TRFAKBK32013"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/208: df
988/209: term_sheet_content
988/210: "TLREF" in term_sheet_content
988/211: term_sheet_content
988/212:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_content
988/213:
ISIN = "TRFTHAL22051"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/214: df
988/215: "TLREF" in term_sheet_content
988/216: term_sheet_content
988/217: term_sheet_url
988/218:
ISIN = "TRFZORF72014"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/219: df
988/220: "TLREF" in term_sheet_content
988/221:
ISIN = "TRSKORTK2026"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/222: df
988/223:
ISIN = "TRSVKFB52028"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/224: df
988/225:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
            
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return dfs, term_sheet_content
988/226:
ISIN = "TRSVKFB52028"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/227: df
988/228: df[0]
988/229:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/230:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/231:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/232:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/233:
def retrieve_issuer_name(term_sheet_content):
    return term_sheet_content.find("div", {"class":"type-medium type-bold bi-sky-black"}).text
988/234:
def append_issuer_name_to_df(issuer, df):
    df.loc[-1] = ["issuer", issuer]  # adding a row
    df.index = df.index + 1  # shifting index
    df = df.sort_index()
    
    return df
988/235:
def bottom_table_exists(df):
    
    bottom_table_check = []

    for row in df.values:
        for element in row:
            try:
                bottom_table_check.append("Principal" in element)
            except TypeError:
                pass

    return any(bottom_table_check)
988/236:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return dfs, term_sheet_content
988/237:
ISIN = "TRSVKFB52028"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/238:
ISIN = "TRFZORF82013"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/239:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df, term_sheet_content
988/240:
ISIN = "TRFZORF82013"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/241: df
988/242:
ISIN = "TRSTTRK42012"
df, term_sheet_content = retrieve_term_sheet(ISIN)
988/243: df
988/244:
for ISIN in df['ISIN Kodu\nISIN Code'][-150:-15]:
    print(ISIN)
988/245:
path = r"D:\Downloads__\tbliste.xls"

tbliste = pd.read_excel(path)
988/246: tbliste['ISIN Kodu\nISIN Code'][-150:-15]
988/247:
for ISIN in tbliste['ISIN Kodu\nISIN Code'][-150:-15]:
    print(ISIN)
988/248:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df
988/249:
ISIN = "TRSTTRK42012"
df = retrieve_term_sheet(ISIN)
988/250: df
988/251: term_sheet_url
988/252:
for ISIN in tbliste['ISIN Kodu\nISIN Code'][-150:-15]:
    df, term_sheet_content = retrieve_term_sheet(ISIN)
988/253: import pandas as pd
988/254:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np
import requests
988/255:
path = r"D:\Downloads__\tbliste.xls"

tbliste = pd.read_excel(path)
988/256: tbliste['ISIN Kodu\nISIN Code'][-150:-15]
988/257:
def get_last_page(ISIN):
    url = "https://www.kap.org.tr/tr/ara/{}/1".format(ISIN)
    page  = requests.get(url).text
    soup_expatistan = BeautifulSoup(page)
    try:
        pages = soup_expatistan.find("div", {"class": "paging"}).findAll("a")
        last_page = pages[-1].text
    except AttributeError:
        last_page = 1 
    return last_page
988/258:
def get_content_last_page(last_page, ISIN):
    url = "https://www.kap.org.tr/tr/ara/{0}/{1}".format(ISIN, last_page)
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/259:
def get_full_terms(last_page_html):
    list_of_items = last_page_html.find("div", {"class": "w-container middle-container"})
    items = list_of_items.findAll("div", {"class":"searchResult disclosure"})
    
    term_sheet_url = "N/A"
    for item in items:
        if "pay" in item.a.text.strip().lower():
            term_sheet_url = "https://www.kap.org.tr" + item.a["href"].replace("tr", "en")
    return term_sheet_url
988/260:
def get_content_term_sheet_url(url, term_sheet_url):
    page  = requests.get(url).text
    return BeautifulSoup(page)
988/261:
def retrieve_issuer_name(term_sheet_content):
    return term_sheet_content.find("div", {"class":"type-medium type-bold bi-sky-black"}).text
988/262:
def append_issuer_name_to_df(issuer, df):
    df.loc[-1] = ["issuer", issuer]  # adding a row
    df.index = df.index + 1  # shifting index
    df = df.sort_index()
    
    return df
988/263:
def bottom_table_exists(df):
    
    bottom_table_check = []

    for row in df.values:
        for element in row:
            try:
                bottom_table_check.append("Principal" in element)
            except TypeError:
                pass

    return any(bottom_table_check)
988/264:
def retrieve_term_sheet(ISIN):
    last_page = get_last_page(ISIN)
    last_page_html = get_content_last_page(last_page, ISIN)
    term_sheet_url = get_full_terms(last_page_html)
    if term_sheet_url != "N/A":
        dfs = pd.read_html(term_sheet_url, decimal=',', thousands="")
        if bottom_table_exists(dfs[-1]):
            df = dfs[-2]
        else:
            df = dfs[-1]
        term_sheet_content = get_content_term_sheet_url(term_sheet_url, "term_sheet_url")
        issuer = retrieve_issuer_name(term_sheet_content)
        df = append_issuer_name_to_df(issuer, df)
    else:
        df = "No Full Term Sheet"
    return df
988/265:
ISIN = "TRSTTRK42012"
df = retrieve_term_sheet(ISIN)
988/266: df
988/267: term_sheet_url
988/268:
dict_data_frame = {}

for ISIN in tbliste['ISIN Kodu\nISIN Code'][-150:-15]:
    df = retrieve_term_sheet(ISIN)
    dict_data_frame[ISIN] = df
988/269:
dict_data_frame = {}

for ISIN in tbliste['ISIN Kodu\nISIN Code'][-150:-15]:
    df = retrieve_term_sheet(ISIN)
    print(df)
    dict_data_frame[ISIN] = df
988/270: dict_data_frame
988/271: dict_data_frame["TRFZORN32012"]
988/272:
ISIN = "TRFZORN32012"
df = retrieve_term_sheet(ISIN)
988/273: df
988/274: term_sheet_url
988/275: dict_data_frame["TRFINFM32017"]
988/276: dict_data_frame["TRSVERA52010"]
989/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np
989/2: driver = webdriver.Chrome(executable_path=r"\chromedriver.exe")
989/3: driver = webdriver.Chrome(executable_path=r"chromedriver.exe")
989/4:
url_to_launch = None

driver = webdriver.Chrome(executable_path="chromedriver.exe")
driver.get(url_to_launch)
990/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import pandas as pd
990/2:
url_to_launch = r"https://plus.credit-suisse.com/authV3/auth/enhancedLogin.fcc?SMQUERYDATA=-SM-iKdPhLWcQorJ9XFqb4Q49TYdWUWwk2olMZW%2bSEk8HqGYwmRP9hSWC73aH70xg2ZxVqdivD0peRXzGLrswzZpEKgNjd1%2flvwg293FzSWPNl985eeDgFCdw7s9s5vszNQg0%2fhf4AEtvZD8NuC9qNwLD4s3nTsZF4Acl1oxFwjf%2bpspXbeDlWwuI4GSro9BP18g0DvGpHlzB%2bYToqqsNPjHs1vtpqi6MClVlwERHR5FkdnS%2bWCQMfn4n8IdpcgoLo%2f%2fHlbMqXnR2CJrdQsvB61yUltYefBx5dIU7EsYZGRfclAEqzUz%2fq9ymHoBKA6SmXX7kSBvGIduF1c%2bCtGXjMc7oPfTcm79EKpc9cciGjHpmfd1eRY9JJ4M4VZXFmVIcEIs"

driver = webdriver.Chrome(executable_path="chromedriver.exe")
driver.get(url_to_launch)
990/3: driver.find_element_by_xpath('//input[@name="username"]')
990/4: driver.find_element_by_xpath('//input[@name=username]')
990/5: driver.find_element_by_xpath('//input[@name="username"]')
990/6: driver.find_element_by_xpath('//input[@ng-model="form.username"]')
990/7: soup = BeautifulSoup(driver.page_source, "html.parser")
990/8: soup
990/9:
url_to_launch = r"https://plus.credit-suisse.com/authV3/auth/enhancedLogin.fcc?SMQUERYDATA=-SM-iKdPhLWcQorJ9XFqb4Q49TYdWUWwk2olMZW%2bSEk8HqGYwmRP9hSWC73aH70xg2ZxVqdivD0peRXzGLrswzZpEKgNjd1%2flvwg293FzSWPNl985eeDgFCdw7s9s5vszNQg0%2fhf4AEtvZD8NuC9qNwLD4s3nTsZF4Acl1oxFwjf%2bpspXbeDlWwuI4GSro9BP18g0DvGpHlzB%2bYToqqsNPjHs1vtpqi6MClVlwERHR5FkdnS%2bWCQMfn4n8IdpcgoLo%2f%2fHlbMqXnR2CJrdQsvB61yUltYefBx5dIU7EsYZGRfclAEqzUz%2fq9ymHoBKA6SmXX7kSBvGIduF1c%2bCtGXjMc7oPfTcm79EKpc9cciGjHpmfd1eRY9JJ4M4VZXFmVIcEIs"

driver = webdriver.Chrome(executable_path="chromedriver.exe")
driver.get(url_to_launch)
990/10: soup = BeautifulSoup(driver.page_source, "html.parser")
990/11: soup
991/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import pandas as pd
991/2:
url_to_launch = r"https://plus.credit-suisse.com/authV3/auth/enhancedLogin.fcc?SMQUERYDATA=-SM-iKdPhLWcQorJ9XFqb4Q49TYdWUWwk2olMZW%2bSEk8HqGYwmRP9hSWC73aH70xg2ZxVqdivD0peRXzGLrswzZpEKgNjd1%2flvwg293FzSWPNl985eeDgFCdw7s9s5vszNQg0%2fhf4AEtvZD8NuC9qNwLD4s3nTsZF4Acl1oxFwjf%2bpspXbeDlWwuI4GSro9BP18g0DvGpHlzB%2bYToqqsNPjHs1vtpqi6MClVlwERHR5FkdnS%2bWCQMfn4n8IdpcgoLo%2f%2fHlbMqXnR2CJrdQsvB61yUltYefBx5dIU7EsYZGRfclAEqzUz%2fq9ymHoBKA6SmXX7kSBvGIduF1c%2bCtGXjMc7oPfTcm79EKpc9cciGjHpmfd1eRY9JJ4M4VZXFmVIcEIs"

driver = webdriver.Chrome(executable_path="chromedriver.exe")
driver.get(url_to_launch)
991/3: soup = BeautifulSoup(driver.page_source, "html.parser")
991/4: soup
991/5: driver.find_element_by_xpath('/html/body/div[2]/div[1]/div[2]/div/div[1]/div[2]/input[1]')
991/6: driver.page_source
991/7:
url_to_launch = r"https://plus.credit-suisse.com/authV3/auth/enhancedLogin.fcc?SMQUERYDATA=-SM-iKdPhLWcQorJ9XFqb4Q49TYdWUWwk2olMZW%2bSEk8HqGYwmRP9hSWC73aH70xg2ZxVqdivD0peRXzGLrswzZpEKgNjd1%2flvwg293FzSWPNl985eeDgFCdw7s9s5vszNQg0%2fhf4AEtvZD8NuC9qNwLD4s3nTsZF4Acl1oxFwjf%2bpspXbeDlWwuI4GSro9BP18g0DvGpHlzB%2bYToqqsNPjHs1vtpqi6MClVlwERHR5FkdnS%2bWCQMfn4n8IdpcgoLo%2f%2fHlbMqXnR2CJrdQsvB61yUltYefBx5dIU7EsYZGRfclAEqzUz%2fq9ymHoBKA6SmXX7kSBvGIduF1c%2bCtGXjMc7oPfTcm79EKpc9cciGjHpmfd1eRY9JJ4M4VZXFmVIcEIs"

driver = webdriver.Chrome()
driver.get(url_to_launch)
991/8:
url_to_launch = r"https://plus.credit-suisse.com/ECPIplanetSecureLoginV3/enhancedLogin"

driver = webdriver.Chrome()
driver.get(url_to_launch)
991/9: driver.page_source
991/10: soup = BeautifulSoup(driver.page_source, "html.parser")
991/11: soup
991/12: soup.find("input", {"name":"username"})
991/13: driver.find_element_by_xpath('//input[@name="username"]')
991/14:
def username_send_keys(keys):
    username_text_box = driver.find_element_by_xpath('//input[@name="username"]')
    username_text_box.send_keys("ankapeng")
991/15: username_send_keys()
991/16: username_send_keys("ankapeng")
991/17: username_send_keys("ankapeng")
991/18:
def password_send_keys(keys):
    password_text_box = driver.find_element_by_xpath('//input[@name="password"]')
    password_text_box.send_keys(keys)
991/19: password_send_keys("kapengu1")
991/20:  driver.find_element_by_xpath('//button[@class="btn"]')
991/21:
def login():
    login_button = driver.find_element_by_xpath('//button[@class="btn"]')
    login.button.click()
991/22:
username_send_keys("ankapeng")
password_send_keys("kapengu1")
login()
991/23: driver.find_element_by_xpath('//button[@class="btn"]')
991/24: driver.find_element_by_xpath('//button[@class="btn"]').click()
992/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import pandas as pd
import time
992/2:
def launch_url(url_to_launch):
    driver = webdriver.Chrome()
    driver.get(url_to_launch)
    return driver
992/3:
def username_send_keys(driver, keys):
    username_text_box = driver.find_element_by_xpath('//input[@name="username"]')
    username_text_box.send_keys(keys)
992/4:
def password_send_keys(driver, keys):
    password_text_box = driver.find_element_by_xpath('//input[@name="password"]')
    password_text_box.send_keys(keys)
992/5:
def login(driver):
    login_button = driver.find_element_by_xpath('//button[@class="btn"]')
    login.button.click()
992/6: driver.find_element_by_xpath('//button[@class="btn"]').click()
992/7:
url_to_launch = r"https://plus.credit-suisse.com/ECPIplanetSecureLoginV3/enhancedLogin"

driver = launch_url(url_to_launch)
username_send_keys(driver, "ankapeng")
password_send_keys(driver, "kapengu1")
time.wait(1)
login(driver)
992/8:
url_to_launch = r"https://plus.credit-suisse.com/ECPIplanetSecureLoginV3/enhancedLogin"

driver = launch_url(url_to_launch)
username_send_keys(driver, "ankapeng")
password_send_keys(driver, "kapengu1")
time.sleep(1)
login(driver)
992/9:
def login(driver):
    login_button = driver.find_element_by_xpath('//button[@class="btn"]')
    login_button.click()
992/10:
url_to_launch = r"https://plus.credit-suisse.com/ECPIplanetSecureLoginV3/enhancedLogin"

driver = launch_url(url_to_launch)
username_send_keys(driver, "ankapeng")
password_send_keys(driver, "kapengu1")
time.sleep(1)
login(driver)
993/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import pandas as pd
import time
993/2:
def launch_url(url_to_launch):
    driver = webdriver.Chrome()
    driver.get(url_to_launch)
    return driver
993/3:
def username_send_keys(driver, keys):
    username_text_box = driver.find_element_by_xpath('//input[@name="username"]')
    username_text_box.send_keys(keys)
993/4:
def password_send_keys(driver, keys):
    password_text_box = driver.find_element_by_xpath('//input[@name="password"]')
    password_text_box.send_keys(keys)
993/5:
def login(driver):
    login_button = driver.find_element_by_xpath('//button[@class="btn"]')
    login_button.click()
993/6:
url_to_launch = r"https://plus.credit-suisse.com/ECPIplanetSecureLoginV3/enhancedLogin"

driver = launch_url(url_to_launch)
username_send_keys(driver, "ankapeng")
password_send_keys(driver, "kapengu1")
time.sleep(1)
login(driver)
993/7:
url_to_launch = r"https://sso.theice.com/appUserLogin?redirectUrl=https://indices.theice.com/home?authFilterRedirectUrl=http%25253A%25252F%25252Findices.theice.com%25252Fhome&loginApp=GIS#pageLogin"

driver = launch_url(url_to_launch)
993/8:
def username_send_keys(driver, keys):
    username_text_box = driver.find_element_by_xpath('//input[@name="user"]')
    username_text_box.send_keys(keys)
993/9:
def password_send_keys(driver, keys):
    password_text_box = driver.find_element_by_xpath('//input[@name="password"]')
    password_text_box.send_keys(keys)
993/10:
def login(driver):
    login_button = driver.find_element_by_xpath('//input[@id="loginPageSubmitBtn"]')
    login_button.click()
993/11:
def wait_until_logs_in(driver):
    delay = 9999999999
    myElem = WebDriverWait(driver, delay).until(EC.presence_of_element_located((By.XPATH, '//a[@href="/signOut"]')))
994/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import pandas as pd
import time
994/2:
def launch_url(url_to_launch):
    driver = webdriver.Chrome()
    driver.get(url_to_launch)
    return driver
994/3:
def username_send_keys(driver, keys):
    username_text_box = driver.find_element_by_xpath('//input[@name="user"]')
    username_text_box.send_keys(keys)
994/4:
def password_send_keys(driver, keys):
    password_text_box = driver.find_element_by_xpath('//input[@name="password"]')
    password_text_box.send_keys(keys)
994/5:
def login(driver):
    login_button = driver.find_element_by_xpath('//input[@id="loginPageSubmitBtn"]')
    login_button.click()
994/6:
def wait_until_logs_in(driver):
    delay = 9999999999
    myElem = WebDriverWait(driver, delay).until(EC.presence_of_element_located((By.XPATH, '//a[@href="/signOut"]')))
994/7:
url_to_launch = r"https://sso.theice.com/appUserLogin?redirectUrl=https://indices.theice.com/home?authFilterRedirectUrl=http%25253A%25252F%25252Findices.theice.com%25252Fhome&loginApp=GIS#pageLogin"

driver = launch_url(url_to_launch)
username_send_keys(driver, "robert.attle@pgim.com")
password_send_keys(driver, "Attlkr6@")
login(driver)
wait_until_logs_in(driver)
994/8:
url_to_launch = r"https://sso.theice.com/appUserLogin?redirectUrl=https://indices.theice.com/home?authFilterRedirectUrl=http%25253A%25252F%25252Findices.theice.com%25252Fhome&loginApp=GIS#pageLogin"

driver = launch_url(url_to_launch)
time.sleep(3)
username_send_keys(driver, "robert.attle@pgim.com")
password_send_keys(driver, "Attlkr6@")
login(driver)
wait_until_logs_in(driver)
994/9: driver.find_element_by_xpath('//input[@name="password"]')
994/10:
driver.find_element_by_xpath('//input[@name="password"]')
password_text_box.send_keys("Attlkr6@")
994/11:
password_text_box =[ driver.find_element_by_xpath('//input[@name="password"]')
password_text_box.send_keys("Attlkr6@")
994/12:
password_text_box = driver.find_element_by_xpath('//input[@name="password"]')
password_text_box.send_keys("Attlkr6@")
994/13:
password_text_box = driver.find_element_by_xpath('//input[@name="password"]')
password_text_box.click()
password_text_box.send_keys("Attlkr6@")
994/14:
password_text_box = driver.find_element_by_xpath('//input[@type="password"]')
password_text_box.click()
password_text_box.send_keys("Attlkr6@")
994/15:
def clickElement(driver, reference_button, x_off, y_off):
    action = webdriver.common.action_chains.ActionChains(driver)
    action.move_to_element_with_offset(reference_button, x_off, y_off)
    action.click()
    action.perform()
    return action
994/16: password_text_box = driver.find_element_by_xpath('//input[@type="password"]')
994/17: clickElement(driver, password_text_box, 0,0)
994/18: clickElement(driver, password_text_box, 0.1,0.1)
994/19:
action = clickElement(driver, password_text_box)
action.click()
994/20:
action = clickElement(driver, password_text_box, 0 , 0)
action.click()
994/21: password_text_box = driver.find_element_by_xpath('//input[@type="password"]')
994/22:
action = clickElement(driver, password_text_box, 0 , 0)
action.click()
994/23: password_text_box.location
994/24: driver.find_element_by_xpath('//*[@id="loginHolder"]/div[2]/div[1]/input')
994/25: driver.find_element_by_xpath('//*[@id="loginHolder"]/div[2]/div[1]/input').click()
994/26: password_text_box.click()
995/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import pandas as pd
import time
995/2:
def launch_url(url_to_launch):
    driver = webdriver.Chrome()
    driver.get(url_to_launch)
    return driver
995/3:
def username_send_keys(driver, keys):
    username_text_box = driver.find_element_by_xpath('//input[@name="user"]')
    username_text_box.send_keys(keys)
995/4:
def password_send_keys(driver, keys):
    password_text_box = driver.find_element_by_xpath('//*[@id="loginHolder"]/div[2]/div[1]/input')
    password_text_box.send_keys(keys)
995/5:
def login(driver):
    login_button = driver.find_element_by_xpath('//input[@id="loginPageSubmitBtn"]')
    login_button.click()
995/6:
def wait_until_logs_in(driver):
    delay = 9999999999
    myElem = WebDriverWait(driver, delay).until(EC.presence_of_element_located((By.XPATH, '//a[@href="/signOut"]')))
995/7:
url_to_launch = r"https://sso.theice.com/appUserLogin?redirectUrl=https://indices.theice.com/home?authFilterRedirectUrl=http%25253A%25252F%25252Findices.theice.com%25252Fhome&loginApp=GIS#pageLogin"

driver = launch_url(url_to_launch)
time.sleep(3)
username_send_keys(driver, "robert.attle@pgim.com")
password_send_keys(driver, "Attlkr6@")
login(driver)
wait_until_logs_in(driver)
995/8:
url_to_launch = r"https://sso.theice.com/appUserLogin?redirectUrl=https://indices.theice.com/home?authFilterRedirectUrl=http%25253A%25252F%25252Findices.theice.com%25252Fhome&loginApp=GIS#pageLogin"

driver = launch_url(url_to_launch)
time.sleep(3)
username_send_keys(driver, "robert.attle@pgim.com")
password_send_keys(driver, "Attlekr6@")
login(driver)
wait_until_logs_in(driver)
995/9: 9999999999/60
995/10:
url_logged = r"https://indices.theice.com/savedProfileMenu/doView?pageTitle=Index%20Profile%20Analysis"
driver = launch_urlurl_logged(url_logged)
995/11:
url_logged = r"https://indices.theice.com/savedProfileMenu/doView?pageTitle=Index%20Profile%20Analysis"
driver = launch_url(url_logged)
995/12:
url_logged = r"https://indices.theice.com/savedProfileMenu/doView?pageTitle=Index%20Profile%20Analysis"
driver.get(url_logged)
995/13:
url_to_launch = r"https://sso.theice.com/appUserLogin?redirectUrl=https://indices.theice.com/home?authFilterRedirectUrl=http%25253A%25252F%25252Findices.theice.com%25252Fhome&loginApp=GIS#pageLogin"

driver = launch_url(url_to_launch)
time.sleep(3)
username_send_keys(driver, "robert.attle@pgim.com")
password_send_keys(driver, "Attlekr6@")
login(driver)
wait_until_logs_in(driver)
996/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import pandas as pd
import time
996/2:
def launch_url(url_to_launch):
    driver = webdriver.Chrome()
    driver.get(url_to_launch)
    return driver
996/3:
def username_send_keys(driver, keys):
    username_text_box = driver.find_element_by_xpath('//input[@name="user"]')
    username_text_box.send_keys(keys)
996/4:
def password_send_keys(driver, keys):
    password_text_box = driver.find_element_by_xpath('//*[@id="loginHolder"]/div[2]/div[1]/input')
    password_text_box.send_keys(keys)
996/5:
def login(driver):
    login_button = driver.find_element_by_xpath('//input[@id="loginPageSubmitBtn"]')
    login_button.click()
996/6:
def wait_until_logs_in(driver):
    delay = 9999999999
    myElem = WebDriverWait(driver, delay).until(EC.presence_of_element_located((By.XPATH, '//a[@href="/signOut"]')))
996/7:
url_to_launch = r"https://sso.theice.com/appUserLogin?redirectUrl=https://indices.theice.com/home?authFilterRedirectUrl=http%25253A%25252F%25252Findices.theice.com%25252Fhome&loginApp=GIS#pageLogin"

driver = launch_url(url_to_launch)
time.sleep(3)
username_send_keys(driver, "robert.attle@pgim.com")
time.sleep(1)
password_send_keys(driver, "Attlekr6@")
time.sleep(1)
login(driver)
wait_until_logs_in(driver)
996/8:
url_logged = r"https://indices.theice.com/savedProfileMenu/doView?pageTitle=Index%20Profile%20Analysis"
driver.get(url_logged)
996/9: driver.find_element_by_xpath('//div[@ext:qtip="L3 - Spreads "]')
996/10: driver.find_element_by_xpath('//div[@ext:qtip="L3 - Spreads"]')
996/11: driver.find_element_by_xpath('//div[@ext:qtip="L3 - Spreads (As of 01/22/2020)"]')
996/12: driver.get_source
996/13: soup = BeautifulSoup(driver.page_source, "html.parser")
996/14:
soup.find("div", {"ext:qtip":"L3 - Spreads
                  "})
996/15: soup.find("div", {"ext:qtip":"L3 - Spreads"})
996/16: soup.find("div")
996/17: soup.find("div", {"ext:qtip":"L3"})
996/18: soup.find("div", {"class:qtip":"x-grid3-cell-inner x-grid3-col-1 x-unselectable"})
996/19: driver.page_source
996/20: soup.find("div", {"ext:qtip":"L3 - Spreads"})
996/21: type(soup.find("div", {"ext:qtip":"L3 - Spreads"}))
996/22: soup.find("div", {"ext:qtip":"L3 - Spreads"})
996/23: soup.find("div", {"ext:qtip":"x-grid3-row x-grid3-row-gis"})
996/24: soup.find("div", {"class":"x-grid3-body"})
996/25:
def launch_url(url_to_launch):

    opts = Options()
    opts.add_argument("user-agent=Mozilla/5.0 (X11; CrOS x86_64 8172.45.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.64 Safari/537.36")

    driver = webdriver.Chrome(chrome_options=opts)
    driver.get(url_to_launch)
    return driver
996/26:
def username_send_keys(driver, keys):
    username_text_box = driver.find_element_by_xpath('//input[@name="user"]')
    username_text_box.send_keys(keys)
996/27:
def password_send_keys(driver, keys):
    password_text_box = driver.find_element_by_xpath('//*[@id="loginHolder"]/div[2]/div[1]/input')
    password_text_box.send_keys(keys)
996/28:
def login(driver):
    login_button = driver.find_element_by_xpath('//input[@id="loginPageSubmitBtn"]')
    login_button.click()
996/29:
def wait_until_logs_in(driver):
    delay = 9999999999
    myElem = WebDriverWait(driver, delay).until(EC.presence_of_element_located((By.XPATH, '//a[@href="/signOut"]')))
996/30:
url_to_launch = r"https://sso.theice.com/appUserLogin?redirectUrl=https://indices.theice.com/home?authFilterRedirectUrl=http%25253A%25252F%25252Findices.theice.com%25252Fhome&loginApp=GIS#pageLogin"

driver = launch_url(url_to_launch)
time.sleep(3)
username_send_keys(driver, "robert.attle@pgim.com")
time.sleep(1)
password_send_keys(driver, "Attlekr6@")
time.sleep(1)
login(driver)
wait_until_logs_in(driver)
996/31:
url_logged = r"https://indices.theice.com/savedProfileMenu/doView?pageTitle=Index%20Profile%20Analysis"
driver.get(url_logged)
996/32: driver.find_element_by_xpath('//div[@ext:qtip="L3 - Spreads (As of 01/22/2020)"]')
996/33: driver.find_element_by_xpath('//img[@src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="]')
996/34:
def clickElement(driver, reference_button, x_off, y_off):
    action = webdriver.common.action_chains.ActionChains(driver)
    action.move_to_element_with_offset(reference_button, x_off, y_off)
    action.click()
    action.perform()
    return action
996/35: ref = driver.find_element_by_xpath('//img[@src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="]')
996/36:
def clickElement(driver, reference_button, x_off, y_off):
    action = webdriver.common.action_chains.ActionChains(driver)
    action.move_to_element_with_offset(reference_button, x_off, y_off)
    action.click()
    action.perform()
    return action
996/37:
url_logged = r"https://indices.theice.com/savedProfileMenu/doView?pageTitle=Index%20Profile%20Analysis"
driver.get(url_logged)
996/38: driver.page_source
996/39: driver.page_source
996/40: driver.find_element_by_xpath('//div[@ext:qtip="L3 - Spreads (As of 01/22/2020)"]')
996/41: driver.find_element_by_xpath('//*[@id="ext-gen80"]/div[5]/table/tbody/tr/td[2]/div')
996/42: driver.find_element_by_xpath('//*[@ext:qtip="L3 - Spreads (As of 01/22/2020)"]')
996/43: driver.find_element_by_xpath('/html/body/div[1]/table[4]/tbody/tr/td/div/div[1]/div/div/div/div[1]/div[2]/div/div/div[1]/div/div/div[6]/div[2]/div/div/div/div/div/div[1]/div[2]/div/div[5]/table/tbody/tr/td[2]/div')
996/44: _
996/45: dict(_)
996/46: vars(_)
996/47:
attrs=[]
for attr in _.get_property('attributes'):
    attrs.append([attr['name'], attr['value']])
print(attrs)
996/48: _
996/49: driver.find_element_by_xpath('/html/body/div[1]/table[4]/tbody/tr/td/div/div[1]/div/div/div/div[1]/div[2]/div/div/div[1]/div/div/div[6]/div[2]/div/div/div/div/div/div[1]/div[2]/div/div[5]/table/tbody/tr/td[2]/div')
996/50: _
996/51:
attrs=[]
for attr in _.get_property('attributes'):
    attrs.append([attr['name'], attr['value']])
print(attrs)
996/52: driver.find_element_by_xpath('//div[@ext:qtip="L3 - Spreads\xa0(As of\xa001/22/2020)"]')
996/53: driver.find_element_by_xpath('//div[name()="ext:qtip"]')
996/54: driver.find_element_by_xpath('//div')
996/55: list(driver.find_element_by_xpath('//div'))
996/56: driver.find_elements_by_xpath('//div')
996/57: def find_by_attr(name, val):
996/58: def find_by_attr(elements, name, val):
996/59:
def find_by_attr(elements, name, val):
    return elements[0]
996/60: driver.find_elements_by_xpath('//div')
996/61: find_by_attr(driver.find_elements_by_xpath('//div'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/62:
def find_by_attr(elements, name, val):
    element = elements[0]
    returnvars(element)
996/63:
def find_by_attr(elements, name, val):
    element = elements[0]
    return vars(element)
996/64: find_by_attr(driver.find_elements_by_xpath('//div'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/65:
def find_by_attr(elements, name, val):
    element = elements[0]
    return element.get_attribute('a', None)
996/66: find_by_attr(driver.find_elements_by_xpath('//div'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/67:
def find_by_attr(elements, name, val):
    element = elements[0]
    return element.get_attribute('a')
996/68: find_by_attr(driver.find_elements_by_xpath('//div'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/69:
def find_by_attr(elements, name, val):
    element = elements[0]
    return [element.get_attribute('a') for element in elements]
996/70: find_by_attr(driver.find_elements_by_xpath('//div'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/71: find_by_attr(driver.find_elements_by_xpath('//div'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/72:
def find_by_attr(elements, name, val):
    element = elements[0]
    return [element.get_attribute('a') for element in elements]
996/73:
def find_by_attr(elements, name, val):
    element = elements[0]
    return [element.get_attribute('ext:qtip') for element in elements]
996/74: find_by_attr(driver.find_elements_by_xpath('//div'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/75: find_by_attr(driver.find_elements_by_xpath('//div[@class="x-grid3-cell-inner"]'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/76:
def find_by_attr(elements, name, val):
    return [element.get_attribute('ext:qtip') for element in elements]
996/77: driver
996/78: driver.source
996/79: driver.page_source
996/80: driver.find_element_by_css_selector("div[ext:qtip='L3 - Spreads\xa0(As of\xa001/22/2020)']")
996/81: driver.find_element_by_css_selector("div[ext:qtip=fd]")
996/82: driver.find_element_by_css_selector("div[ext:qtip=fd]")
996/83: driver.find_element_by_css_selector("div[qtip=fd]")
996/84: find_by_attr(driver.find_elements_by_xpath('//div[@class="x-grid3-cell-inner"]'), 'ext:qtip', 'L3 - Spreads\xa0(As of\xa001/22/2020)')
996/85:
attrs=[]
for attr in _.get_property('attributes'):
    attrs.append([attr['name'], attr['value']])
print(attrs)
996/86: driver.find_element_by_xpath('/html/body/div[1]/table[4]/tbody/tr/td/div/div[1]/div/div/div/div[1]/div[2]/div/div/div[1]/div/div/div[6]/div[2]/div/div/div/div/div/div[1]/div[2]/div/div[5]/table/tbody/tr/td[2]/div')
996/87:
attrs=[]
for attr in _.get_property('attributes'):
    attrs.append([attr['name'], attr['value']])
print(attrs)
996/88:
attrs=[]
for attr in _.get_property('attributes'):
    attrs.append([attr['name'], attr['value']])
print(attrs)
996/89:
attrs=[]
for attr in _.get_property('attributes'):
    print(attr)
    attrs.append([attr['name'], attr['value']])
print(attrs)
996/90:
attrs=[]
for attr in _.get_property('attributes'):
    print(attr['name'], attr)
    attrs.append([attr['name'], attr['value']])
print(attrs)
996/91: driver.find_elements_by_xpath('//div[@class="x-grid3-cell-inner"]')
996/92: driver.find_elements_by_xpath('//div[name()="ext:qtip"]')
996/93: driver.find_elements_by_xpath('//div//@[name()="ext:qtip"]')
996/94: driver.find_element_by_xpath("div[qtip=fd]")
996/95: driver.find_elements_by_xpath('//div[@ext:qtip]')
996/96: driver
996/97: driver.find_elements_by_xpath('//div[@ext\:qtip]')
997/1:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)


    def scrollDowninRightSubWindow(self):
        reference_button = scrape.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(0.3)
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(40)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(0.5)
997/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
997/3: scrape = ScrapeJobsPage()
997/4: login.SignIn()
997/5: navigate.clickJobs()
997/6: navigate.clickUKJuniorDataScientist()
997/7: navigate.clickUKJuniorDataScientist()
997/8: scrape.initialiseCrawler()
997/9: import numpy as np
997/10: np.random.normal()
997/11: np.random.normal(0, 1)
997/12: np.random.normal(0, 1)
997/13: np.random.normal(0, 1)
997/14: np.random.normal(0, 1)
997/15: np.random.normal(2, 1)
997/16: np.random.normal(2, 1)
997/17: np.random.normal(2, 1)
997/18: np.random.normal(2, 1)
997/19: np.random.normal(2, 1)
997/20: np.random.normal(2, 1)
997/21: np.random.normal(2, 1)
997/22: np.random.normal(2, 1)
997/23: np.random.normal(2, 1)
997/24: np.random.normal(2, 1)
997/25: np.random.normal(2, 1)
997/26: np.random.normal(2, 1)
997/27: np.random.normal(2, 1)
997/28: np.random.normal(1.2, 0.3)
997/29: np.random.normal(1.2, 0.3)
997/30: np.random.normal(1.2, 0.3)
997/31: np.random.normal(1.2, 0.3)
997/32: np.random.normal(1.2, 0.3)
997/33: np.random.normal(1.2, 0.3)
997/34: np.random.normal(1.2, 0.3)
997/35: np.random.normal(1.2, 0.3)
997/36: np.random.normal(1.2, 0.3)
997/37: np.random.normal(0.6, 0.3)
997/38: np.random.normal(0.6, 0.3)
997/39: np.random.normal(0.6, 0.3)
997/40: np.random.normal(0.6, 0.3)
997/41: np.random.normal(0.6, 0.3)
997/42: np.random.normal(0.6, 0.3)
997/43: np.random.normal(0.6, 0.3)
997/44: np.random.normal(0.6, 0.3)
997/45: np.random.normal(0.6, 0.3)
997/46: np.random.normal(0.6, 0.3)
997/47: np.random.normal(0.6, 0.3)
997/48: np.random.normal(0.6, 0.3)
997/49: np.random.normal(0.6, 0.3)
997/50: np.random.normal(0.6, 0.3)
997/51: np.random.normal(0.6, 0.3)
997/52: np.random.normal(0.6, 0.3)
997/53: np.random.normal(0.6, 0.3)
997/54: np.random.normal(0.6, 0.3)
997/55: np.random.normal(0.6, 0.3)
997/56: np.random.normal(0.6, 0.3)
997/57: np.random.normal(0.6, 0.3)
997/58: np.random.normal(0.6, 0.3)
997/59: np.random.normal(0.6, 0.3)
997/60: for i in range(np.random.normal(0.6, 0.3)
997/61:
for i in range(1000):
    print(np.random.normal(0.6, 0.3))
997/62:
for i in range(1000):
    print(np.random.normal(0.6, 0.2))
997/63:
for i in range(1000):
    print(np.random.normal(0.8, 0.2))
997/64:
for i in range(1000):
    print(np.random.normal(0.6, 0.2))
997/65:
for i in range(1000):
    print(np.random.normal(0.6, 0.1))
997/66:
for i in range(1000):
    print(np.random.normal(0.4, 0.1))
998/1:
from job_application_filter import *
from bs4 import BeautifulSoup
998/2:
from job_application_filter import *
from bs4 import BeautifulSoup
998/3:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
998/4: scrape = ScrapeJobsPage()
998/5: login.SignIn()
998/6: login.SignIn()
998/7: login.SignIn()
998/8: login.SignIn()
998/9: login.SignIn()
999/1:
from job_application_filter import *
from bs4 import BeautifulSoup
999/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
999/3: scrape = ScrapeJobsPage()
999/4: login.SignIn()
999/5: navigate.clickJobs()
999/6: navigate.clickUKJuniorDataScientist()
999/7: navigate.clickUKJuniorDataScientist()
999/8: scrape.initialiseCrawler()
999/9: scrape.initialiseCrawler()
1000/1:
from job_application_filter import *
from bs4 import BeautifulSoup
1000/2:
url = "https://www.linkedin.com/"
driver, data = InitialiseLinkedin(url)
login = Login(driver, data)
navigate = NavigateLinkedIn()
1000/3: scrape = ScrapeJobsPage()
1000/4: login.SignIn()
1000/5:
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from selenium import webdriver
from bs4 import BeautifulSoup
import json
import re
import time
import pandas as pd
import datetime as dt
from datetime import datetime
import numpy as np

def InitialiseLinkedin(url_to_launch):
    
    global driver

    with open(r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\Keys.json") as f:
        data = json.load(f)

    option = Options()

    option.add_argument("--disable-infobars")
    option.add_argument("start-maximized")
    option.add_argument("--disable-extensions")

    # Pass the argument 1 to allow and 2 to block
    option.add_experimental_option("prefs", {
    "profile.default_content_setting_values.notifications": 1 })

    driver = webdriver.Chrome(options=option,
                              executable_path=r"C:\Users\Cagri\Google Drive\Self Study\Job Application Filter Project\chromedriver.exe")

    driver.get(url_to_launch)

    return driver, data


class Login(object):

    def __init__(self,driver,data):
        self.driver = driver
        self.data = data
        self.email = None
        self.password = None
        self.submit_button = None

    def clickSignIn(self):
        #Clicks on sign in button in the initial screen
        self.driver.find_element_by_xpath("/html/body/nav/a[3]").click()

        self.email = self.driver.find_element_by_id("username")
        self.password = self.driver.find_element_by_id("password")
        self.submit_button = self.driver.find_element_by_tag_name("button")

    def SignIn(self):
         self.clickSignIn()
         self.email.send_keys(list(self.data.values())[0])
         self.password.send_keys(list(self.data.values())[1])
         self.submit_button.send_keys(Keys.ENTER)


class NavigateLinkedIn(object):

    def __init__(self):
        self.driver = driver

    def clickJobs(self):
        self.driver.find_element_by_id("jobs-nav-item").click()

    def clickUKJuniorDataScientist(self):
        self.driver.find_element_by_class_name("flex-1").click()


class ScrapeJobsPage(object):
   

    def __init__(self):
        self.driver = driver

        self.soup = None

        self.lst_job_ads = None
        self.dict_html_content = {}

        self.df = pd.DataFrame({
                                'company_name': [],
                                'company_size': [],
                                'company_sector_TOP': [],
                                'company_sector_BOTTOM': [],
                                'job_title': [],
                                'position_level_TOP': [],
                                'position_level_BOTTOM': [],
                                'job_function': [],
                                'applicant_count' : [],
                                'job_location': [],
                                'job_post_date': [],
                                'days_since_posted': [],
                                'base_salary': [],
                                'total_compensation': [],
                                'job_href': []
                                })

        self.today = datetime.today()



    def passHTMLContenttoBeautifulSoup(self):
        self.soup = BeautifulSoup(self.driver.page_source, "html.parser")


    def hideChatBox(self):
        wait = WebDriverWait(self.driver, 1)
        wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "input[placeholder='Search messages']")))
        self.driver.find_element_by_css_selector("header[class='msg-overlay-bubble-header ']").click()


    def closeFeedbackWindow(self):
        self.driver.find_element_by_xpath('//button[@data-control-name="search_feedback_close"]').click()


    def scrollDowninLeftSubWindow(self):
        reference_button = self.driver.find_element_by_css_selector("button[aria-label='Manage alerts']")
        action = self.clickElement(reference_button, 35, 78)

        for _ in range(3):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(np.random.normal(loc=0.4, scale=0.1))


    def scrollDowninRightSubWindow(self):
        reference_button = self.driver.find_element_by_xpath('//artdeco-dropdown-trigger[@data-control-name="jobdetails_topcard_options"]')
        action = self.clickElement(reference_button, 26, 132)
        
        for _ in range(2):
            action.send_keys(Keys.SPACE).perform()
            time.sleep(np.random.normal(loc=0.4, scale=0.1))
            
            
    def displayInformation(self, data_to_add):
        for key,value in data_to_add.items():
            if key != "job_href":
                print(key+":", value)
        print("\n")


    def clickElement(self, reference_button, x_off, y_off):
        action = webdriver.common.action_chains.ActionChains(self.driver)
        action.move_to_element_with_offset(reference_button, x_off, y_off)
        action.click()
        action.perform()
        return action


    def clickJobAd(self):
        reference_button = self.driver.find_element_by_id("{}".format(self.job_ID))
        self.clickElement(reference_button, 0, 0)


    def retrieveFinalPageNumber(self):
        
        #find ul whose class name should be as below.
        #Then find the tags "li". the final element of the "li" is the last page available
        self.passHTMLContenttoBeautifulSoup()
        last_page = self.soup.find("ul",class_ = "artdeco-pagination__pages artdeco-pagination__pages--number").\
        find_all("li")[-1].span.text
        return last_page


# *************** LEFT FRAME **************************************************************************************


    def retrieveJobTitle(self, job_ad):
        try:
            self.job_title = (job_ad.find("h3").text.strip())
            self.job_title = re.sub(r"\n|Promoted","", self.job_title).strip()
        except AttributeError:
            self.job_title = ""


    def retrieveCompanyName(self, job_ad):
        try:
            self.company_name = job_ad.find("a", attrs={"data-control-name":"job_card_company_link"}).text.strip()
        except AttributeError:
            self.company_name = ""


    def retrieveJobAdID(self, job_ad):
        self.job_ID = job_ad.find("h3")["id"]


    def retrieveJobLocation(self):
        id_h3 = re.search(r"\d+", self.job_ID).group(0)
        id_loc = int(id_h3) + 4
        id_loc = "ember" + str(id_loc)
        try:
            self.job_location = self.soup.find(id=id_loc).text.strip()
        except:
            self.job_location = ""
        
        if "applicant" in self.job_location:
            self.job_location = ""


    def retrieveJobHREF(self, job_ad):
        self.job_href = job_ad.a["href"]
        self.job_href = "www.linkedin.com" + self.job_href


    def retrieveJobPostDate(self, job_ad):
        self.job_post_date = job_ad.find("time")["datetime"]
        self.job_post_date = dt.datetime.strptime(self.job_post_date, '%Y-%m-%d')


    def calculateDaysSincePosted(self):
        self.days_since_posted = int((self.today - self.job_post_date).days)


# ************************* RIGHT FRAME ***************************************************************************


    def retrieveCompanySizeandCompanySectorTOP(self):
        company_text = self.soup.find("div", class_ = "ph2").text
        company_text = re.sub(r"\n", "", company_text).strip()

        if "employee" in company_text:
            self.company_sector_TOP = re.search(r"employees? (.+)", company_text)
            if self.company_sector_TOP:
                self.company_sector_TOP = self.company_sector_TOP.group(1)
            else:
                self.company_sector_TOP = ""
            self.company_size = re.search(r"\s+(.+) employee", company_text).group(1)
        else:
            self.company_sector_TOP = ""
            self.company_size = ""

        if "," in self.company_sector_TOP:
            if not "&" in self.company_sector_TOP:
                self.company_sector_TOP = ""
            else:
                pass


    def retrievePositionLevelandApplicantCount(self):
        job_text = self.soup.find("div", class_ = "pr2").text.strip()
        if "level" in job_text:
            self.position_level_TOP = re.search(r" (.+ level)", job_text)
            self.position_level_TOP = self.position_level_TOP.group(1)
        else:
            self.position_level_TOP = ""

        if "applicant" in job_text:
            self.applicant_count = re.search(r" (\d+) applicants?", job_text)
            self.applicant_count = self.applicant_count.group(1)
        else:
            self.applicant_count = -1


    def retrievePositionLevelBOTTOM(self):
        try:
            seniority_level = self.soup.find("div", {"class":"jobs-description-details"}).p.text
        except:
            seniority_level = ""
        self.position_level_BOTTOM = seniority_level


    def retrieveCompanySectorandJobFunctionBOTTOM(self):
        dict_job_details = {}
        information_order = ["industry","job_function"]
        job_description_details = self.soup.find("div", {"class":"jobs-description-details"}).findAll("ul")

        for job_description_detail, io in zip(job_description_details , information_order):
            initial_text = ""
            for part_information in job_description_detail.findAll("li"):
                initial_text += "\n" + part_information.text
            dict_job_details[io] = initial_text.strip()

        try:
            self.company_sector_BOTTOM = dict_job_details["industry"]
            self.job_function = dict_job_details["job_function"]
            if "time" in dict_job_details["job_function"].lower():
                self.job_function = ""
        except:
            self.company_sector_BOTTOM = ""
            self.job_function = ""

    
    def retrieveSalary(self):
        salary_types = ["base_salary", "total_compensation"]
        dict_salary_holder = {}

        salary_holder = self.soup.findAll("div", class_="salary-main-rail__data-container")
        for salary, salary_type in zip(salary_holder, salary_types):
            dict_salary_holder[salary_type] = salary.find("p").text.strip()

        pattern_to_replace = re.compile("[£,/yr]")

        try:
            for salary_type in salary_types:
                dict_salary_holder[salary_type] = int(re.sub(pattern_to_replace, "", dict_salary_holder[salary_type]))
        except:
            dict_salary_holder["base_salary"] = ""
            dict_salary_holder["total_compensation"] = ""
            
        self.base_salary = dict_salary_holder["base_salary"]
        self.total_compensation = dict_salary_holder["total_compensation"]


# *************************************************************************************************************


    def retrieveInformationRightSubWindow(self):
        self.scrollDowninRightSubWindow()
        self.passHTMLContenttoBeautifulSoup()

        self.retrieveCompanySectorandJobFunctionBOTTOM()
        self.retrievePositionLevelBOTTOM()
        self.retrieveCompanySizeandCompanySectorTOP()
        self.retrievePositionLevelandApplicantCount()
        self.retrieveSalary()


    def retrieveInformationLeftSubWindow(self, job_ad):
        self.retrieveCompanyName(job_ad)
        self.retrieveJobTitle(job_ad)
        self.retrieveJobAdID(job_ad)
        self.retrieveJobLocation()
        self.retrieveJobHREF(job_ad)
        self.retrieveJobPostDate(job_ad)
        self.calculateDaysSincePosted()

        self.clickJobAd()


    def initialiseCrawler(self):
        last_page = self.retrieveFinalPageNumber()
        i = 1
        for page in range(0, int(last_page)-1):
            url = "https://www.linkedin.com/jobs/search/?alertAction=viewjobs&f_T=25190&geoId=101165590&keywords=junior%20data%20scientist&location=United%20Kingdom&start={}".format(page*25)
            self.driver.get(url)

            try:      self.hideChatBox()
            except:   pass

            self.scrollDowninLeftSubWindow()

            try:      self.closeFeedbackWindow()
            except:   pass

            self.passHTMLContenttoBeautifulSoup()

            self.dict_html_content[i] = self.driver.page_source
            i +=1

            self.lst_job_ads = self.soup.find("ul", "jobs-search-results__list artdeco-list").find_all("li", class_ = "p0")
            for job_ad in self.lst_job_ads:

                try:
                    self.retrieveInformationLeftSubWindow(job_ad)
                except Exception as error1:
                    self.company_name = "-"
                    self.job_title = "-"
                    self.job_location = "-"
                    self.job_post_date = "-"
                    self.days_since_posted = "-"
                    self.job_href = error1

                try:
                    self.retrieveInformationRightSubWindow()
                except Exception as error2:
                    self.company_sector_BOTTOM = "-"
                    self.job_function = "-"
                    self.position_level_BOTTOM = error2
                    self.company_size = "-"
                    self.company_sector_TOP = "-"
                    self.position_level_TOP = "-"
                    self.applicant_count = "-"
                    self.base_salary = "-"
                    self.total_compensation = "-"

                data_to_add = {'company_name': self.company_name,
                               'company_size': self.company_size,
                                'company_sector_TOP': self.company_sector_TOP,
                                'company_sector_BOTTOM': self.company_sector_BOTTOM,
                                'job_title': self.job_title,
                                'position_level_TOP': self.position_level_TOP,
                                'position_level_BOTTOM': self.position_level_BOTTOM,
                                'job_function': self.job_function,
                                'applicant_count' : self.applicant_count,
                                'job_location': self.job_location,
                                'job_post_date': self.job_post_date,
                                'days_since_posted': self.days_since_posted,
                                'base_salary': self.base_salary,
                                'total_compensation': self.total_compensation,
                                'job_href': self.job_href}

                self.df = self.df.append(data_to_add,
                                         ignore_index=True)


                self.displayInformation(data_to_add)

                time.sleep(np.random.normal(loc=0.6, scale=0.1))
1000/6: scrape = ScrapeJobsPage()
1000/7: login.SignIn()
1000/8: navigate.clickJobs()
1000/9: navigate.clickUKJuniorDataScientist()
1000/10: scrape.initialiseCrawler()
1000/11: scrape.df.to_csv("jobs_scraped.csv")
1001/1: dict_of_elements
1001/2:
def make_hashes(height):
    for i in range(1, height):
        number_of_spaces = " " * (height - i)
        number_of_hashes_left = "#" * i
        
        middle_space = " " * 2
        number_of_hashes_right = "#" * i
        
        print(number_of_spaces + number_of_hashes_left + middle_space + number_of_hashes_right)
1001/3: make_hashes
1001/4: make_hashes(5)
1001/5: make_hashes(20)
1002/1: import numpy as np
1002/2:
class Cards(object):
  
    def __init__(self,suit,rank,value):
        self.suit = suit
        self.rank = rank
        self.value = value
1002/3:
class Dealer(object):
    
    def __init__(self):
        self.dcards = []

class Player(object):
    
    def __init__(self,money):
        self.money = money
        self.bet = None
        self.pcards = []
        
    def check_bet_amount(self):
        if self.bet <= self.money:
            bet_control = True
        else:
            print("\nPlease bet less than what you currently have: %s\n" % self.money)
            bet_control = False
    
        return bet_control
    
    def win(self):
        self.money +=self.bet*2
        
    def lose(self):
        self.money -= self.bet*2
        
    def draw(self):
        self.money = self.money
1002/4:
class Deck(Cards, Dealer, Player):
 
    def __init__(self):
        suits = ['Hearts', 'Diamonds', 'Spades', 'Clubs']
        ranks = ['Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace']
        values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8, 'Nine':9, 'Ten':10, 'Jack':10,
                  'Queen':10, 'King':10, 'Ace':11}
        
        self.deck = []
        for suit in suits:
            for rank in ranks:
                self.deck.append(Cards(suit,rank,values[rank]))
                
    def shuffle_cards(self):
        np.random.shuffle(self.deck)
        
    def deal_cards(self):
        self.shuffle_cards()
        self.pcards = []
        self.dcards = []
        
        cards = 0
        while cards < 2:
            self.pcards.append(self.deck.pop(0))
            self.dcards.append(self.deck.pop(0))
            cards += 1
1002/5:
class BlackJack(Deck):
    
    def __init__(self):
        Dealer.__init__(self)
        Player.__init__(self, 500)
        Deck.__init__(self)
        
    def get_dealer_and_player_card(self):
                
        dealer_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["dcards"])]

        player_cards = [str(no+1) + "- " + vars(element)["rank"] + " of " +
                        vars(element)["suit"] for no, element in enumerate(self.__dict__["pcards"])]
        
        return dealer_cards, player_cards
               
    def get_total_value(self):
        
        total_value_player = [vars(element)["value"] for element in self.__dict__["pcards"]]
        total_value_dealer = [vars(element)["value"] for element in self.__dict__["dcards"]]
        return sum(total_value_player), sum(total_value_dealer)
    
    def get_bet(self):
        bet_control = False

        while bet_control is False:
            bet = input("\nHow much are you betting? - ")
            try:
                bet = int(bet)
                if bet > 0:
                    self.bet = bet
                    bet_control = self.check_bet_amount()
                else:
                    print(type(bet),bet)
                    print("\nPlease provide a positive value!\n")
            except ValueError:
                print("\nPlease provide a valid value!\n")
    
    def show_partial(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            if card == dealer_cards[0]:
                print(card)
            else:
                print(str(no+1) + "  <Card hidden>")
        
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def show_all(self):
        
        dealer_cards, player_cards = self.get_dealer_and_player_card()
        total_value_player, total_value_dealer = self.get_total_value()
        
        print("============================================================\n"+
              "\n------------------\n| Dealer's Cards |\n------------------")
        for no, card in enumerate(dealer_cards):
            print(card)
            if dealer_cards[-1] == card:
                print("<Total points: {}>".format(total_value_dealer))
                
        print("\n------------------\n| Player's Cards |\n------------------")
        for card in player_cards:
            print(card)
            if player_cards[-1] == card:
                print("<Total points: {}>".format(total_value_player))
                
    def hit_or_stand(self):
        hit_control = False
        player_hit = False
        
        while hit_control is False:
            hit_check = input("\nDo you wish to hit? Please enter 'Y' or 'N' - ").lower()
            if hit_check == "y":
                self.pcards.append(self.deck.pop(0))
                player_hit = True
                hit_control = True
            elif hit_check == "n":
                player_hit = False
                hit_control = True
            else:
                print("\nPlease provide a valid value!\n")
                
        self.check_if_ace_in_hand()

        if player_hit is True:
            self.dcards.append(self.deck.pop(0))
            
        return player_hit
    
    def check_if_ace_in_hand(self):
        
        player_cards = [vars(elements) for elements in self.__dict__["pcards"]]
        card_values = [card.values() for card in player_cards]
        ace_mask = ["Ace" in dict_values for dict_values in card_values]
        
        total_value_player, total_value_dealer = self.get_total_value()

        if any(ace_mask) and total_value_player > 21:
            print("\n>>>>>>>>Player's points exceed 21 - Ace counts as 1 point!!")
            card_no_ace = ace_mask.index(True)
            self.pcards[card_no_ace].value = 1
                
    def run_rules(self,player_hit):
        
        total_value_player, total_value_dealer = self.get_total_value()
        
        game_win = None
        continue_check = None
        if total_value_player > 21 or\
           total_value_dealer > 21 or\
           total_value_player == 21 or\
           total_value_dealer == 21:
            
            print("\n============================================================")
            if total_value_player > 21 and total_value_dealer > 21:
                print("Tie!")
            elif total_value_player > 21:
                game_win = False
                print("Dealer wins! Player goes bust!")
            elif total_value_dealer > 21:
                game_win = True
                print("Player wins! Dealer goes bust!")
            elif total_value_player == 21:
                if total_value_dealer == 21:
                    print("Tie!")
                else:
                    game_win = True
                    print("Player wins!")
            elif total_value_dealer == 21:
                if total_value_player == 21:
                    print("Tie!")
                else:
                    game_win = False
                    print("Dealer wins!")
            
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is False:
            
            print("\n============================================================")
            if total_value_player > total_value_dealer:
                game_win = True
                print("Player wins!")
            elif total_value_player < total_value_dealer:
                game_win = False
                print("Dealer wins!")
            elif total_value_player == total_value_dealer:
                print("Tie!")
                
            self.show_all()
            self.check_result(game_win)
            
        elif total_value_player < 21 and total_value_dealer < 21 and player_hit is True:
            continue_check = False
            self.show_partial()
            
        return game_win
    
    def check_result(self, game_win):
        
        if game_win:
            self.win()
        elif game_win is False:
            self.lose()
        else:
            self.draw()
            
        print("\nYour current outstanding stands at: %s \n" % self.money)
1002/6:
def start_game():
    continue_playing = True
    player = BlackJack()
    
    while continue_playing is True:
        player.deal_cards()
        player.show_partial()
        player.check_if_ace_in_hand()
        player.get_bet()

        player_hit = None
        game_win = player.run_rules(player_hit)
        total_value_player, total_value_dealer = player.get_total_value()

        while total_value_player < 21 and total_value_dealer < 21:
            player_hit = player.hit_or_stand()
            total_value_player, total_value_dealer = player.get_total_value()
            if player_hit is False:
                game_win = player.run_rules(player_hit)
                break
            else:
                game_win = player.run_rules(player_hit)

        continue_playing_control = False
        while continue_playing_control is False:
            continue_playing = input("Would you like to continue playing? Please enter 'Y' or 'N' -").lower()
            if continue_playing == 'y' or continue_playing == 'n':
                continue_playing_control = True
                if continue_playing == 'y':
                    continue_playing = True
                else:
                    continue_playing = False
            else:
                print("Please either provide 'y' or 'n'")

    #print("\nGame win= %s\n" % game_win)
    return player
1002/7: player = start_game()
1003/1: random.random
1003/2: import random
1003/3: random.random
1003/4: random.random()
1003/5: random.randint()
1003/6: random.randint(0,4)
1003/7: random.randint(0,4)
1003/8: random.randint(0,4)
1003/9: random.randint(0,4)
1003/10: random.randint(0,4)
1003/11: random.randint(0,4)
1003/12: random.randint(0,4)
1003/13: random.randint(0,4)
1003/14: random.randint(0,4)
1003/15: random.randint(0,4)
1003/16: random.randint(0,4)
1003/17: random.randint(0,4)
1003/18: random.randint(0,4)
1003/19: random.randint(0,4)
1003/20: random.randint(0,4)
1003/21: random.randint(0,4)
1003/22: random.randint(0,4)
1003/23: random.randint(0,4)
1003/24: random.randint(0,4)
1003/25: random.randint(0,4)
1003/26: random.randint(0,4)
1003/27: random.randint(0,4)
1003/28: random.randint(0,4)
1003/29: random.randint(0,4)
1003/30: random.randint(0,4)
1003/31: random.randint(0,4)
1003/32: random.randint(0,4)
1003/33: random.randint(0,4)
1003/34: random.randint(0,4)
1003/35: random.randint(0,4)
1003/36: random.randint(0,4)
1003/37: random.randint(0,4)
1003/38: random.randint(0,4)
1003/39: random.randint(0,4)
1003/40: random.randint(0,4)
1003/41: random.randint(0,4)
1003/42: random.randint(0,4)
1003/43: random.randint(0,4)
1003/44: random.randint(0,4)
1003/45: random.randint(0,4)
1003/46: random.randint(0,4)
1003/47: candidates = ["Alice", "Bob", "Charlie", "David"]
1003/48: import random
1003/49: random.randint(0,4)
1003/50: candidates.shuffle
1003/51: shuffle(candidates)
1003/52: import numpy as np
1003/53: np.random.uniform(1,4)
1003/54: np.random.uniform(0,4)
1003/55: np.random.uniform(0,4)
1003/56: np.random.uniform(0,4)
1003/57: np.random.uniform(0,4)
1003/58: np.random.uniform(0,4)
1003/59: np.random.uniform(0,4)
1003/60: np.random.uniform(0,4)
1003/61: np.random.uniform(0,4)
1003/62: np.random.uniform(0,4)
1003/63: np.random.uniform(0,4)
1003/64: np.random.uniform(0,4)
1003/65: np.random.uniform(0,4)
1003/66: np.random.uniform(0,4)
1003/67: np.random.uniform(0,4)
1003/68: np.random.uniform(0,4)
1003/69: np.random.uniform(0,4)
1003/70: int(np.random.uniform(0,4))
1003/71: int(np.random.uniform(0,4))
1003/72: int(np.random.uniform(0,4))
1003/73: int(np.random.uniform(0,4))
1003/74: int(np.random.uniform(0,4))
1003/75: int(np.random.uniform(0,4))
1003/76: int(np.random.uniform(0,4))
1003/77: int(np.random.uniform(0,4))
1003/78: int(np.random.uniform(0,4))
1003/79: int(np.random.uniform(0,4))
1003/80: int(np.random.uniform(0,4))
1003/81: int(np.random.uniform(0,4))
1003/82: int(np.random.uniform(0,4))
1003/83: int(np.random.uniform(0,4))
1003/84: int(np.random.uniform(0,4))
1003/85: int(np.random.uniform(0,4))
1003/86: int(np.random.uniform(0,4))
1003/87: int(np.random.uniform(0,4))
1003/88: int(np.random.uniform(0,4))
1003/89: int(np.random.uniform(0,4))
1003/90: int(np.random.uniform(0,4))
1003/91: int(np.random.uniform(0,4))
1003/92: int(np.random.uniform(0,4))
1003/93: int(np.random.uniform(0,4))
1003/94: int(np.random.uniform(0,4))
1003/95: int(np.random.uniform(0,4))
1003/96: int(np.random.uniform(0,4))
1003/97: int(np.random.uniform(0,4))
1003/98: int(np.random.uniform(0,4))
1003/99:
import random

foo = ['a', 'b', 'c', 'd', 'e']
print(random.choice(foo))
1003/100:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/101:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/102:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/103:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/104:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/105:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/106:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/107:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/108:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/109:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/110:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/111:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/112:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/113:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/114:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/115:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/116:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/117:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/118:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/119:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/120:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/121:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/122:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/123:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/124:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/125:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/126:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/127:
import secrets

foo = ['battery', 'correct', 'horse', 'staple']
print(secrets.choice(foo))
1003/128: foo
1003/129: test = [1,2,3]
1003/130:
import secrets
ballots = 5;
votes = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in len(candidates):
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/131:
import secrets
ballots = 5;
votes = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in candidates:
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/132: votes
1003/133:
import secrets
ballots = 5;
votes = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in candidates:
        print(candidates)
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/134: test = ["a","b","c"]
1003/135: test.remove("b")
1003/136: test
1003/137:
import secrets
ballots = 5
candidate_count = 4
votes = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in range(candidate_count):
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/138: votes
1003/139:
for vote in votes:
    text_file = open("votes.txt", "w")
    text_file.write(vote)
    text_file.close()
1003/140:
for vote in votes:
    text_file = open("C:\Users\Cagri\Google Drive\votes.txt", "w")
    text_file.write(vote)
    text_file.close()
1003/141:
for vote in votes:
    text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")
    text_file.write(vote)
    text_file.close()
1003/142: candidates = ["Alice", "Bob", "Charlie", "David"]
1003/143:
text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")

for vote in votes:
    text_file.write(vote)
    
text_file.close()
1003/144:
text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")

for vote in votes:
    text_file.write(vote + "\n")
    
text_file.close()
1003/145: candidates.index("David")
1003/146:
import secrets
ballots = 10
candidate_count = 4
votes = []
preferences = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in range(candidate_count):
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/147: votes
1003/148:
text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")

for vote in votes:
    text_file.write(vote + "\n")
    
text_file.close()
1003/149:
text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")

for vote in votes:
    text_file.write(vote + "\n")
    
text_file.close()
1003/150:
import secrets
ballots = 10
candidate_count = 4
votes = []
preferences = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in range(candidate_count):
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/151: votes
1003/152:
text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")

for vote in votes:
    text_file.write(vote + "\n")
    
text_file.close()
1003/153:
import secrets
ballots = 10
candidate_count = 4
votes = []
preferences = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in range(candidate_count):
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/154: votes
1003/155:
text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")

for vote in votes:
    text_file.write(vote + "\n")
    
text_file.close()
1003/156:
import secrets
ballots = 10
candidate_count = 4
votes = []
preferences = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in range(candidate_count):
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/157: votes
1003/158:
text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")

for vote in votes:
    text_file.write(vote + "\n")
    
text_file.close()
1003/159:
import secrets
ballots = 10
candidate_count = 4
votes = []
preferences = []


for ballot in range(ballots):
    candidates = ["Alice", "Bob", "Charlie", "David"]
    for _ in range(candidate_count):
        selection = secrets.choice(candidates)
        votes.append(selection)
        candidates.remove(selection)
1003/160: votes
1003/161:
text_file = open(r"C:\Users\Cagri\Google Drive\votes.txt", "w")

for vote in votes:
    text_file.write(vote + "\n")
    
text_file.close()
1007/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1007/2: c
1007/3:
# Create table - CLIENTS
sql_commad = '''
CREATE TABLE CLIENTS
([generated_id] INTEGER PRIMARY KEY,[Client_Name] text, [Country_ID] integer, [Date] date)
'''

sql_commad = sql_commad.replace("\n", "");
1007/4:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE mov
(id TEXT,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
1007/5: sql_command
1007/6:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE mov
(id TEXT,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
c.execute(sql_command)
1007/7:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE mov
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
c.execute(sql_command)
1008/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1008/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE mov
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
c.execute(sql_command)
1008/3:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE mov
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except OperationalError:
    print("Table already exists!")
1008/4:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE mov
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1008/5:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1008/6:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE mov
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1009/1: import csv
1009/2:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1009/3:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE mov
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1009/4: import csv
1009/5:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1009/6:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1009/7:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1010/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1010/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1010/3:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1010/4:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimeter="\t")
1010/5: import csv
1010/6:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimeter="\t")
1010/7:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimeter="|")
1010/8:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimeter="|")
1010/9:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimeter="\t")
1010/10:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
1010/11: reader
1010/12:
for index, row in enumerate(reader):
    print(row)
    if index == 0:
        break
1010/13:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
1010/14:
for index, row in enumerate(reader):
    print(row)
    if index == 0:
        break
1010/15: reader
1010/16:
for row in reader:
    print(row)
    breal
1010/17:
for row in reader:
    print(row)
    break
1010/18:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
1010/19:
for row in reader:
    print(row)
    break
1010/20: reader
1010/21:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
    
    for row in reader:
        print(row)
        break
1010/22: import pandas as pd
1010/23: pd.read_csv("data.tsv", delimiter="\t")
1011/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1011/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1011/3: import csv
1011/4:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
    
    for row in reader:
        print(row)
        break
1012/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1012/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1012/3: import csv
1012/4:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
    
    for row in reader:
        print(row)
        break
1012/5: reader
1012/6: import pandas as pd
1012/7: df = pd.read_csv("data.tsv", delimiter="\t")
1012/8: df
1013/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1013/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1013/3: import csv
1013/4:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
    
    for row in reader:
        print(row)
        break
1014/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1014/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1014/3: import csv
1014/4:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
    
    for row in reader:
        print(row)
        break
1014/5: import pandas as pd
1014/6: df = pd.read_csv("data.tsv", delimiter="\t")
1014/7: df
1015/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1015/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1015/3: import csv
1015/4:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
    
    for row in reader:
        print(row)
        break
1015/5:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
    
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries":
            continue
            
        if row["startYear"] > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1015/6:
with open("data.tsv", "r") as titles:
    reader = csv.DictReader(titles, delimiter="\t", encoding="utf8")
    
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries":
            continue
            
        if row["startYear"] > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1015/7:
with open(data.tsv, mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries":
            continue
            
        if row["startYear"] > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1015/8:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries":
            continue
            
        if row["startYear"] > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1015/9:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1015/10:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1015/11:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        print(row)
        break
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row[""], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1015/12:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1015/13:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1015/14: import csv
1015/15:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        print(row)
        break
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row[""], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1015/16:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1016/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1016/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1016/3: import csv
1016/4:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, start_year) VALUES (?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1016/5:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1016/6:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1016/7:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1016/8: import csv
1016/9:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1016/10:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, genre, start_year) VALUES (?, ?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1017/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1017/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except:
    print("Table already exists!")
1017/3: import csv
1017/4:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1017/5: shows
1017/6:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1017/7:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1017/8:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1017/9: import csv
1017/10:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1018/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1018/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1018/3: import csv
1018/4:
with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
    reader = csv.DictReader(titles, delimiter="\t")
        
    for row in reader:
        if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
            continue
            
        if int(row["startYear"]) > 1970:
            sql_command = """
            INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
            """.replace("\n", "")
            c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
            conn.commit()

c.close()
conn.close()
1018/5:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print 'func:%r args:[%r, %r] took: %2.4f sec' % \
          (f.__name__, args, kw, te-ts)
        return result
    return wrap
1018/6:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('func:%r args:[%r, %r] took: %2.4f sec' % \
          (f.__name__, args, kw, te-ts))
        return result
    return wrap
1019/1:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1019/2:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1019/3: import csv
1019/4:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('func:%r args:[%r, %r] took: %2.4f sec' % \
          (f.__name__, args, kw, te-ts))
        return result
    return wrap
1019/5:
@timing
def create_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        for row in reader:
            if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
                continue

            if int(row["startYear"]) > 1970:
                sql_command = """
                INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
                """.replace("\n", "")
                c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
                conn.commit()
1019/6:
create_database()
c.close()
conn.close()
1019/7: 1122/60
1019/8:
@timing
def select_from_database():
    sql_command = """
    SELECT 
        id, title, genres, start_year
    FROM 
        shows
    WHERE
        (
            (isAdult = 0 AND titleType != "tvSeries" AND startYear != "\\N" AND startYear > 1970)
        )
    """.replace("\n", "")
    c.execute(sql_command)
    for row in c.fetchone():
        print(row)
1019/9: select_from_database()
1019/10:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1019/11:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1019/12: import csv
1019/13:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('func:%r args:[%r, %r] took: %2.4f sec' % \
          (f.__name__, args, kw, te-ts))
        return result
    return wrap
1019/14:
@timing
def select_from_database():
    sql_command = """
    SELECT 
        id, title, genres, start_year
    FROM 
        shows
    WHERE
        (
            (isAdult = 0 AND titleType != "tvSeries" AND startYear != "\\N" AND startYear > 1970)
        )
    """.replace("\n", "")
    c.execute(sql_command)
    for row in c.fetchone():
        print(row)
1019/15: # create_database()
1019/16: select_from_database()
1019/17:
@timing
def create_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        for row in reader:
            print(row)
            break
            if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
                continue

            if int(row["startYear"]) > 1970:
                sql_command = """
                INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
                """.replace("\n", "")
                c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
                conn.commit()
                
    c.close()
    conn.close()
1019/18: create_database()
1019/19: c
1019/20:
@timing
def select_from_database():
    sql_command = """
    SELECT 
        id, title, genres, start_year
    FROM 
        shows
    WHERE
        (
            (isAdult = "0" AND titleType != "tvSeries" AND startYear != "\\N" AND startYear > 1970)
        )
    """.replace("\n", "")
    c.execute(sql_command)
    for row in c.fetchone():
        print(row)
1019/21: create_database()
1019/22: select_from_database()
1019/23:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1019/24:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1019/25: import csv
1019/26:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('func:%r args:[%r, %r] took: %2.4f sec' % \
          (f.__name__, args, kw, te-ts))
        return result
    return wrap
1019/27:
@timing
def select_from_database():
    sql_command = """
    SELECT 
        id, title, genres, start_year
    FROM 
        shows
    WHERE
        (
            (isAdult = "0" AND titleType != "tvSeries" AND startYear != "\\N" AND startYear > 1970)
        )
    """.replace("\n", "")
    c.execute(sql_command)
    for row in c.fetchone():
        print(row)
1019/28: select_from_database()
1019/29:
@timing
def select_from_database():
    sql_command = """
    SELECT 
        id, title, genres, start_year
    FROM 
        shows
    WHERE
        (
            (start_year > 2018 and start_year < 2020)
        )
    """.replace("\n", "")
    c.execute(sql_command)
    for row in c.fetchone():
        print(row)
1019/30: create_database()
1019/31: select_from_database()
1019/32:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1019/33:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1019/34: import csv
1019/35:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('func:%r args:[%r, %r] took: %2.4f sec' % \
          (f.__name__, args, kw, te-ts))
        return result
    return wrap
1019/36:
@timing
def create_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        for row in reader:
            print(row)
            break
            if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
                continue

            if int(row["startYear"]) > 1970:
                sql_command = """
                INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
                """.replace("\n", "")
                c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
                conn.commit()
                
    c.close()
    conn.close()
1019/37:
@timing
def select_from_database():
    sql_command = """
    SELECT 
        id, title, genres, start_year
    FROM 
        shows
    WHERE
        (
            (start_year > 2018 and start_year < 2020)
        )
    """.replace("\n", "")
    c.execute(sql_command)
    for row in c.fetchone():
        print(row)
        
    c.close()
    conn.close()
1019/38: select_from_database()
1019/39:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('took: %2.4f sec' % \
          (te-ts))
        return result
    return wrap
1019/40:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1019/41: import csv
1019/42:
import sqlite3

conn = sqlite3.connect("test.db")
c = conn.cursor()
1019/43:
# Create table - CLIENTS
sql_command = '''
CREATE TABLE shows
(id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
'''

sql_command = sql_command.replace("\n", "");
try:
    c.execute(sql_command)
except conn.OperationalError:
    print("Table already exists!")
1019/44: import csv
1019/45:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('took: %2.4f sec' % \
          (te-ts))
        return result
    return wrap
1019/46:
@timing
def create_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        for row in reader:
            print(row)
            break
            if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
                continue

            if int(row["startYear"]) > 1970:
                sql_command = """
                INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
                """.replace("\n", "")
                c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
                conn.commit()
                
    c.close()
    conn.close()
1019/47:
@timing
def select_from_database():
    sql_command = """
    SELECT 
        id, title, genres, start_year
    FROM 
        shows
    WHERE
        (
            (start_year > 2018 and start_year < 2020)
        )
    """.replace("\n", "")
    c.execute(sql_command)
    for row in c.fetchone():
        print(row)
        
    c.close()
    conn.close()
1019/48: select_from_database()
1019/49:
import sqlite3

conn = sqlite3.connect("data.db")
c = conn.cursor()
1019/50: import csv
1019/51:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('took: %2.4f sec' % \
          (te-ts))
        return result
    return wrap
1019/52:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (
    tconst TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT,
    )
    '''.replace("\n", "")
    
    c.execute(sql_command)
1019/53: create_data_db_file()
1019/54:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (tconst TEXT PRIMARY KEY,title TEXT,p_title TEXT,o_title TEXT,is_adult TEXT,start_year NUMERIC,end_year NUMERC,run_time_minutes NUMERIC,genres TEXT,)
    '''.replace("\n", "")
    
    c.execute(sql_command)
1019/55: create_data_db_file()
1020/1:
import sqlite3

conn = sqlite3.connect("data.db")
c = conn.cursor()
1020/2: import csv
1020/3:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('took: %2.4f sec' % \
          (te-ts))
        return result
    return wrap
1020/4:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (
    tconst TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT,
    )
    '''.replace("\n", "")
    
    c.execute(sql_command)
1020/5: create_data_db_file()
1020/6:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (tconst TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT)
    '''.replace("\n", "")
    
    c.execute(sql_command)
1020/7: create_data_db_file()
1020/8:
def create_full_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        sql_command = """
        INSERT INTO shows 
        (id,
        title,
        p_title,
        o_title,
        is_adult,
        start_year,
        end_year,
        run_time_minutes,
        genres
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """.replace("\n", "")

        for row in reader:
            id_ = row["tconst"]
            title = row["titleType"]
            p_title = row["primaryTitle"]
            o_title = row["originalTitle"]
            is_adult = row["isAdult"]
            start_year = row["startYear"]
            end_year = row["endYear"]
            run_time_minutes = row["runtimeMinutes"]
            genres = row["genres"]

            c.execute(sql_command,
                      (id_[2:],
                       title,
                       p_title,
                       o_title,
                       is_adult,
                       start_year,
                       end_year,
                       run_time_minutes,
                       genres))
            break
            
    c.close()
    conn.close()
1020/9: create_full_database()
1020/10:
def create_full_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        sql_command = """
        INSERT INTO data 
        (id,
        title,
        p_title,
        o_title,
        is_adult,
        start_year,
        end_year,
        run_time_minutes,
        genres
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """.replace("\n", "")

        for row in reader:
            id_ = row["tconst"]
            title = row["titleType"]
            p_title = row["primaryTitle"]
            o_title = row["originalTitle"]
            is_adult = row["isAdult"]
            start_year = row["startYear"]
            end_year = row["endYear"]
            run_time_minutes = row["runtimeMinutes"]
            genres = row["genres"]

            c.execute(sql_command,
                      (id_[2:],
                       title,
                       p_title,
                       o_title,
                       is_adult,
                       start_year,
                       end_year,
                       run_time_minutes,
                       genres))
            break
            
    c.close()
    conn.close()
1020/11: create_full_database()
1021/1:
import sqlite3

conn = sqlite3.connect("data.db")
c = conn.cursor()
1021/2: import csv
1021/3:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('took: %2.4f sec' % \
          (te-ts))
        return result
    return wrap
1021/4:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (id TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT)
    '''.replace("\n", "")
    
    c.execute(sql_command)
1021/5: create_data_db_file()
1021/6:
def create_full_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        sql_command = """
        INSERT INTO data 
        (id,
        title,
        p_title,
        o_title,
        is_adult,
        start_year,
        end_year,
        run_time_minutes,
        genres
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """.replace("\n", "")

        for row in reader:
            id_ = row["tconst"]
            title = row["titleType"]
            p_title = row["primaryTitle"]
            o_title = row["originalTitle"]
            is_adult = row["isAdult"]
            start_year = row["startYear"]
            end_year = row["endYear"]
            run_time_minutes = row["runtimeMinutes"]
            genres = row["genres"]

            c.execute(sql_command,
                      (id_[2:],
                       title,
                       p_title,
                       o_title,
                       is_adult,
                       start_year,
                       end_year,
                       run_time_minutes,
                       genres))
            break
            
    c.close()
    conn.close()
1021/7: create_full_database()
1022/1:
import sqlite3

conn = sqlite3.connect("data.db")
c = conn.cursor()
1022/2:
# Create table - CLIENTS
# sql_command = '''
# CREATE TABLE shows
# (id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
# '''

# sql_command = sql_command.replace("\n", "");
# try:
#     c.execute(sql_command)
# except conn.OperationalError:
#     print("Table already exists!")
1022/3: import csv
1022/4:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('took: %2.4f sec' % \
          (te-ts))
        return result
    return wrap
1022/5:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (id TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT)
    '''.replace("\n", "")
    
    c.execute(sql_command)
1022/6: create_data_db_file()
1022/7:
# @timing
# def create_database():
#     with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
#         reader = csv.DictReader(titles, delimiter="\t")

#         for row in reader:
#             print(row)
#             break
#             if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
#                 continue

#             if int(row["startYear"]) > 1970:
#                 sql_command = """
#                 INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
#                 """.replace("\n", "")
#                 c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
#                 conn.commit()
                
#     c.close()
#     conn.close()
1022/8:
def create_full_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        sql_command = """
        INSERT INTO data 
        (id,
        title,
        p_title,
        o_title,
        is_adult,
        start_year,
        end_year,
        run_time_minutes,
        genres
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """.replace("\n", "")

        for row in reader:
            id_ = row["tconst"]
            title = row["titleType"]
            p_title = row["primaryTitle"]
            o_title = row["originalTitle"]
            is_adult = row["isAdult"]
            start_year = row["startYear"]
            end_year = row["endYear"]
            run_time_minutes = row["runtimeMinutes"]
            genres = row["genres"]

            c.execute(sql_command,
                      (id_[2:],
                       title,
                       p_title,
                       o_title,
                       is_adult,
                       start_year,
                       end_year,
                       run_time_minutes,
                       genres))
            conn.commit()
            break
            
            
    c.close()
    conn.close()
1022/9: create_full_database()
1022/10:
import sqlite3

conn = sqlite3.connect("data.db")
c = conn.cursor()
1022/11:
# Create table - CLIENTS
# sql_command = '''
# CREATE TABLE shows
# (id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
# '''

# sql_command = sql_command.replace("\n", "");
# try:
#     c.execute(sql_command)
# except conn.OperationalError:
#     print("Table already exists!")
1022/12: import csv
1022/13:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('took: %2.4f sec' % \
          (te-ts))
        return result
    return wrap
1022/14:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (id TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT)
    '''.replace("\n", "")
    
    c.execute(sql_command)
1022/15: create_data_db_file()
1022/16:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (id TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT)
    '''.replace("\n", "")
    try:
        c.execute(sql_command)
    except conn.
1022/17:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (id TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT)
    '''.replace("\n", "")
    try:
        c.execute(sql_command)
    except conn.OperationalError:
        print("Table already exists")
1022/18: create_data_db_file()
1022/19:
# @timing
# def create_database():
#     with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
#         reader = csv.DictReader(titles, delimiter="\t")

#         for row in reader:
#             print(row)
#             break
#             if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
#                 continue

#             if int(row["startYear"]) > 1970:
#                 sql_command = """
#                 INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
#                 """.replace("\n", "")
#                 c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
#                 conn.commit()
                
#     c.close()
#     conn.close()
1022/20:
def create_full_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        sql_command = """
        INSERT INTO data 
        (id,
        title,
        p_title,
        o_title,
        is_adult,
        start_year,
        end_year,
        run_time_minutes,
        genres
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """.replace("\n", "")

        for row in reader:
            id_ = row["tconst"]
            title = row["titleType"]
            p_title = row["primaryTitle"]
            o_title = row["originalTitle"]
            is_adult = row["isAdult"]
            start_year = row["startYear"]
            end_year = row["endYear"]
            run_time_minutes = row["runtimeMinutes"]
            genres = row["genres"]

            c.execute(sql_command,
                      (id_[2:],
                       title,
                       p_title,
                       o_title,
                       is_adult,
                       start_year,
                       end_year,
                       run_time_minutes,
                       genres))
            conn.commit()
            
            
    c.close()
    conn.close()
1022/21: create_full_database()
1023/1:
import sqlite3

conn = sqlite3.connect("data.db")
c = conn.cursor()
1023/2:
# Create table - CLIENTS
# sql_command = '''
# CREATE TABLE shows
# (id TEXT PRIMARY KEY,title TEXT, genres TEXT, start_year NUMERIC)
# '''

# sql_command = sql_command.replace("\n", "");
# try:
#     c.execute(sql_command)
# except conn.OperationalError:
#     print("Table already exists!")
1023/3: import csv
1023/4:
from functools import wraps
from time import time

def timing(f):
    @wraps(f)
    def wrap(*args, **kw):
        ts = time()
        result = f(*args, **kw)
        te = time()
        print('took: %2.4f sec' % \
          (te-ts))
        return result
    return wrap
1023/5:
@timing
def create_data_db_file():
    sql_command = '''
    CREATE TABLE data
    (id TEXT PRIMARY KEY,
    title TEXT,
    p_title TEXT,
    o_title TEXT,
    is_adult TEXT,
    start_year NUMERIC,
    end_year NUMERC,
    run_time_minutes NUMERIC,
    genres TEXT)
    '''.replace("\n", "")
    try:
        c.execute(sql_command)
    except conn.OperationalError:
        print("Table already exists")
1023/6: create_data_db_file()
1023/7:
# @timing
# def create_database():
#     with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
#         reader = csv.DictReader(titles, delimiter="\t")

#         for row in reader:
#             print(row)
#             break
#             if row["isAdult"] == 1 or row["titleType"] != "tvSeries" or row["startYear"] == "\\N":
#                 continue

#             if int(row["startYear"]) > 1970:
#                 sql_command = """
#                 INSERT INTO shows (id, title, genres, start_year) VALUES (?, ?, ?, ?)
#                 """.replace("\n", "")
#                 c.execute(sql_command, (row["tconst"], row["primaryTitle"], row["genres"], row["startYear"]))
#                 conn.commit()
                
#     c.close()
#     conn.close()
1023/8:
def create_full_database():
    with open("data.tsv", mode="r", encoding="utf-8-sig") as titles:
        reader = csv.DictReader(titles, delimiter="\t")

        sql_command = """
        INSERT INTO data 
        (id,
        title,
        p_title,
        o_title,
        is_adult,
        start_year,
        end_year,
        run_time_minutes,
        genres
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """.replace("\n", "")

        for row in reader:
            id_ = row["tconst"]
            title = row["titleType"]
            p_title = row["primaryTitle"]
            o_title = row["originalTitle"]
            is_adult = row["isAdult"]
            start_year = row["startYear"]
            end_year = row["endYear"]
            run_time_minutes = row["runtimeMinutes"]
            genres = row["genres"]

            c.execute(sql_command,
                      (id_[2:],
                       title,
                       p_title,
                       o_title,
                       is_adult,
                       start_year,
                       end_year,
                       run_time_minutes,
                       genres))
            conn.commit()
            
            
    c.close()
    conn.close()
1023/9: create_full_database()
1026/1:
import sqlite3

conn = sqlite3.connect("data.db")
c = conn.cursor()
1027/1: import sqlite3
1027/2:
db_file = "movies.db"
conn = sqlite3.connect()
1027/3:
db_file = "movies.db"
conn = sqlite3.connect(db_file)
1027/4:
db_file = "movies.db"
conn = sqlite3.connect(db_file)
cur = conn.cursor()
1027/5: rows = cur.fetchall()
1027/6: rows
1027/7:
conn = sqlite3.connect("movies.db")
c = conn.cursor()
1027/8: rows = cur.fetchall()
1027/9: rows
1027/10:
for row in rows:
    print(row)
1027/11: c.execute("SELECT * FROM movies")
1027/12: movies = c.execute("SELECT * FROM movies")
1027/13: movies.fetchone()
1027/14:
directors = c.execute("SELECT * FROM directors")
movies = c.execute("SELECT * FROM movies")
ratings = c.execute("SELECT * FROM ratings")
people = c.execute("SELECT * FROM people")
stars = c.execute("SELECT * FROM stars")
1027/15: movies.fetchmany(10)
1027/16: import sqlite3
1027/17:
conn = sqlite3.connect("movies.db")
c = conn.cursor()
1027/18:
directors = c.execute("SELECT * FROM directors")
movies = c.execute("SELECT * FROM movies")
ratings = c.execute("SELECT * FROM ratings")
people = c.execute("SELECT * FROM people")
stars = c.execute("SELECT * FROM stars")
1027/19: movies.fetchmany(10)
1027/20: movies.fetone(10)
1027/21: movies.fetchone()
1029/1: import sqlite3
1029/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()
1029/3:
directors = c.execute("SELECT * FROM directors")
movies = c.execute("SELECT * FROM movies")
ratings = c.execute("SELECT * FROM ratings")
people = c.execute("SELECT * FROM people")
stars = c.execute("SELECT * FROM stars")
1029/4: movies.fetchmany(10)
1029/5:
directors = c.execute("SELECT * FROM directors;")
movies = c.execute("SELECT * FROM movies;")
ratings = c.execute("SELECT * FROM ratings;")
people = c.execute("SELECT * FROM people;")
stars = c.execute("SELECT * FROM stars;")
1029/6: movies.fetchmany(10)
1029/7:
directors = c.execute("SELECT * FROM directors;")
movies = c.execute("SELECT title FROM movies;")
ratings = c.execute("SELECT * FROM ratings;")
people = c.execute("SELECT * FROM people;")
stars = c.execute("SELECT * FROM stars;")
1029/8: movies.fetchmany(10)
1029/9: movies
1029/10: movies.rowcount
1029/11: movies.fetchone
1029/12: movies.fetchone()
1029/13:
# directors = c.execute("SELECT * FROM directors;")
movies = c.execute("SELECT title FROM movies;")
# ratings = c.execute("SELECT * FROM ratings;")
# people = c.execute("SELECT * FROM people;")
# stars = c.execute("SELECT * FROM stars;")
1029/14: movies.fetchone()
1029/15: import sqlite3
1029/16:
conn = sqlite3.connect("movies.db")
c = conn.cursor()
1029/17:
# directors = c.execute("SELECT * FROM directors;")
movies = c.execute("SELECT * FROM movies;")
# ratings = c.execute("SELECT * FROM ratings;")
# people = c.execute("SELECT * FROM people;")
# stars = c.execute("SELECT * FROM stars;")
1029/18: movies.fetchone()
1029/19:
directors = c.execute("SELECT * FROM directors;")
movies = c.execute("SELECT * FROM movies;")
ratings = c.execute("SELECT * FROM ratings;")
people = c.execute("SELECT * FROM people;")
stars = c.execute("SELECT * FROM stars;")
1029/20: movies.fetchone()
1029/21: stars.fetchone()
1029/22:
def execute_task(cursor, task):
    return cursor.execute(task)
1029/23:
directors = c.execute("SELECT * FROM directors;")
movies = execute_task(c, "SELECT * FROM movies;")
ratings = c.execute("SELECT * FROM ratings;")
people = c.execute("SELECT * FROM people;")
stars = c.execute("SELECT * FROM stars;")
1029/24: movies.fetchone()
1029/25:
def execute_task(connection, task):
    c = connection.cursor()
    return c.execute(task)
1029/26:
directors = c.execute("SELECT * FROM directors;")
movies = execute_task(c, "SELECT * FROM movies;")
ratings = c.execute("SELECT * FROM ratings;")
people = c.execute("SELECT * FROM people;")
stars = c.execute("SELECT * FROM stars;")
1029/27: movies.fetchone()
1029/28:
directors = c.execute("SELECT * FROM directors;")
movies = execute_task(conn, "SELECT * FROM movies;")
ratings = c.execute("SELECT * FROM ratings;")
people = c.execute("SELECT * FROM people;")
stars = c.execute("SELECT * FROM stars;")
1029/29: movies.fetchone()
1029/30: import sqlite3
1029/31: conn = sqlite3.connect("movies.db")
1029/32:
def execute_task(connection = conn, task):
    c = connection.cursor()
    return c.execute(task)
1029/33:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1029/34: import sqlite3
1029/35: conn = sqlite3.connect("movies.db")
1029/36:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1029/37:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1029/38: movies.fetchone()
1029/39: stars.fetchone()
1029/40:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
1029/41:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1029/42:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.f
1029/43:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1029/44:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1029/45:
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1029/46:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1029/47:
# Join here is not necessary.
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchone()
1029/48:
# Join here is not necessary.
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1029/49:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()
1029/50:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0]
1029/51:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1029/52:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchall()
1029/53:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1029/54:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_eight = execute_task(task)
sql_eight.fetchmany(10)
1029/55:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1029/56:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1029/57:
task = """
        SELECT DISTINCT(name) from directors
        LEFT OUTER JOIN people
        ON directors.person_id = people.id
        INNER JOIN stars
        ON directors.person_id = stars.person_id
        LEFT OUTER JOIN ratings
        ON directors.movie_id = ratings.movie_id
        LEFT OUTER JOIN movies
        ON directors.movie_id = movies.id
        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
1030/1: import sqlite3
1030/2:
conn = sqlite3.connect("movies.db")
c = connection.cursor()

c.execute('CREATE INDEX person_index ON stars(person_id);')
c.execute('CREATE INDEX movie_index ON stars(movie_id);')
c.execute('CREATE INDEX name_index ON movies(name);')
1030/3:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

c.execute('CREATE INDEX person_index ON stars(person_id);')
c.execute('CREATE INDEX movie_index ON stars(movie_id);')
c.execute('CREATE INDEX name_index ON movies(name);')
1030/4:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

# c.execute('CREATE INDEX person_index ON stars(person_id);')
# c.execute('CREATE INDEX movie_index ON stars(movie_id);')
# c.execute('CREATE INDEX name_index ON movies(name);')
1030/5:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1030/6:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1030/7:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1031/1: import sqlite3
1031/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

# c.execute('CREATE INDEX person_index ON stars(person_id);')
# c.execute('CREATE INDEX movie_index ON stars(movie_id);')
# c.execute('CREATE INDEX name_index ON movies(name);')
1031/3:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1031/4:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1031/5: import sqlite3
1031/6:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

c.execute('CREATE INDEX person_index ON stars(person_id);')
c.execute('CREATE INDEX movie_index ON stars(movie_id);')
c.execute('CREATE INDEX name_index ON movies(name);')
1031/7:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

c.execute('CREATE INDEX person_index ON stars(person_id);')
c.execute('CREATE INDEX movie_index ON stars(movie_id);')
c.execute('CREATE INDEX name_index ON people(name);')
1031/8:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

# c.execute('CREATE INDEX person_index ON stars(person_id);')
# c.execute('CREATE INDEX movie_index ON stars(movie_id);')
c.execute('CREATE INDEX name_index ON people(name);')
1031/9:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1031/10:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1031/11:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1031/12:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1031/13:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1031/14:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1031/15:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1031/16:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1031/17:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1031/18:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1032/1: import sqlite3
1032/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

# c.execute('CREATE INDEX person_index ON stars(person_id);')
# c.execute('CREATE INDEX movie_index ON stars(movie_id);')
# c.execute('CREATE INDEX name_index ON people(name);')
1032/3:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1032/4:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1032/5:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1032/6:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1032/7:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1032/8:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1032/9:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1032/10:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1032/11:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1032/12:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1032/13:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1032/14:
task = """
        SELECT DISTINCT(name) from directors
        LEFT OUTER JOIN people
        ON directors.person_id = people.id
        INNER JOIN stars
        ON directors.person_id = stars.person_id
        LEFT OUTER JOIN ratings
        ON directors.movie_id = ratings.movie_id
        LEFT OUTER JOIN movies
        ON directors.movie_id = movies.id
        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
1032/15:
task = """
        SELECT name, title, rating FROM movies
        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE name = 'Chadwick Boseman'
        ORDER BY rating DESC
        LIMIT 5;
"""

sql_eleven = execute_task(task)
sql_eleven.fetchall()
1032/16:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter'
        
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""

sql_twelve = execute_task(task)
sql_twelve.fetchall()
1032/17:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
"""

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        


sql_twelve = execute_task(task)
sql_twelve = execute_task(task2)
sql_twelve.fetchall()
1032/18:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
"""

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        


sql_twelve = execute_task(task)
sql_twelve = execute_task(task2)
sql_twelve.fetchall()
1032/19:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
"""

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        


sql_twelve = execute_task(task)
sql_twelve = execute_task(task_2)
sql_twelve.fetchall()
1032/20:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
"""

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        


sql_twelve = c.execute(task)
sql_twelve = execute_task(task_2)
sql_twelve.fetchall()
1032/21:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
"""

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        


sql_twelve = c.execute(task)
sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1032/22:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
"""

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        


sql_twelve = c.execute(task)
c.commit()
sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1032/23:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
"""

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        


sql_twelve = c.execute(task)
conn.commit()
sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1033/1: import sqlite3
1033/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

# c.execute('CREATE INDEX person_index ON stars(person_id);')
# c.execute('CREATE INDEX movie_index ON stars(movie_id);')
# c.execute('CREATE INDEX name_index ON people(name);')
1033/3:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1033/4:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1033/5:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1033/6:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1033/7:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1033/8:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1033/9:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1033/10:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1033/11:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1033/12:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1033/13:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1033/14:
task = """
        SELECT DISTINCT(name) from directors
        LEFT OUTER JOIN people
        ON directors.person_id = people.id
        INNER JOIN stars
        ON directors.person_id = stars.person_id
        LEFT OUTER JOIN ratings
        ON directors.movie_id = ratings.movie_id
        LEFT OUTER JOIN movies
        ON directors.movie_id = movies.id
        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
1033/15:
task = """
        SELECT name, title, rating FROM movies
        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE name = 'Chadwick Boseman'
        ORDER BY rating DESC, title ASC
        LIMIT 5;
"""

sql_eleven = execute_task(task)
sql_eleven.fetchall()
1033/16:
task = """
        CREATE VIEW jd_hbc AS

        SELECT 
            movie_id,
            person_id,
            title,
            name
        FROM movies

        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
"""

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        


sql_twelve = c.execute(task)
conn.commit()
sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1033/17:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Error as e:
    print(e)

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        



sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1033/18:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        



sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1033/19:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

# task_2 = """
#         SELECT movie_id, title, count(movie_id) FROM jd_hbc
#         GROUP BY movie_id, title
#         HAVING count(movie_id) = 2;
# """        



# sql_twelve = c.execute(task_2)
# sql_twelve.fetchall()
1034/1: import sqlite3
1034/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

# c.execute('CREATE INDEX person_index ON stars(person_id);')
# c.execute('CREATE INDEX movie_index ON stars(movie_id);')
# c.execute('CREATE INDEX name_index ON people(name);')
1034/3:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1034/4:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1034/5:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1034/6:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1034/7:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1034/8:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1034/9:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1034/10:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1034/11:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1034/12:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1034/13:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1034/14:
task = """
        SELECT DISTINCT(name) from directors
        LEFT OUTER JOIN people
        ON directors.person_id = people.id
        INNER JOIN stars
        ON directors.person_id = stars.person_id
        LEFT OUTER JOIN ratings
        ON directors.movie_id = ratings.movie_id
        LEFT OUTER JOIN movies
        ON directors.movie_id = movies.id
        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
1034/15:
task = """
        SELECT name, title, rating FROM movies
        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE name = 'Chadwick Boseman'
        ORDER BY rating DESC, title ASC
        LIMIT 5;
"""

sql_eleven = execute_task(task)
sql_eleven.fetchall()
1034/16:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter;'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

# task_2 = """
#         SELECT movie_id, title, count(movie_id) FROM jd_hbc
#         GROUP BY movie_id, title
#         HAVING count(movie_id) = 2;
# """        



# sql_twelve = c.execute(task_2)
# sql_twelve.fetchall()
1035/1: import sqlite3
1035/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

c.execute('CREATE INDEX person_index ON stars(person_id);')
c.execute('CREATE INDEX movie_index ON stars(movie_id);')
c.execute('CREATE INDEX name_index ON people(name);')
1035/3:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

try:
    c.execute('CREATE INDEX person_index ON stars(person_id);')
    c.execute('CREATE INDEX movie_index ON stars(movie_id);')
    c.execute('CREATE INDEX name_index ON people(name);')
except Exception as e:
    print(e)
1035/4:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1035/5:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1035/6:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1035/7:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1035/8:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1035/9:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1035/10:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1035/11:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1035/12:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1035/13:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1035/14:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1035/15:
task = """
        SELECT DISTINCT(name) from directors
        LEFT OUTER JOIN people
        ON directors.person_id = people.id
        INNER JOIN stars
        ON directors.person_id = stars.person_id
        LEFT OUTER JOIN ratings
        ON directors.movie_id = ratings.movie_id
        LEFT OUTER JOIN movies
        ON directors.movie_id = movies.id
        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
1035/16:
task = """
        SELECT name, title, rating FROM movies
        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE name = 'Chadwick Boseman'
        ORDER BY rating DESC, title ASC
        LIMIT 5;
"""

sql_eleven = execute_task(task)
sql_eleven.fetchall()
1035/17:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

task_2 = """
        SELECT movie_id, title, count(movie_id) FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        



sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1035/18:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

task_2 = """
        SELECT title FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        

sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1036/1: import sqlite3
1036/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

try:
    c.execute('CREATE INDEX person_index ON stars(person_id);')
    c.execute('CREATE INDEX movie_index ON stars(movie_id);')
    c.execute('CREATE INDEX name_index ON people(name);')
except Exception as e:
    print(e)
1036/3:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1036/4:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1036/5:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1036/6:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1036/7:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1036/8:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1036/9:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1036/10:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1036/11:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1036/12:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1036/13:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1036/14:
task = """
        SELECT DISTINCT(name) from directors
        LEFT OUTER JOIN people
        ON directors.person_id = people.id
        INNER JOIN stars
        ON directors.person_id = stars.person_id
        LEFT OUTER JOIN ratings
        ON directors.movie_id = ratings.movie_id
        LEFT OUTER JOIN movies
        ON directors.movie_id = movies.id
        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
1036/15:
task = """
        SELECT name, title, rating FROM movies
        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE name = 'Chadwick Boseman'
        ORDER BY rating DESC, title ASC
        LIMIT 5;
"""

sql_eleven = execute_task(task)
sql_eleven.fetchall()
1036/16:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

task_2 = """
        SELECT title FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        

sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1037/1: import sqlite3
1037/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

try:
    c.execute('CREATE INDEX person_index ON stars(person_id);')
    c.execute('CREATE INDEX movie_index ON stars(movie_id);')
    c.execute('CREATE INDEX name_index ON people(name);')
except Exception as e:
    print(e)
1037/3:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1037/4:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1037/5:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1037/6:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1037/7:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1037/8:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1037/9:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1037/10:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1037/11:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1037/12:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1037/13:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE year = 2004
        ORDER BY birth DESC;
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1037/14:
task = """
        SELECT 
            DISTINCT(name)
        FROM directors

        LEFT OUTER JOIN ratings
            ON directors.movie_id = ratings.movie_id
        JOIN people
            ON directors.person_id = people.id

        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
1037/15:
task = """
        SELECT 
            DISTINCT(name)
        FROM directors

        LEFT OUTER JOIN ratings
            ON directors.movie_id = ratings.movie_id
        JOIN people
            ON directors.person_id = people.id

        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
print(len(sql_ten.fetchall))
1037/16:
task = """
        SELECT 
            DISTINCT(name)
        FROM directors

        LEFT OUTER JOIN ratings
            ON directors.movie_id = ratings.movie_id
        JOIN people
            ON directors.person_id = people.id

        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
sql_ten.fetchmany(10)
print(len(sql_ten.fetchall()))
1037/17:
task = """
        SELECT 
            DISTINCT(name)
        FROM directors

        LEFT OUTER JOIN ratings
            ON directors.movie_id = ratings.movie_id
        JOIN people
            ON directors.person_id = people.id

        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
print(len(sql_ten.fetchall()))
sql_ten.fetchmany(10)
1037/18:
task = """
        SELECT 
            DISTINCT(name)
        FROM directors

        LEFT OUTER JOIN ratings
            ON directors.movie_id = ratings.movie_id
        JOIN people
            ON directors.person_id = people.id

        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
print(len(sql_ten.fetchall()))
1038/1: import sqlite3
1038/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

try:
    c.execute('CREATE INDEX person_index ON stars(person_id);')
    c.execute('CREATE INDEX movie_index ON stars(movie_id);')
    c.execute('CREATE INDEX name_index ON people(name);')
except Exception as e:
    print(e)
1038/3:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1038/4:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1038/5:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1038/6:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1038/7:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1038/8:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1038/9:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1038/10:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1038/11:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1038/12:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1038/13:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1038/14:
task = """
        SELECT DISTINCT(person_id), name FROM stars
        JOIN people
        ON stars.person_id = people.id
        WHERE movie_id IN (
            SELECT id FROM movies
            WHERE year = 2004
        );
"""

sql_nine = execute_task(task)
sql_nine.fetchmany(10)
1038/15:
task = """
        SELECT 
            DISTINCT(name)
        FROM directors

        LEFT OUTER JOIN ratings
            ON directors.movie_id = ratings.movie_id
        JOIN people
            ON directors.person_id = people.id

        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
print(len(sql_ten.fetchall()))
1038/16:
task = """
        SELECT DISTINCT(person_id), name FROM stars
        JOIN people
        ON stars.person_id = people.id
        WHERE movie_id IN (
            SELECT id FROM movies
            WHERE year = 2004
        );
"""

sql_nine = execute_task(task)
print(len(sql_nine.fetchall()))
## sql_nine.fetchmany(10)
1038/17:
task = """
        SELECT name, title, rating FROM movies
        JOIN stars
        ON movies.id = stars.movie_id
        JOIN people
        ON stars.person_id = people.id
        JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE name = 'Chadwick Boseman'
        ORDER BY rating DESC, title ASC
        LIMIT 5;
"""

sql_eleven = execute_task(task)
sql_eleven.fetchall()
1038/18:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

task_2 = """
        SELECT title FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        

sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1038/19:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

task_2 = """
        SELECT title FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        

sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1038/20:
CREATE VIEW kb_movies AS

SELECT 
    movie_id
FROM movies

JOIN stars
ON movies.id = stars.movie_id
JOIN people
ON stars.person_id = people.id
WHERE name = 'Kevin Bacon';
1038/21:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

try:
    c.execute('CREATE INDEX person_index ON stars(person_id);')
    c.execute('CREATE INDEX movie_index ON stars(movie_id);')
    c.execute('CREATE INDEX name_index ON people(name);')
except Exception as e:
    print(e)
1039/1: import sqlite3
1039/2:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

try:
    c.execute('CREATE INDEX people_index ON people(id);')
    c.execute('CREATE INDEX person_index ON stars(person_id);')
    c.execute('CREATE INDEX movie_index ON stars(movie_id);')
    c.execute('CREATE INDEX name_index ON people(name);')
except Exception as e:
    print(e)
1039/3: import sqlite3
1039/4:
conn = sqlite3.connect("movies.db")
c = conn.cursor()

try:
    c.execute('CREATE INDEX people_index ON people(id);')
    c.execute('CREATE INDEX person_index ON stars(person_id);')
    c.execute('CREATE INDEX movie_index ON stars(movie_id);')
    c.execute('CREATE INDEX name_index ON people(name);')
except Exception as e:
    print(e)
1039/5:
SELECT * FROM stars
LEFT OUTER JOIN people
ON stars.person_id = people.id;
1039/6:
def execute_task(task, connection = conn):
    c = connection.cursor()
    return c.execute(task)
1039/7:
directors = execute_task("SELECT * FROM directors;")
movies = execute_task("SELECT * FROM movies;")
ratings = execute_task("SELECT * FROM ratings;")
people = execute_task("SELECT * FROM people;")
stars = execute_task("SELECT * FROM stars;")
1039/8:
task = """
        SELECT title, year
        FROM movies
        WHERE year = 2008;
"""

sql_one = execute_task(task)
sql_one.fetchmany(10)
1039/9:
task = """
        SELECT name, birth
        FROM people
        WHERE name = 'Emma Stone';
"""

sql_two = execute_task(task)
sql_two.fetchone()
1039/10:
task = """
        SELECT title, year
        FROM movies
        WHERE year >= 2018
        ORDER BY title ASC;
"""

sql_three = execute_task(task)
sql_three.fetchmany(10)
1039/11:
# Join here is not necessary.
task = """
        SELECT COUNT(title) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE rating = 10.0;
"""

sql_four = execute_task(task)
sql_four.fetchone()
1039/12:
task = """
        SELECT * FROM movies
        WHERE title LIKE 'Harry Potter%'
        ORDER BY year ASC;
"""

sql_five = execute_task(task)
sql_five.fetchall()
1039/13:
task = """
        SELECT AVG(rating) FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2012;
"""

sql_six = execute_task(task)
sql_six.fetchall()[0][0]
1039/14:
task = """
        SELECT title, rating FROM movies
        INNER JOIN ratings
        ON movies.id = ratings.movie_id
        WHERE year = 2010
        ORDER BY rating DESC, title ASC;
"""

sql_seven = execute_task(task)
sql_seven.fetchmany(10)
1039/15:
task = """
        SELECT name FROM movies
        INNER JOIN stars
        ON movies.id = stars.movie_id
        INNER JOIN people
        ON stars.person_id = people.id
        WHERE title = 'Toy Story';
"""

sql_eight = execute_task(task)
sql_eight.fetchall()
1039/16:
task = """
        SELECT 
            DISTINCT(person_id),
            name
        FROM stars
        
        JOIN people
            ON stars.person_id = people.id
        
        WHERE movie_id IN (
            SELECT id FROM movies
            WHERE year = 2004
        );
"""

sql_nine = execute_task(task)
print(len(sql_nine.fetchall()))
## sql_nine.fetchmany(10)
1039/17:
task = """
        SELECT 
            DISTINCT(name)
        FROM directors

        LEFT OUTER JOIN ratings
            ON directors.movie_id = ratings.movie_id
        JOIN people
            ON directors.person_id = people.id

        WHERE rating >= 9.0;
"""

sql_ten = execute_task(task)
print(len(sql_ten.fetchall()))
1039/18:
task = """
        SELECT 
            name,
            title,
            rating
        FROM movies

        JOIN stars
            ON movies.id = stars.movie_id
        JOIN people
            ON stars.person_id = people.id
        JOIN ratings
            ON movies.id = ratings.movie_id

        WHERE name = 'Chadwick Boseman'
        ORDER BY 
            rating DESC,
            title ASC
        LIMIT 5;
"""

sql_eleven = execute_task(task)
sql_eleven.fetchall()
1039/19:
try:
    task = """
            CREATE VIEW jd_hbc AS

            SELECT 
                movie_id,
                person_id,
                title,
                name
            FROM movies

            JOIN stars
            ON movies.id = stars.movie_id
            JOIN people
            ON stars.person_id = people.id
            WHERE name = 'Johnny Depp' or name = 'Helena Bonham Carter'
    """
    sql_twelve = c.execute(task)
    conn.commit()
except Exception as e:
    print(e)

task_2 = """
        SELECT title FROM jd_hbc
        GROUP BY movie_id, title
        HAVING count(movie_id) = 2;
"""        

sql_twelve = c.execute(task_2)
sql_twelve.fetchall()
1039/20:
task = """
        SELECT 
            DISTINCT(name)
        FROM stars

        LEFT OUTER JOIN people
            ON stars.person_id = people.id
        WHERE movie_id IN(
        SELECT 
            movie_id
        FROM stars

        LEFT OUTER JOIN people
            ON stars.person_id = people.id
        WHERE name = 'Kevin Bacon'
            AND birth = 1958
        )
        AND name != 'Kevin Bacon';
"""        

sql_thirteen = c.execute(task)
sql_thirteen.fetchall()
1039/21:
task = """
        SELECT 
            DISTINCT(name)
        FROM stars

        LEFT OUTER JOIN people
            ON stars.person_id = people.id
        WHERE movie_id IN(
        SELECT 
            movie_id
        FROM stars

        LEFT OUTER JOIN people
            ON stars.person_id = people.id
        WHERE name = 'Kevin Bacon'
            AND birth = 1958
        )
        AND name != 'Kevin Bacon';
"""        

sql_thirteen = c.execute(task)
print(len(sql_thirteen.fetchall()))
# sql_thirteen.fetchall()
   1: %history -g
   2: %history -g -f filename
